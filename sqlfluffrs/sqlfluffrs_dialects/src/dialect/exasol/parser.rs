/* This is a generated file! */
#![cfg_attr(rustfmt, rustfmt_skip)]
use std::sync::Arc;
use once_cell::sync::Lazy;
use sqlfluffrs_types::{Grammar, ParseMode, SimpleHint};

// name='AbsKeywordSegment'
pub static ABS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ABS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AbsoluteKeywordSegment'
pub static ABSOLUTE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ABSOLUTE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AccessKeywordSegment'
pub static ACCESS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ACCESS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AccessStatementSegment'
pub static ACCESS_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AccessStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "GrantKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GRANT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RevokeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REVOKE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GRANT".to_string(), "REVOKE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "GrantRevokeSystemPrivilegesSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ACCESS".to_string(), "ALL".to_string(), "ALTER".to_string(), "CREATE".to_string(), "DELETE".to_string(), "DROP".to_string(), "EXECUTE".to_string(), "EXPORT".to_string(), "GRANT".to_string(), "IMPERSONATE".to_string(), "IMPORT".to_string(), "INSERT".to_string(), "KILL".to_string(), "MANAGE".to_string(), "SELECT".to_string(), "SET".to_string(), "UPDATE".to_string(), "USE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "GrantRevokeObjectPrivilegesSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string(), "ALTER".to_string(), "DELETE".to_string(), "EXECUTE".to_string(), "EXPORT".to_string(), "IMPORT".to_string(), "INSERT".to_string(), "REFERENCES".to_string(), "SELECT".to_string(), "UPDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "GrantRevokeRolesSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "GrantRevokeImpersonationSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IMPERSONATION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "GrantRevokeConnectionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONNECTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "GrantRevokeConnectionRestrictedSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ACCESS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GRANT".to_string(), "REVOKE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AccessorGrammar'
pub static ACCESSOR_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ArrayAccessorSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["[".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["[".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AcosKeywordSegment'
pub static ACOS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ACOS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ActionKeywordSegment'
pub static ACTION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ACTION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AdapterKeywordSegment'
pub static ADAPTER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ADAPTER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AddKeywordSegment'
pub static ADD_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ADD",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Add_daysKeywordSegment'
pub static ADD_DAYS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ADD_DAYS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Add_hoursKeywordSegment'
pub static ADD_HOURS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ADD_HOURS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Add_minutesKeywordSegment'
pub static ADD_MINUTES_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ADD_MINUTES",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Add_monthsKeywordSegment'
pub static ADD_MONTHS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ADD_MONTHS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Add_secondsKeywordSegment'
pub static ADD_SECONDS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ADD_SECONDS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Add_weeksKeywordSegment'
pub static ADD_WEEKS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ADD_WEEKS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Add_yearsKeywordSegment'
pub static ADD_YEARS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ADD_YEARS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AdminKeywordSegment'
pub static ADMIN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ADMIN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AfterKeywordSegment'
pub static AFTER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "AFTER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AggregateOrderByClause'
pub static AGGREGATE_ORDER_BY_CLAUSE: Lazy<Arc<Grammar>> = Lazy::new(||
// AggregateOrderByClause
Arc::new(Grammar::Ref {
    name: "OrderByClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AliasExpressionSegment'
pub static ALIAS_EXPRESSION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AliasExpressionSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::Ref {
    name: "AsAliasOperatorSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierListSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "SingleQuotedIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["single_quote".to_string()]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("dedent"))
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='AliasedTableReferenceGrammar'
pub static ALIASED_TABLE_REFERENCE_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AliasExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='AlignKeywordSegment'
pub static ALIGN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ALIGN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AllKeywordSegment'
pub static ALL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ALL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AllocateKeywordSegment'
pub static ALLOCATE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ALLOCATE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AlterConnectionSegment'
pub static ALTER_CONNECTION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AlterConnectionSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConnectionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONNECTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NakedIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConnectionDefinition",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AlterConsumerGroupSegment'
pub static ALTER_CONSUMER_GROUP_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AlterConsumerGroupSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConsumerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSUMER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "GroupKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ConsumerGroupParameterSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CPU_WEIGHT".to_string(), "GROUP_TEMP_DB_RAM_LIMIT".to_string(), "IDLE_TIMEOUT".to_string(), "PRECEDENCE".to_string(), "QUERY_TIMEOUT".to_string(), "SESSION_TEMP_DB_RAM_LIMIT".to_string(), "USER_TEMP_DB_RAM_LIMIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CPU_WEIGHT".to_string(), "GROUP_TEMP_DB_RAM_LIMIT".to_string(), "IDLE_TIMEOUT".to_string(), "PRECEDENCE".to_string(), "QUERY_TIMEOUT".to_string(), "SESSION_TEMP_DB_RAM_LIMIT".to_string(), "USER_TEMP_DB_RAM_LIMIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AlterKeywordSegment'
pub static ALTER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ALTER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AlterRoleStatementSegment'
pub static ALTER_ROLE_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AlterRoleStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RoleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RoleReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "Consumer_groupKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSUMER_GROUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "NullKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSUMER_GROUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AlterSchemaStatementSegment'
pub static ALTER_SCHEMA_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AlterSchemaStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Raw_size_limitKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RAW_SIZE_LIMIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StarSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["*".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["*".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ChangeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHANGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OwnerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OWNER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHANGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHANGE".to_string(), "SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AlterSequenceOptionsSegment'
pub static ALTER_SEQUENCE_OPTIONS_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AlterSequenceOptionsSegment
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IncrementKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "SequenceMinValueGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "SequenceMaxValueGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CacheKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "NocacheKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CycleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CYCLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NocycleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOCYCLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CYCLE".to_string(), "NOCYCLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OrderNoOrderGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='AlterSequenceStatementSegment'
pub static ALTER_SEQUENCE_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AlterSequenceStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SequenceKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SEQUENCE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SequenceReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterSequenceOptionsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AlterSessionSegment'
pub static ALTER_SESSION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AlterSessionSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SessionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SESSION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SessionParameterSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRAINT_STATE_DEFAULT".to_string(), "DEFAULT_LIKE_ESCAPE_CHARACTER".to_string(), "HASHTYPE_FORMAT".to_string(), "IDLE_TIMEOUT".to_string(), "NICE".to_string(), "NLS_DATE_FORMAT".to_string(), "NLS_DATE_LANGUAGE".to_string(), "NLS_FIRST_DAY_OF_WEEK".to_string(), "NLS_NUMERIC_CHARACTERS".to_string(), "NLS_TIMESTAMP_FORMAT".to_string(), "PROFILE".to_string(), "QUERY_CACHE".to_string(), "QUERY_TIMEOUT".to_string(), "SCRIPT_LANGUAGES".to_string(), "SCRIPT_OUTPUT_ADDRESS".to_string(), "SESSION_TEMP_DB_RAM_LIMIT".to_string(), "SNAPSHOT_MODE".to_string(), "SQL_PREPROCESSOR_SCRIPT".to_string(), "ST_MAX_DECIMAL_DIGITS".to_string(), "TIMESTAMP_ARITHMETIC_BEHAVIOR".to_string(), "TIME_ZONE".to_string(), "TIME_ZONE_BEHAVIOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string(), "single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AlterSystemSegment'
pub static ALTER_SYSTEM_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AlterSystemSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SystemKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SYSTEM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SystemParameterSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRAINT_STATE_DEFAULT".to_string(), "DEFAULT_CONSUMER_GROUP".to_string(), "DEFAULT_LIKE_ESCAPE_CHARACTER".to_string(), "HASHTYPE_FORMAT".to_string(), "IDLE_TIMEOUT".to_string(), "NLS_DATE_FORMAT".to_string(), "NLS_DATE_LANGUAGE".to_string(), "NLS_FIRST_DAY_OF_WEEK".to_string(), "NLS_NUMERIC_CHARACTERS".to_string(), "NLS_TIMESTAMP_FORMAT".to_string(), "PASSWORD_EXPIRY_POLICY".to_string(), "PASSWORD_SECURITY_POLICY".to_string(), "PROFILE".to_string(), "QUERY_CACHE".to_string(), "QUERY_TIMEOUT".to_string(), "SCRIPT_LANGUAGES".to_string(), "SCRIPT_OUTPUT_ADDRESS".to_string(), "SESSION_TEMP_DB_RAM_LIMIT".to_string(), "SNAPSHOT_MODE".to_string(), "SQL_PREPROCESSOR_SCRIPT".to_string(), "ST_MAX_DECIMAL_DIGITS".to_string(), "TEMP_DB_RAM_LIMIT".to_string(), "TIMESTAMP_ARITHMETIC_BEHAVIOR".to_string(), "TIME_ZONE".to_string(), "TIME_ZONE_BEHAVIOR".to_string(), "USER_TEMP_DB_RAM_LIMIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string(), "single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AlterTableAddColumnSegment'
pub static ALTER_TABLE_ADD_COLUMN_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AlterTableAddColumnSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AddKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLUMN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfNotExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColumnDefinitionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnDefinitionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AlterTableAlterColumnSegment'
pub static ALTER_TABLE_ALTER_COLUMN_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AlterTableAlterColumnSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLUMN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IdentityKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IDENTITY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IDENTITY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DefaultKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "BareFunctionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONNECT_BY_ISCYCLE".to_string(), "CONNECT_BY_ISLEAF".to_string(), "CONNECT_BY_ROOT".to_string(), "CURDATE".to_string(), "CURRENT_DATE".to_string(), "CURRENT_SCHEMA".to_string(), "CURRENT_SESSION".to_string(), "CURRENT_STATEMENT".to_string(), "CURRENT_TIMESTAMP".to_string(), "CURRENT_USER".to_string(), "DBTIMEZONE".to_string(), "LEVEL".to_string(), "LOCALTIMESTAMP".to_string(), "NOW".to_string(), "ROWID".to_string(), "ROWNUM".to_string(), "SESSIONTIMEZONE".to_string(), "SYSDATE".to_string(), "SYSTIMESTAMP".to_string(), "USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string(), "IDENTITY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IdentityKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IDENTITY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DefaultKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string(), "IDENTITY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string(), "SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AlterTableColumnSegment'
pub static ALTER_TABLE_COLUMN_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AlterTableColumnSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterTableAddColumnSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AlterTableDropColumnSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AlterTableModifyColumnSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MODIFY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AlterTableRenameColumnSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AlterTableAlterColumnSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string(), "ALTER".to_string(), "DROP".to_string(), "MODIFY".to_string(), "RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AlterTableConstraintSegment'
pub static ALTER_TABLE_CONSTRAINT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AlterTableConstraintSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AddKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableOutOfLineConstraintSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRAINT".to_string(), "FOREIGN".to_string(), "PRIMARY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ModifyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MODIFY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ConstraintKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRAINT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRAINT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PrimaryKeyGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PRIMARY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRAINT".to_string(), "PRIMARY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableConstraintEnableDisableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DISABLE".to_string(), "ENABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MODIFY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ConstraintKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRAINT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRAINT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PrimaryKeyGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PRIMARY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRAINT".to_string(), "PRIMARY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RenameKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConstraintKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRAINT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string(), "DROP".to_string(), "MODIFY".to_string(), "RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AlterTableDistributePartitionSegment'
pub static ALTER_TABLE_DISTRIBUTE_PARTITION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AlterTableDistributePartitionSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TableDistributionPartitionClause",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DISTRIBUTE".to_string(), "PARTITION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DistributionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DISTRIBUTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AndKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AND".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PartitionKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PARTITION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DISTRIBUTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PartitionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PARTITION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AndKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AND".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DistributionKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DISTRIBUTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PARTITION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DISTRIBUTION".to_string(), "PARTITION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "KeysKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["KEYS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DISTRIBUTE".to_string(), "DROP".to_string(), "PARTITION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AlterTableDropColumnGrammar'
pub static ALTER_TABLE_DROP_COLUMN_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLUMN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AlterTableDropColumnSegment'
pub static ALTER_TABLE_DROP_COLUMN_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AlterTableDropColumnSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLUMN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CascadeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConstraintsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRAINTS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AlterTableModifyColumnSegment'
pub static ALTER_TABLE_MODIFY_COLUMN_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AlterTableModifyColumnSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ModifyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MODIFY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLUMN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DatatypeSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BIGINT".to_string(), "BOOL".to_string(), "BOOLEAN".to_string(), "CHAR".to_string(), "CHARACTER".to_string(), "CLOB".to_string(), "DATE".to_string(), "DEC".to_string(), "DECIMAL".to_string(), "DOUBLE".to_string(), "FLOAT".to_string(), "GEOMETRY".to_string(), "HASHTYPE".to_string(), "INT".to_string(), "INTEGER".to_string(), "INTERVAL".to_string(), "LONG".to_string(), "NCHAR".to_string(), "NUMBER".to_string(), "NUMERIC".to_string(), "NVARCHAR".to_string(), "NVARCHAR2".to_string(), "REAL".to_string(), "SHORTINT".to_string(), "SMALLINT".to_string(), "TIMESTAMP".to_string(), "TINYINT".to_string(), "VARCHAR".to_string(), "VARCHAR2".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnConstraintSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COMMENT".to_string(), "CONSTRAINT".to_string(), "DEFAULT".to_string(), "IDENTITY".to_string(), "NOT".to_string(), "NULL".to_string(), "PRIMARY".to_string(), "REFERENCES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DatatypeSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BIGINT".to_string(), "BOOL".to_string(), "BOOLEAN".to_string(), "CHAR".to_string(), "CHARACTER".to_string(), "CLOB".to_string(), "DATE".to_string(), "DEC".to_string(), "DECIMAL".to_string(), "DOUBLE".to_string(), "FLOAT".to_string(), "GEOMETRY".to_string(), "HASHTYPE".to_string(), "INT".to_string(), "INTEGER".to_string(), "INTERVAL".to_string(), "LONG".to_string(), "NCHAR".to_string(), "NUMBER".to_string(), "NUMERIC".to_string(), "NVARCHAR".to_string(), "NVARCHAR2".to_string(), "REAL".to_string(), "SHORTINT".to_string(), "SMALLINT".to_string(), "TIMESTAMP".to_string(), "TINYINT".to_string(), "VARCHAR".to_string(), "VARCHAR2".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnConstraintSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COMMENT".to_string(), "CONSTRAINT".to_string(), "DEFAULT".to_string(), "IDENTITY".to_string(), "NOT".to_string(), "NULL".to_string(), "PRIMARY".to_string(), "REFERENCES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MODIFY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AlterTableOptionsGrammar'
pub static ALTER_TABLE_OPTIONS_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "NakedIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AddKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ModifyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MODIFY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string(), "MODIFY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLUMN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnDefinitionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FirstKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FIRST".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AfterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AFTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AFTER".to_string(), "FIRST".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AFTER".to_string(), "FIRST".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BracketedColumnReferenceListGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "AFTER".to_string(), "FIRST".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string(), "MODIFY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AlterTableDropColumnGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RenameKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string(), "TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='AlterTableRenameColumnSegment'
pub static ALTER_TABLE_RENAME_COLUMN_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AlterTableRenameColumnSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RenameKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLUMN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AlterTableStatementSegment'
pub static ALTER_TABLE_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AlterTableStatementSegment
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterTableColumnSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AlterTableConstraintSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AlterTableDistributePartitionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AlterUserStatementSegment'
pub static ALTER_USER_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AlterUserStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UserKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RoleReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IdentifiedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IDENTIFIED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "UserPasswordAuthSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ReplaceKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REPLACE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PasswordLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["double_quote".to_string()]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REPLACE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UserLDAPAuthSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UserKerberosAuthSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UserOpenIDAuthSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AT".to_string(), "BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IDENTIFIED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "Password_expiry_policyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PASSWORD_EXPIRY_POLICY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PASSWORD_EXPIRY_POLICY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PasswordKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PASSWORD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpireKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXPIRE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PASSWORD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ResetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FailedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FAILED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LoginKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LOGIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AttemptsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ATTEMPTS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Consumer_groupKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSUMER_GROUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "NullKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IDENTIFIED".to_string(), "PASSWORD".to_string(), "PASSWORD_EXPIRY_POLICY".to_string(), "RESET".to_string(), "SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AlterVirtualSchemaStatementSegment'
pub static ALTER_VIRTUAL_SCHEMA_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AlterVirtualSchemaStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "VirtualKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VIRTUAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RefreshKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REFRESH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TablesKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REFRESH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ChangeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHANGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OwnerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OWNER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHANGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHANGE".to_string(), "REFRESH".to_string(), "SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AlwaysKeywordSegment'
pub static ALWAYS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ALWAYS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AmpersandSegment'
pub static AMPERSAND_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "&",
    token_type: "ampersand",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='AnalyzeKeywordSegment'
pub static ANALYZE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ANALYZE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AndKeywordSegment'
pub static AND_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "AND",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AndOperatorGrammar'
pub static AND_OPERATOR_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "AND",
    token_type: "binary_operator",
    raw_class: "BinaryOperatorSegment",
    optional: false,
})
);

// name='AnsiKeywordSegment'
pub static ANSI_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ANSI",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AnyKeywordSegment'
pub static ANY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ANY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AppendKeywordSegment'
pub static APPEND_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "APPEND",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Approximate_count_distinctKeywordSegment'
pub static APPROXIMATE_COUNT_DISTINCT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "APPROXIMATE_COUNT_DISTINCT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AreKeywordSegment'
pub static ARE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ARE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ArithmeticBinaryOperatorGrammar'
pub static ARITHMETIC_BINARY_OPERATOR_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PlusSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["+".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MinusSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["-".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DivideSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["/".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MultiplySegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["*".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ModuloSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["%".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BitwiseAndSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["&".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BitwiseOrSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["|".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BitwiseXorSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["^".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BitwiseLShiftSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["<".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BitwiseRShiftSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([">".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["%".to_string(), "&".to_string(), "*".to_string(), "+".to_string(), "-".to_string(), "/".to_string(), "<".to_string(), ">".to_string(), "^".to_string(), "|".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ArrayAccessorSegment'
pub static ARRAY_ACCESSOR_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ArrayAccessorSegment
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "SliceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([":".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "[",
    token_type: "start_square_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: "]",
    token_type: "end_square_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Greedy,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["[".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ArrayExpressionSegment'
pub static ARRAY_EXPRESSION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ArrayExpressionSegment
Arc::new(Grammar::Nothing())
);

// name='ArrayKeywordSegment'
pub static ARRAY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ARRAY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ArrayLiteralSegment'
pub static ARRAY_LITERAL_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ArrayLiteralSegment
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "BaseExpressionElementGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: true,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "[",
    token_type: "start_square_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: "]",
    token_type: "end_square_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["[".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ArrayTypeSegment'
pub static ARRAY_TYPE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ArrayTypeSegment
Arc::new(Grammar::Nothing())
);

// name='AsAliasOperatorSegment'
pub static AS_ALIAS_OPERATOR_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AsAliasOperatorSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AsKeywordSegment'
pub static AS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "AS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AscKeywordSegment'
pub static ASC_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ASC",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AsciiKeywordSegment'
pub static ASCII_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ASCII",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AsensitiveKeywordSegment'
pub static ASENSITIVE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ASENSITIVE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AsinKeywordSegment'
pub static ASIN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ASIN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AssertionKeywordSegment'
pub static ASSERTION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ASSERTION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AssignmentKeywordSegment'
pub static ASSIGNMENT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ASSIGNMENT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AsymmetricKeywordSegment'
pub static ASYMMETRIC_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ASYMMETRIC",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AtKeywordSegment'
pub static AT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "AT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Atan2KeywordSegment'
pub static ATAN2_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ATAN2",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AtanKeywordSegment'
pub static ATAN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ATAN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AtomicKeywordSegment'
pub static ATOMIC_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ATOMIC",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AttemptsKeywordSegment'
pub static ATTEMPTS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ATTEMPTS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AttributeKeywordSegment'
pub static ATTRIBUTE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ATTRIBUTE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AuditKeywordSegment'
pub static AUDIT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "AUDIT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AuthenticatedKeywordSegment'
pub static AUTHENTICATED_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "AUTHENTICATED",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AuthidKeywordSegment'
pub static AUTHID_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "AUTHID",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AuthorizationKeywordSegment'
pub static AUTHORIZATION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "AUTHORIZATION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AutoIncrementGrammar'
pub static AUTO_INCREMENT_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "Auto_incrementKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='AutoKeywordSegment'
pub static AUTO_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "AUTO",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AvgKeywordSegment'
pub static AVG_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "AVG",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='BackupKeywordSegment'
pub static BACKUP_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "BACKUP",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='BareFunctionSegment'
pub static BARE_FUNCTION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::MultiStringParser {
    templates: vec!["CONNECT_BY_ISCYCLE", "CONNECT_BY_ISLEAF", "CONNECT_BY_ROOT", "CURDATE", "CURRENT_DATE", "CURRENT_SCHEMA", "CURRENT_SESSION", "CURRENT_STATEMENT", "CURRENT_TIMESTAMP", "CURRENT_USER", "DBTIMEZONE", "LEVEL", "LOCALTIMESTAMP", "NOW", "ROWID", "ROWNUM", "SESSIONTIMEZONE", "SYSDATE", "SYSTIMESTAMP", "USER"],
    token_type: "bare_function",
    raw_class: "CodeSegment",
    optional: false,
})
);

// name='BaseExpressionElementGrammar'
pub static BASE_EXPRESSION_ELEMENT_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "BareFunctionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONNECT_BY_ISCYCLE".to_string(), "CONNECT_BY_ISLEAF".to_string(), "CONNECT_BY_ROOT".to_string(), "CURDATE".to_string(), "CURRENT_DATE".to_string(), "CURRENT_SCHEMA".to_string(), "CURRENT_SESSION".to_string(), "CURRENT_STATEMENT".to_string(), "CURRENT_TIMESTAMP".to_string(), "CURRENT_USER".to_string(), "DBTIMEZONE".to_string(), "LEVEL".to_string(), "LOCALTIMESTAMP".to_string(), "NOW".to_string(), "ROWID".to_string(), "ROWNUM".to_string(), "SESSIONTIMEZONE".to_string(), "SYSDATE".to_string(), "SYSTIMESTAMP".to_string(), "USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IntervalExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INTERVAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DatatypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BIGINT".to_string(), "BOOL".to_string(), "BOOLEAN".to_string(), "CHAR".to_string(), "CHARACTER".to_string(), "CLOB".to_string(), "DATE".to_string(), "DEC".to_string(), "DECIMAL".to_string(), "DOUBLE".to_string(), "FLOAT".to_string(), "GEOMETRY".to_string(), "HASHTYPE".to_string(), "INT".to_string(), "INTEGER".to_string(), "INTERVAL".to_string(), "LONG".to_string(), "NCHAR".to_string(), "NUMBER".to_string(), "NUMERIC".to_string(), "NVARCHAR".to_string(), "NVARCHAR2".to_string(), "REAL".to_string(), "SHORTINT".to_string(), "SMALLINT".to_string(), "TIMESTAMP".to_string(), "TINYINT".to_string(), "VARCHAR".to_string(), "VARCHAR2".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BIGINT".to_string(), "BOOL".to_string(), "BOOLEAN".to_string(), "CHAR".to_string(), "CHARACTER".to_string(), "CLOB".to_string(), "DATE".to_string(), "DEC".to_string(), "DECIMAL".to_string(), "DOUBLE".to_string(), "FLOAT".to_string(), "GEOMETRY".to_string(), "HASHTYPE".to_string(), "INT".to_string(), "INTEGER".to_string(), "INTERVAL".to_string(), "LONG".to_string(), "NCHAR".to_string(), "NUMBER".to_string(), "NUMERIC".to_string(), "NVARCHAR".to_string(), "NVARCHAR2".to_string(), "REAL".to_string(), "SHORTINT".to_string(), "SMALLINT".to_string(), "TIMESTAMP".to_string(), "TINYINT".to_string(), "VARCHAR".to_string(), "VARCHAR2".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='BaseFileSegment'
pub static BASE_FILE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Token{
    token_type: "file",
//    token_type: "BaseFileSegment",
})
);

// name='BaseSegment'
pub static BASE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Token{
    token_type: "base",
//    token_type: "BaseSegment",
})
);

// name='BeforeKeywordSegment'
pub static BEFORE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "BEFORE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='BeginKeywordSegment'
pub static BEGIN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "BEGIN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='BernoulliKeywordSegment'
pub static BERNOULLI_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "BERNOULLI",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='BetweenKeywordSegment'
pub static BETWEEN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "BETWEEN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='BigintKeywordSegment'
pub static BIGINT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "BIGINT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='BinaryKeywordSegment'
pub static BINARY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "BINARY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='BinaryOperatorGrammar'
pub static BINARY_OPERATOR_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ArithmeticBinaryOperatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["%".to_string(), "&".to_string(), "*".to_string(), "+".to_string(), "-".to_string(), "/".to_string(), "<".to_string(), ">".to_string(), "^".to_string(), "|".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StringBinaryOperatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["|".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BooleanBinaryOperatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AND".to_string(), "OR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ComparisonOperatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["!".to_string(), "<".to_string(), "=".to_string(), ">".to_string(), "IS".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["like_operator".to_string()]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["!".to_string(), "%".to_string(), "&".to_string(), "*".to_string(), "+".to_string(), "-".to_string(), "/".to_string(), "<".to_string(), "=".to_string(), ">".to_string(), "AND".to_string(), "IS".to_string(), "OR".to_string(), "^".to_string(), "|".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["like_operator".to_string()]),
        }),
})
);

// name='BinaryOperatorSegment'
pub static BINARY_OPERATOR_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Token{
    token_type: "binary_operator",
//    token_type: "BinaryOperatorSegment",
})
);

// name='BitKeywordSegment'
pub static BIT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "BIT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Bit_andKeywordSegment'
pub static BIT_AND_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "BIT_AND",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Bit_checkKeywordSegment'
pub static BIT_CHECK_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "BIT_CHECK",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Bit_lengthKeywordSegment'
pub static BIT_LENGTH_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "BIT_LENGTH",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Bit_lrotateKeywordSegment'
pub static BIT_LROTATE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "BIT_LROTATE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Bit_lshiftKeywordSegment'
pub static BIT_LSHIFT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "BIT_LSHIFT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Bit_notKeywordSegment'
pub static BIT_NOT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "BIT_NOT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Bit_orKeywordSegment'
pub static BIT_OR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "BIT_OR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Bit_rrotateKeywordSegment'
pub static BIT_RROTATE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "BIT_RROTATE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Bit_rshiftKeywordSegment'
pub static BIT_RSHIFT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "BIT_RSHIFT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Bit_setKeywordSegment'
pub static BIT_SET_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "BIT_SET",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Bit_to_numKeywordSegment'
pub static BIT_TO_NUM_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "BIT_TO_NUM",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Bit_xorKeywordSegment'
pub static BIT_XOR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "BIT_XOR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='BitwiseAndSegment'
pub static BITWISE_AND_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// BitwiseAndSegment
Arc::new(Grammar::Ref {
    name: "AmpersandSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["&".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='BitwiseLShiftSegment'
pub static BITWISE_L_SHIFT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// BitwiseLShiftSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RawLessThanSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["<".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RawLessThanSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["<".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: false,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["<".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='BitwiseOrSegment'
pub static BITWISE_OR_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// BitwiseOrSegment
Arc::new(Grammar::Ref {
    name: "PipeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["|".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='BitwiseRShiftSegment'
pub static BITWISE_R_SHIFT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// BitwiseRShiftSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RawGreaterThanSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([">".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RawGreaterThanSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([">".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: false,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([">".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='BitwiseXorSegment'
pub static BITWISE_XOR_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "^",
    token_type: "binary_operator",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='BlobKeywordSegment'
pub static BLOB_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "BLOB",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='BlockedKeywordSegment'
pub static BLOCKED_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "BLOCKED",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='BoolKeywordSegment'
pub static BOOL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "BOOL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='BooleanBinaryOperatorGrammar'
pub static BOOLEAN_BINARY_OPERATOR_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AndOperatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AND".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OrOperatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AND".to_string(), "OR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='BooleanKeywordSegment'
pub static BOOLEAN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "BOOLEAN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='BooleanLiteralGrammar'
pub static BOOLEAN_LITERAL_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TrueSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TRUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FalseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FALSE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UnknownSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UNKNOWN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FALSE".to_string(), "TRUE".to_string(), "UNKNOWN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='BothKeywordSegment'
pub static BOTH_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "BOTH",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='BracketedArguments'
pub static BRACKETED_ARGUMENTS: Lazy<Arc<Grammar>> = Lazy::new(||
// BracketedArguments
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: true,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "BitKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ByteKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BYTE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CharKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHAR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BIT".to_string(), "BYTE".to_string(), "CHAR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='BracketedColumnReferenceListGrammar'
pub static BRACKETED_COLUMN_REFERENCE_LIST_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='BracketedSegment'
pub static BRACKETED_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Token{
    token_type: "bracketed",
//    token_type: "BracketedSegment",
})
);

// name='BracketedSetExpressionGrammar'
pub static BRACKETED_SET_EXPRESSION_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "UnorderedSetExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "SELECT".to_string(), "VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='BreadthKeywordSegment'
pub static BREADTH_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "BREADTH",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ByKeywordSegment'
pub static BY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "BY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ByteKeywordSegment'
pub static BYTE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "BYTE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CSVColumnDefinitionSegment'
pub static C_S_V_COLUMN_DEFINITION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CSVColumnDefinitionSegment
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RangeOperator",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["range_operator".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FormatKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FORMAT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["single_quote".to_string()]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FORMAT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DelimitKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DELIMIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlwaysKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALWAYS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NeverKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NEVER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AutoKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AUTO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALWAYS".to_string(), "AUTO".to_string(), "NEVER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DELIMIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CTEColumnList'
pub static C_T_E_COLUMN_LIST: Lazy<Arc<Grammar>> = Lazy::new(||
// CTEColumnList
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierListSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CTEDefinitionSegment'
pub static C_T_E_DEFINITION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CTEDefinitionSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "CTEColumnList",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AsKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SelectableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "SELECT".to_string(), "VALUES".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Greedy,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='CallKeywordSegment'
pub static CALL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CALL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CalledKeywordSegment'
pub static CALLED_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CALLED",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CardinalityKeywordSegment'
pub static CARDINALITY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CARDINALITY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CascadeKeywordSegment'
pub static CASCADE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CASCADE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CascadedKeywordSegment'
pub static CASCADED_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CASCADED",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CaseExpressionSegment'
pub static CASE_EXPRESSION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CaseExpressionSegment
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CaseKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WhenClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "ElseKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ELSE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EndKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["END".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: true,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ElseClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "EndKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["END".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: true,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ELSE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("dedent"))
,
Arc::new(Grammar::Ref {
    name: "EndKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["END".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CaseKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WhenClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "ElseKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ELSE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EndKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["END".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: true,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ElseClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "EndKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["END".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: true,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ELSE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("dedent"))
,
Arc::new(Grammar::Ref {
    name: "EndKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["END".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "ComparisonOperatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["!".to_string(), "<".to_string(), "=".to_string(), ">".to_string(), "IS".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["like_operator".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BinaryOperatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["!".to_string(), "%".to_string(), "&".to_string(), "*".to_string(), "+".to_string(), "-".to_string(), "/".to_string(), "<".to_string(), "=".to_string(), ">".to_string(), "AND".to_string(), "IS".to_string(), "OR".to_string(), "^".to_string(), "|".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["like_operator".to_string()]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CaseKeywordSegment'
pub static CASE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CASE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CasespecificKeywordSegment'
pub static CASESPECIFIC_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CASESPECIFIC",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CastKeywordSegment'
pub static CAST_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CAST",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CastOperatorSegment'
pub static CAST_OPERATOR_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "::",
    token_type: "casting_operator",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='CatalogKeywordSegment'
pub static CATALOG_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CATALOG",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CeilKeywordSegment'
pub static CEIL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CEIL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CeilingKeywordSegment'
pub static CEILING_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CEILING",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ChainKeywordSegment'
pub static CHAIN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CHAIN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ChangeKeywordSegment'
pub static CHANGE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CHANGE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CharCharacterSetGrammar'
pub static CHAR_CHARACTER_SET_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "Utf8KeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UTF8".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AsciiKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ASCII".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ASCII".to_string(), "UTF8".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CharKeywordSegment'
pub static CHAR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CHAR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CharacterKeywordSegment'
pub static CHARACTER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CHARACTER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Character_lengthKeywordSegment'
pub static CHARACTER_LENGTH_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CHARACTER_LENGTH",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Character_set_catalogKeywordSegment'
pub static CHARACTER_SET_CATALOG_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CHARACTER_SET_CATALOG",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Character_set_nameKeywordSegment'
pub static CHARACTER_SET_NAME_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CHARACTER_SET_NAME",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Character_set_schemaKeywordSegment'
pub static CHARACTER_SET_SCHEMA_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CHARACTER_SET_SCHEMA",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CharacteristicsKeywordSegment'
pub static CHARACTERISTICS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CHARACTERISTICS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CharactersKeywordSegment'
pub static CHARACTERS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CHARACTERS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CheckKeywordSegment'
pub static CHECK_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CHECK",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CheckedKeywordSegment'
pub static CHECKED_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CHECKED",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ChrKeywordSegment'
pub static CHR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CHR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ClearKeywordSegment'
pub static CLEAR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CLEAR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ClobKeywordSegment'
pub static CLOB_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CLOB",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CloseKeywordSegment'
pub static CLOSE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CLOSE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CloseSchemaSegment'
pub static CLOSE_SCHEMA_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CloseSchemaSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CloseKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CLOSE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CLOSE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CoalesceKeywordSegment'
pub static COALESCE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "COALESCE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CobolKeywordSegment'
pub static COBOL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "COBOL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CodeSegment'
pub static CODE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Token{
    token_type: "raw",
//    token_type: "CodeSegment",
})
);

// name='CollateGrammar'
pub static COLLATE_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Nothing())
);

// name='CollateKeywordSegment'
pub static COLLATE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "COLLATE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CollationKeywordSegment'
pub static COLLATION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "COLLATION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CollationReferenceSegment'
pub static COLLATION_REFERENCE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CollationReferenceSegment
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "ObjectReferenceDelimiterGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "ObjectReferenceTerminatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    reset_terminators: false,
    allow_gaps: false,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='Collation_catalogKeywordSegment'
pub static COLLATION_CATALOG_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "COLLATION_CATALOG",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Collation_nameKeywordSegment'
pub static COLLATION_NAME_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "COLLATION_NAME",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Collation_schemaKeywordSegment'
pub static COLLATION_SCHEMA_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "COLLATION_SCHEMA",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Cologne_phoneticKeywordSegment'
pub static COLOGNE_PHONETIC_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "COLOGNE_PHONETIC",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ColonDelimiterSegment'
pub static COLON_DELIMITER_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: ":",
    token_type: "colon_delimiter",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='ColonPrefixSegment'
pub static COLON_PREFIX_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: ":",
    token_type: "colon_prefix",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='ColonSegment'
pub static COLON_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: ":",
    token_type: "colon",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='ColumnConstraintDefaultGrammar'
pub static COLUMN_CONSTRAINT_DEFAULT_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ShorthandCastSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "LiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "FunctionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "BareFunctionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONNECT_BY_ISCYCLE".to_string(), "CONNECT_BY_ISLEAF".to_string(), "CONNECT_BY_ROOT".to_string(), "CURDATE".to_string(), "CURRENT_DATE".to_string(), "CURRENT_SCHEMA".to_string(), "CURRENT_SESSION".to_string(), "CURRENT_STATEMENT".to_string(), "CURRENT_TIMESTAMP".to_string(), "CURRENT_USER".to_string(), "DBTIMEZONE".to_string(), "LEVEL".to_string(), "LOCALTIMESTAMP".to_string(), "NOW".to_string(), "ROWID".to_string(), "ROWNUM".to_string(), "SESSIONTIMEZONE".to_string(), "SYSDATE".to_string(), "SYSTIMESTAMP".to_string(), "USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='ColumnConstraintSegment'
pub static COLUMN_CONSTRAINT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ColumnConstraintSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DefaultKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "BareFunctionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONNECT_BY_ISCYCLE".to_string(), "CONNECT_BY_ISLEAF".to_string(), "CONNECT_BY_ROOT".to_string(), "CURDATE".to_string(), "CURRENT_DATE".to_string(), "CURRENT_SCHEMA".to_string(), "CURRENT_SESSION".to_string(), "CURRENT_STATEMENT".to_string(), "CURRENT_TIMESTAMP".to_string(), "CURRENT_USER".to_string(), "DBTIMEZONE".to_string(), "LEVEL".to_string(), "LOCALTIMESTAMP".to_string(), "NOW".to_string(), "ROWID".to_string(), "ROWNUM".to_string(), "SESSIONTIMEZONE".to_string(), "SYSDATE".to_string(), "SYSTIMESTAMP".to_string(), "USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IdentityKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IDENTITY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IDENTITY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string(), "IDENTITY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableInlineConstraintSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRAINT".to_string(), "NOT".to_string(), "NULL".to_string(), "PRIMARY".to_string(), "REFERENCES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CommentClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COMMENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COMMENT".to_string(), "CONSTRAINT".to_string(), "DEFAULT".to_string(), "IDENTITY".to_string(), "NOT".to_string(), "NULL".to_string(), "PRIMARY".to_string(), "REFERENCES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ColumnDatatypeSegment'
pub static COLUMN_DATATYPE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ColumnDatatypeSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DatatypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BIGINT".to_string(), "BOOL".to_string(), "BOOLEAN".to_string(), "CHAR".to_string(), "CHARACTER".to_string(), "CLOB".to_string(), "DATE".to_string(), "DEC".to_string(), "DECIMAL".to_string(), "DOUBLE".to_string(), "FLOAT".to_string(), "GEOMETRY".to_string(), "HASHTYPE".to_string(), "INT".to_string(), "INTEGER".to_string(), "INTERVAL".to_string(), "LONG".to_string(), "NCHAR".to_string(), "NUMBER".to_string(), "NUMERIC".to_string(), "NVARCHAR".to_string(), "NVARCHAR2".to_string(), "REAL".to_string(), "SHORTINT".to_string(), "SMALLINT".to_string(), "TIMESTAMP".to_string(), "TINYINT".to_string(), "VARCHAR".to_string(), "VARCHAR2".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='ColumnDefinitionSegment'
pub static COLUMN_DEFINITION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ColumnDefinitionSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColumnDatatypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ColumnConstraintSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COMMENT".to_string(), "CONSTRAINT".to_string(), "DEFAULT".to_string(), "IDENTITY".to_string(), "NOT".to_string(), "NULL".to_string(), "PRIMARY".to_string(), "REFERENCES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='ColumnGeneratedGrammar'
pub static COLUMN_GENERATED_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Nothing())
);

// name='ColumnKeywordSegment'
pub static COLUMN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "COLUMN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ColumnReferenceListGrammar'
pub static COLUMN_REFERENCE_LIST_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='ColumnReferenceSegment'
pub static COLUMN_REFERENCE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ColumnReferenceSegment
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "ObjectReferenceDelimiterGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "ObjectReferenceTerminatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    reset_terminators: false,
    allow_gaps: false,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='ColumnsExpressionFunctionContentsSegment'
pub static COLUMNS_EXPRESSION_FUNCTION_CONTENTS_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ColumnsExpressionFunctionContentsSegment
Arc::new(Grammar::Nothing())
);

// name='ColumnsExpressionFunctionNameSegment'
pub static COLUMNS_EXPRESSION_FUNCTION_NAME_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ColumnsExpressionFunctionNameSegment
Arc::new(Grammar::Ref {
    name: "ColumnsExpressionNameGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
);

// name='ColumnsExpressionGrammar'
pub static COLUMNS_EXPRESSION_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Nothing())
);

// name='ColumnsExpressionNameGrammar'
pub static COLUMNS_EXPRESSION_NAME_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Nothing())
);

// name='CommaSegment'
pub static COMMA_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: ",",
    token_type: "comma",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='CommentClauseSegment'
pub static COMMENT_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CommentClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CommentKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COMMENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COMMENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CommentKeywordSegment'
pub static COMMENT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "COMMENT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CommentSegment'
pub static COMMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Token{
    token_type: "comment",
//    token_type: "CommentSegment",
})
);

// name='CommentStatementSegment'
pub static COMMENT_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CommentStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CommentKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COMMENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TableKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["single_quote".to_string()]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "IsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColumnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLUMN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FUNCTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ScriptKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCRIPT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UserKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RoleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConnectionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONNECTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ConsumerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSUMER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "GroupKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSUMER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLUMN".to_string(), "CONNECTION".to_string(), "CONSUMER".to_string(), "FUNCTION".to_string(), "ROLE".to_string(), "SCHEMA".to_string(), "SCRIPT".to_string(), "USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "IsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLUMN".to_string(), "CONNECTION".to_string(), "CONSUMER".to_string(), "FUNCTION".to_string(), "ROLE".to_string(), "SCHEMA".to_string(), "SCRIPT".to_string(), "USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COMMENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CommentsKeywordSegment'
pub static COMMENTS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "COMMENTS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CommitKeywordSegment'
pub static COMMIT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "COMMIT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CommittedKeywordSegment'
pub static COMMITTED_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "COMMITTED",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ComparisonOperatorGrammar'
pub static COMPARISON_OPERATOR_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "GreaterThanSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([">".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LessThanSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["<".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "GreaterThanOrEqualToSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([">".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LessThanOrEqualToSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["<".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NotEqualToSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["!".to_string(), "<".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LikeOperatorSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["like_operator".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IsDistinctFromGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["!".to_string(), "<".to_string(), "=".to_string(), ">".to_string(), "IS".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["like_operator".to_string()]),
        }),
})
);

// name='ComparisonOperatorSegment'
pub static COMPARISON_OPERATOR_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Token{
    token_type: "comparison_operator",
//    token_type: "ComparisonOperatorSegment",
})
);

// name='CompositeBinaryOperatorSegment'
pub static COMPOSITE_BINARY_OPERATOR_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Token{
    token_type: "binary_operator",
//    token_type: "CompositeBinaryOperatorSegment",
})
);

// name='CompositeComparisonOperatorSegment'
pub static COMPOSITE_COMPARISON_OPERATOR_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Token{
    token_type: "comparison_operator",
//    token_type: "CompositeComparisonOperatorSegment",
})
);

// name='ConcatKeywordSegment'
pub static CONCAT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CONCAT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ConcatSegment'
pub static CONCAT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ConcatSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PipeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["|".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PipeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["|".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: false,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["|".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ConditionKeywordSegment'
pub static CONDITION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CONDITION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ConditionalCrossJoinKeywordsGrammar'
pub static CONDITIONAL_CROSS_JOIN_KEYWORDS_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Ref {
    name: "CrossKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CROSS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ConditionalJoinKeywordsGrammar'
pub static CONDITIONAL_JOIN_KEYWORDS_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "JoinTypeKeywordsGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FULL".to_string(), "INNER".to_string(), "LEFT".to_string(), "RIGHT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConditionalCrossJoinKeywordsGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CROSS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NonStandardJoinTypeKeywordsGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='ConnectByClauseSegment'
pub static CONNECT_BY_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ConnectByClauseSegment
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ConnectKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONNECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NocycleKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOCYCLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "AndKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AND".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "StartKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["START".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "StartKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["START".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["START".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONNECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "StartKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["START".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ConnectKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONNECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NocycleKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOCYCLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "AndKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AND".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["START".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONNECT".to_string(), "START".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ConnectKeywordSegment'
pub static CONNECT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CONNECT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Connect_by_iscycleKeywordSegment'
pub static CONNECT_BY_ISCYCLE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CONNECT_BY_ISCYCLE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Connect_by_isleafKeywordSegment'
pub static CONNECT_BY_ISLEAF_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CONNECT_BY_ISLEAF",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Connect_by_rootKeywordSegment'
pub static CONNECT_BY_ROOT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CONNECT_BY_ROOT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ConnectionDefinition'
pub static CONNECTION_DEFINITION: Lazy<Arc<Grammar>> = Lazy::new(||
// ConnectionDefinition
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["single_quote".to_string()]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "UserKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IdentifiedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IDENTIFIED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["single_quote".to_string()]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='ConnectionKeywordSegment'
pub static CONNECTION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CONNECTION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ConstantKeywordSegment'
pub static CONSTANT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CONSTANT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ConstraintKeywordSegment'
pub static CONSTRAINT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CONSTRAINT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Constraint_state_defaultKeywordSegment'
pub static CONSTRAINT_STATE_DEFAULT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CONSTRAINT_STATE_DEFAULT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ConstraintsKeywordSegment'
pub static CONSTRAINTS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CONSTRAINTS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ConstructorKeywordSegment'
pub static CONSTRUCTOR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CONSTRUCTOR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ConsumerGroupParameterSegment'
pub static CONSUMER_GROUP_PARAMETER_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ConsumerGroupParameterSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "Cpu_weightKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CPU_WEIGHT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PrecedenceKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PRECEDENCE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Group_temp_db_ram_limitKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUP_TEMP_DB_RAM_LIMIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "User_temp_db_ram_limitKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USER_TEMP_DB_RAM_LIMIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Session_temp_db_ram_limitKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SESSION_TEMP_DB_RAM_LIMIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Query_timeoutKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["QUERY_TIMEOUT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Idle_timeoutKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IDLE_TIMEOUT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CPU_WEIGHT".to_string(), "GROUP_TEMP_DB_RAM_LIMIT".to_string(), "IDLE_TIMEOUT".to_string(), "PRECEDENCE".to_string(), "QUERY_TIMEOUT".to_string(), "SESSION_TEMP_DB_RAM_LIMIT".to_string(), "USER_TEMP_DB_RAM_LIMIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string(), "single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CPU_WEIGHT".to_string(), "GROUP_TEMP_DB_RAM_LIMIT".to_string(), "IDLE_TIMEOUT".to_string(), "PRECEDENCE".to_string(), "QUERY_TIMEOUT".to_string(), "SESSION_TEMP_DB_RAM_LIMIT".to_string(), "USER_TEMP_DB_RAM_LIMIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ConsumerKeywordSegment'
pub static CONSUMER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CONSUMER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Consumer_groupKeywordSegment'
pub static CONSUMER_GROUP_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CONSUMER_GROUP",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ContainsKeywordSegment'
pub static CONTAINS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CONTAINS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ContinueKeywordSegment'
pub static CONTINUE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CONTINUE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ControlKeywordSegment'
pub static CONTROL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CONTROL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ConvertKeywordSegment'
pub static CONVERT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CONVERT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Convert_tzKeywordSegment'
pub static CONVERT_TZ_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CONVERT_TZ",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CorrKeywordSegment'
pub static CORR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CORR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CorrespondingKeywordSegment'
pub static CORRESPONDING_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CORRESPONDING",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CosKeywordSegment'
pub static COS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "COS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CoshKeywordSegment'
pub static COSH_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "COSH",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CotKeywordSegment'
pub static COT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "COT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CountKeywordSegment'
pub static COUNT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "COUNT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Covar_popKeywordSegment'
pub static COVAR_POP_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "COVAR_POP",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Covar_sampKeywordSegment'
pub static COVAR_SAMP_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "COVAR_SAMP",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Cpu_weightKeywordSegment'
pub static CPU_WEIGHT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CPU_WEIGHT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CreateAdapterScriptStatementSegment'
pub static CREATE_ADAPTER_SCRIPT_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CreateAdapterScriptStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OrReplaceGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "JavaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["JAVA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PythonKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PYTHON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LuaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LUA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AdapterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADAPTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ScriptKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCRIPT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ScriptReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::Ref {
    name: "ScriptContentSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("dedent"))
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CreateCastStatementSegment'
pub static CREATE_CAST_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CreateCastStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CastKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CAST".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DatatypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BIGINT".to_string(), "BOOL".to_string(), "BOOLEAN".to_string(), "CHAR".to_string(), "CHARACTER".to_string(), "CLOB".to_string(), "DATE".to_string(), "DEC".to_string(), "DECIMAL".to_string(), "DOUBLE".to_string(), "FLOAT".to_string(), "GEOMETRY".to_string(), "HASHTYPE".to_string(), "INT".to_string(), "INTEGER".to_string(), "INTERVAL".to_string(), "LONG".to_string(), "NCHAR".to_string(), "NUMBER".to_string(), "NUMERIC".to_string(), "NVARCHAR".to_string(), "NVARCHAR2".to_string(), "REAL".to_string(), "SHORTINT".to_string(), "SMALLINT".to_string(), "TIMESTAMP".to_string(), "TINYINT".to_string(), "VARCHAR".to_string(), "VARCHAR2".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DatatypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BIGINT".to_string(), "BOOL".to_string(), "BOOLEAN".to_string(), "CHAR".to_string(), "CHARACTER".to_string(), "CLOB".to_string(), "DATE".to_string(), "DEC".to_string(), "DECIMAL".to_string(), "DOUBLE".to_string(), "FLOAT".to_string(), "GEOMETRY".to_string(), "HASHTYPE".to_string(), "INT".to_string(), "INTEGER".to_string(), "INTERVAL".to_string(), "LONG".to_string(), "NCHAR".to_string(), "NUMBER".to_string(), "NUMERIC".to_string(), "NVARCHAR".to_string(), "NVARCHAR2".to_string(), "REAL".to_string(), "SHORTINT".to_string(), "SMALLINT".to_string(), "TIMESTAMP".to_string(), "TINYINT".to_string(), "VARCHAR".to_string(), "VARCHAR2".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SpecificKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SPECIFIC".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RoutineKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROUTINE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FUNCTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ProcedureKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PROCEDURE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "InstanceKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INSTANCE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StaticKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STATIC".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConstructorKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRUCTOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRUCTOR".to_string(), "INSTANCE".to_string(), "STATIC".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MethodKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["METHOD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRUCTOR".to_string(), "INSTANCE".to_string(), "METHOD".to_string(), "STATIC".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRUCTOR".to_string(), "FUNCTION".to_string(), "INSTANCE".to_string(), "METHOD".to_string(), "PROCEDURE".to_string(), "ROUTINE".to_string(), "STATIC".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "FunctionParameterListGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ForKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AssignmentKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ASSIGNMENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CreateConnectionSegment'
pub static CREATE_CONNECTION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CreateConnectionSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OrReplaceGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConnectionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONNECTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NakedIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConnectionDefinition",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CreateConsumerGroupSegment'
pub static CREATE_CONSUMER_GROUP_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CreateConsumerGroupSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConsumerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSUMER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "GroupKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ConsumerGroupParameterSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CPU_WEIGHT".to_string(), "GROUP_TEMP_DB_RAM_LIMIT".to_string(), "IDLE_TIMEOUT".to_string(), "PRECEDENCE".to_string(), "QUERY_TIMEOUT".to_string(), "SESSION_TEMP_DB_RAM_LIMIT".to_string(), "USER_TEMP_DB_RAM_LIMIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CPU_WEIGHT".to_string(), "GROUP_TEMP_DB_RAM_LIMIT".to_string(), "IDLE_TIMEOUT".to_string(), "PRECEDENCE".to_string(), "QUERY_TIMEOUT".to_string(), "SESSION_TEMP_DB_RAM_LIMIT".to_string(), "USER_TEMP_DB_RAM_LIMIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CreateDatabaseStatementSegment'
pub static CREATE_DATABASE_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CreateDatabaseStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DatabaseKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATABASE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfNotExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DatabaseReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CreateFunctionStatementSegment'
pub static CREATE_FUNCTION_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CreateFunctionStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OrReplaceGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FUNCTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "InKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DatatypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BIGINT".to_string(), "BOOL".to_string(), "BOOLEAN".to_string(), "CHAR".to_string(), "CHARACTER".to_string(), "CLOB".to_string(), "DATE".to_string(), "DEC".to_string(), "DECIMAL".to_string(), "DOUBLE".to_string(), "FLOAT".to_string(), "GEOMETRY".to_string(), "HASHTYPE".to_string(), "INT".to_string(), "INTEGER".to_string(), "INTERVAL".to_string(), "LONG".to_string(), "NCHAR".to_string(), "NUMBER".to_string(), "NUMERIC".to_string(), "NVARCHAR".to_string(), "NVARCHAR2".to_string(), "REAL".to_string(), "SHORTINT".to_string(), "SMALLINT".to_string(), "TIMESTAMP".to_string(), "TINYINT".to_string(), "VARCHAR".to_string(), "VARCHAR2".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: true,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ReturnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RETURN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DatatypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BIGINT".to_string(), "BOOL".to_string(), "BOOLEAN".to_string(), "CHAR".to_string(), "CHARACTER".to_string(), "CLOB".to_string(), "DATE".to_string(), "DEC".to_string(), "DECIMAL".to_string(), "DOUBLE".to_string(), "FLOAT".to_string(), "GEOMETRY".to_string(), "HASHTYPE".to_string(), "INT".to_string(), "INTEGER".to_string(), "INTERVAL".to_string(), "LONG".to_string(), "NCHAR".to_string(), "NUMBER".to_string(), "NUMERIC".to_string(), "NVARCHAR".to_string(), "NVARCHAR2".to_string(), "REAL".to_string(), "SHORTINT".to_string(), "SMALLINT".to_string(), "TIMESTAMP".to_string(), "TINYINT".to_string(), "VARCHAR".to_string(), "VARCHAR2".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string(), "IS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "VariableNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DatatypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BIGINT".to_string(), "BOOL".to_string(), "BOOLEAN".to_string(), "CHAR".to_string(), "CHARACTER".to_string(), "CLOB".to_string(), "DATE".to_string(), "DEC".to_string(), "DECIMAL".to_string(), "DOUBLE".to_string(), "FLOAT".to_string(), "GEOMETRY".to_string(), "HASHTYPE".to_string(), "INT".to_string(), "INTEGER".to_string(), "INTERVAL".to_string(), "LONG".to_string(), "NCHAR".to_string(), "NUMBER".to_string(), "NUMERIC".to_string(), "NVARCHAR".to_string(), "NVARCHAR2".to_string(), "REAL".to_string(), "SHORTINT".to_string(), "SMALLINT".to_string(), "TIMESTAMP".to_string(), "TINYINT".to_string(), "VARCHAR".to_string(), "VARCHAR2".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DelimiterGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([";".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("dedent"))
,
Arc::new(Grammar::Ref {
    name: "BeginKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BEGIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FunctionBodySegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ReturnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RETURN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionContentsExpressionGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DelimiterGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([";".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("dedent"))
,
Arc::new(Grammar::Ref {
    name: "EndKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["END".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionReferenceSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "SemicolonSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([";".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CreateIndexStatementSegment'
pub static CREATE_INDEX_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CreateIndexStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OrReplaceGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UniqueKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UNIQUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IndexKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INDEX".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfNotExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IndexReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IndexColumnDefinitionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CreateKeywordSegment'
pub static CREATE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CREATE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CreateModelStatementSegment'
pub static CREATE_MODEL_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CreateModelStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OrReplaceGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ModelKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "IfNotExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OptionsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OPTIONS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["single_quote".to_string()]),
        }),
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["single_quote".to_string()]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "[",
    token_type: "start_square_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: "]",
    token_type: "end_square_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["[".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OPTIONS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SelectableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "SELECT".to_string(), "VALUES".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CreateRoleStatementSegment'
pub static CREATE_ROLE_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CreateRoleStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RoleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RoleReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CreateSchemaStatementSegment'
pub static CREATE_SCHEMA_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CreateSchemaStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfNotExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CreateScriptingLuaScriptStatementSegment'
pub static CREATE_SCRIPTING_LUA_SCRIPT_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CreateScriptingLuaScriptStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OrReplaceGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LuaKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LUA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ScriptKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCRIPT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ScriptReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ArrayKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ARRAY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: true,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ReturnsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RETURNS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RowcountKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROWCOUNT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROWCOUNT".to_string(), "TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RETURNS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::Ref {
    name: "ScriptContentSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("dedent"))
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CreateSequenceOptionsSegment'
pub static CREATE_SEQUENCE_OPTIONS_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CreateSequenceOptionsSegment
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IncrementKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "StartKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["START".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["START".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SequenceMinValueGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "SequenceMaxValueGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CacheKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "NocacheKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CycleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CYCLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NocycleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOCYCLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CYCLE".to_string(), "NOCYCLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OrderNoOrderGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='CreateSequenceStatementSegment'
pub static CREATE_SEQUENCE_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CreateSequenceStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SequenceKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SEQUENCE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SequenceReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateSequenceOptionsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CreateTableLikeClauseSegment'
pub static CREATE_TABLE_LIKE_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CreateTableLikeClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LikeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LIKE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AliasExpressionSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IncludingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INCLUDING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExcludingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCLUDING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCLUDING".to_string(), "INCLUDING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DefaultsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULTS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCLUDING".to_string(), "INCLUDING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IncludingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INCLUDING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExcludingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCLUDING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCLUDING".to_string(), "INCLUDING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IdentityKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IDENTITY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCLUDING".to_string(), "INCLUDING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IncludingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INCLUDING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExcludingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCLUDING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCLUDING".to_string(), "INCLUDING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CommentsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COMMENTS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCLUDING".to_string(), "INCLUDING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LIKE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CreateTableStatementSegment'
pub static CREATE_TABLE_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CreateTableStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OrReplaceGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfNotExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TableContentDefinitionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableDistributionPartitionClause",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DISTRIBUTE".to_string(), "PARTITION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SelectableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "SELECT".to_string(), "VALUES".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WithDataClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CreateTableLikeClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LIKE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "AS".to_string(), "LIKE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CommentClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COMMENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CreateTriggerStatementSegment'
pub static CREATE_TRIGGER_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CreateTriggerStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TriggerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TRIGGER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TriggerReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "BeforeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BEFORE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AfterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AFTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "InsteadKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "OfKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "InsertKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INSERT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DeleteKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DELETE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "UpdateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UPDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OfKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "OrKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UPDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "OrKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DELETE".to_string(), "INSERT".to_string(), "UPDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ReferencingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REFERENCING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OldKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OLD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RowKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "NewKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NEW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RowKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REFERENCING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FromKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NotKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DeferrableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFERRABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DeferrableKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFERRABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "InitiallyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INITIALLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ImmediateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IMMEDIATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INITIALLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "InitiallyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INITIALLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DeferredKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFERRED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INITIALLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INITIALLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFERRABLE".to_string(), "INITIALLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFERRABLE".to_string(), "INITIALLY".to_string(), "NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ForKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EachKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EACH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RowKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StatementKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STATEMENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROW".to_string(), "STATEMENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WhenKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFERRABLE".to_string(), "FOR".to_string(), "FROM".to_string(), "INITIALLY".to_string(), "NOT".to_string(), "REFERENCING".to_string(), "WHEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExecuteKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXECUTE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ProcedureKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PROCEDURE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionNameIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["word".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionContentsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXECUTE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CreateUDFScriptStatementSegment'
pub static CREATE_U_D_F_SCRIPT_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CreateUDFScriptStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OrReplaceGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "JavaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["JAVA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PythonKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PYTHON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LuaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LUA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["R".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ScalarKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCALAR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCALAR".to_string(), "SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ScriptKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCRIPT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ScriptReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "UDFParameterGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "OrderByClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ReturnsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RETURNS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DatatypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BIGINT".to_string(), "BOOL".to_string(), "BOOLEAN".to_string(), "CHAR".to_string(), "CHARACTER".to_string(), "CLOB".to_string(), "DATE".to_string(), "DEC".to_string(), "DECIMAL".to_string(), "DOUBLE".to_string(), "FLOAT".to_string(), "GEOMETRY".to_string(), "HASHTYPE".to_string(), "INT".to_string(), "INTEGER".to_string(), "INTERVAL".to_string(), "LONG".to_string(), "NCHAR".to_string(), "NUMBER".to_string(), "NUMERIC".to_string(), "NVARCHAR".to_string(), "NVARCHAR2".to_string(), "REAL".to_string(), "SHORTINT".to_string(), "SMALLINT".to_string(), "TIMESTAMP".to_string(), "TINYINT".to_string(), "VARCHAR".to_string(), "VARCHAR2".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RETURNS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EmitsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EMITS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EMITS".to_string(), "RETURNS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::Ref {
    name: "ScriptContentSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("dedent"))
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CreateUserStatementSegment'
pub static CREATE_USER_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CreateUserStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UserKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RoleReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "IdentifiedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IDENTIFIED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "UserPasswordAuthSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UserKerberosAuthSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UserLDAPAuthSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UserOpenIDAuthSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AT".to_string(), "BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CreateViewStatementSegment'
pub static CREATE_VIEW_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CreateViewStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OrReplaceGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ForceKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FORCE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ViewKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VIEW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ViewReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "CommentClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COMMENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SelectableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "SELECT".to_string(), "VALUES".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SelectableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "SELECT".to_string(), "VALUES".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "SELECT".to_string(), "VALUES".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CommentClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COMMENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CreateVirtualSchemaStatementSegment'
pub static CREATE_VIRTUAL_SCHEMA_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CreateVirtualSchemaStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "VirtualKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VIRTUAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfNotExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "UsingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CreatedKeywordSegment'
pub static CREATED_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CREATED",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CrossKeywordSegment'
pub static CROSS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CROSS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CsKeywordSegment'
pub static CS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CsvKeywordSegment'
pub static CSV_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CSV",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CubeFunctionNameSegment'
pub static CUBE_FUNCTION_NAME_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CubeFunctionNameSegment
Arc::new(Grammar::StringParser {
    template: "CUBE",
    token_type: "function_name_identifier",
    raw_class: "CodeSegment",
    optional: false,
})
);

// name='CubeKeywordSegment'
pub static CUBE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CUBE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CubeRollupClauseSegment'
pub static CUBE_ROLLUP_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CubeRollupClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CubeFunctionNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CUBE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RollupFunctionNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROLLUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CUBE".to_string(), "ROLLUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "GroupingExpressionList",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CUBE".to_string(), "ROLLUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CurdateKeywordSegment'
pub static CURDATE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CURDATE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CurrentKeywordSegment'
pub static CURRENT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CURRENT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Current_dateKeywordSegment'
pub static CURRENT_DATE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CURRENT_DATE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Current_pathKeywordSegment'
pub static CURRENT_PATH_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CURRENT_PATH",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Current_roleKeywordSegment'
pub static CURRENT_ROLE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CURRENT_ROLE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Current_schemaKeywordSegment'
pub static CURRENT_SCHEMA_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CURRENT_SCHEMA",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Current_sessionKeywordSegment'
pub static CURRENT_SESSION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CURRENT_SESSION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Current_statementKeywordSegment'
pub static CURRENT_STATEMENT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CURRENT_STATEMENT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Current_timeKeywordSegment'
pub static CURRENT_TIME_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CURRENT_TIME",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Current_timestampKeywordSegment'
pub static CURRENT_TIMESTAMP_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CURRENT_TIMESTAMP",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Current_userKeywordSegment'
pub static CURRENT_USER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CURRENT_USER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CursorKeywordSegment'
pub static CURSOR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CURSOR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CycleKeywordSegment'
pub static CYCLE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CYCLE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DataKeywordSegment'
pub static DATA_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DATA",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DatabaseKeywordSegment'
pub static DATABASE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DATABASE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DatabaseReferenceSegment'
pub static DATABASE_REFERENCE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DatabaseReferenceSegment
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "ObjectReferenceDelimiterGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "ObjectReferenceTerminatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    reset_terminators: false,
    allow_gaps: false,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='DatalinkKeywordSegment'
pub static DATALINK_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DATALINK",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DatatypeIdentifierSegment'
pub static DATATYPE_IDENTIFIER_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::RegexParser {
    template: regex::RegexBuilder::new(r#"[A-Z_][A-Z0-9_]*"#)
         .case_insensitive(true)
         .build()
         .unwrap(),
    token_type: "data_type_identifier",
    raw_class: "CodeSegment",
    optional: false,
    anti_template: Some(regex::RegexBuilder::new(r#"^(NOT)$"#)         .case_insensitive(true)         .build()         .unwrap()     ),
})
,
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: Some(Box::new(
Arc::new(Grammar::Ref {
    name: "NakedIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
    )),
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='DatatypeSegment'
pub static DATATYPE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DatatypeSegment
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DecimalKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DECIMAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DecKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEC".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumberKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NUMBER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NUMERIC".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEC".to_string(), "DECIMAL".to_string(), "NUMBER".to_string(), "NUMERIC".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BracketedArguments",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEC".to_string(), "DECIMAL".to_string(), "NUMBER".to_string(), "NUMERIC".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BigintKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BIGINT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DoubleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DOUBLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PrecisionKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PRECISION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DOUBLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FloatKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FLOAT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IntKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IntegerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INTEGER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RealKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ShortintKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SHORTINT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TinyintKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TINYINT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SmallintKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SMALLINT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "BooleanKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BOOLEAN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BoolKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BOOL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BOOL".to_string(), "BOOLEAN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TimestampKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TIMESTAMP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LocalKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LOCAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TimeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TIME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ZoneKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ZONE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TIMESTAMP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATE".to_string(), "TIMESTAMP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IntervalKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INTERVAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "YearKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["YEAR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BracketedArguments",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MonthKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MONTH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INTERVAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IntervalKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INTERVAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DayKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DAY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BracketedArguments",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SecondKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SECOND".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BracketedArguments",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INTERVAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "GeometryKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GEOMETRY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BracketedArguments",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GEOMETRY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "HashtypeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["HASHTYPE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BracketedArguments",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["HASHTYPE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CharKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHAR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "VaryingKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VARYING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHAR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "VarcharKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VARCHAR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Varchar2KeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VARCHAR2".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NcharKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NCHAR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NvarcharKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NVARCHAR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Nvarchar2KeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NVARCHAR2".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHAR".to_string(), "NCHAR".to_string(), "NVARCHAR".to_string(), "NVARCHAR2".to_string(), "VARCHAR".to_string(), "VARCHAR2".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BracketedArguments",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHAR".to_string(), "NCHAR".to_string(), "NVARCHAR".to_string(), "NVARCHAR2".to_string(), "VARCHAR".to_string(), "VARCHAR2".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LongKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LONG".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "VarcharKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VARCHAR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LONG".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CharacterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHARACTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LargeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LARGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OBJECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LARGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "VaryingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VARYING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LARGE".to_string(), "VARYING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BracketedArguments",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "LARGE".to_string(), "VARYING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHARACTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ClobKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CLOB".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BracketedArguments",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CLOB".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHAR".to_string(), "CHARACTER".to_string(), "CLOB".to_string(), "LONG".to_string(), "NCHAR".to_string(), "NVARCHAR".to_string(), "NVARCHAR2".to_string(), "VARCHAR".to_string(), "VARCHAR2".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CharCharacterSetGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ASCII".to_string(), "UTF8".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHAR".to_string(), "CHARACTER".to_string(), "CLOB".to_string(), "LONG".to_string(), "NCHAR".to_string(), "NVARCHAR".to_string(), "NVARCHAR2".to_string(), "VARCHAR".to_string(), "VARCHAR2".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BIGINT".to_string(), "BOOL".to_string(), "BOOLEAN".to_string(), "CHAR".to_string(), "CHARACTER".to_string(), "CLOB".to_string(), "DATE".to_string(), "DEC".to_string(), "DECIMAL".to_string(), "DOUBLE".to_string(), "FLOAT".to_string(), "GEOMETRY".to_string(), "HASHTYPE".to_string(), "INT".to_string(), "INTEGER".to_string(), "INTERVAL".to_string(), "LONG".to_string(), "NCHAR".to_string(), "NUMBER".to_string(), "NUMERIC".to_string(), "NVARCHAR".to_string(), "NVARCHAR2".to_string(), "REAL".to_string(), "SHORTINT".to_string(), "SMALLINT".to_string(), "TIMESTAMP".to_string(), "TINYINT".to_string(), "VARCHAR".to_string(), "VARCHAR2".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DateKeywordSegment'
pub static DATE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DATE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DatePartFunctionName'
pub static DATE_PART_FUNCTION_NAME: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::MultiStringParser {
    templates: vec!["ADD_DAYS", "ADD_HOURS", "ADD_MINUTES", "ADD_MONTHS", "ADD_SECONDS", "ADD_WEEKS", "ADD_YEARS"],
    token_type: "function_name_identifier",
    raw_class: "CodeSegment",
    optional: false,
})
);

// name='DatePartFunctionNameSegment'
pub static DATE_PART_FUNCTION_NAME_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DatePartFunctionNameSegment
Arc::new(Grammar::Ref {
    name: "DatePartFunctionName",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD_DAYS".to_string(), "ADD_HOURS".to_string(), "ADD_MINUTES".to_string(), "ADD_MONTHS".to_string(), "ADD_SECONDS".to_string(), "ADD_WEEKS".to_string(), "ADD_YEARS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DateTimeFunctionContentsSegment'
pub static DATE_TIME_FUNCTION_CONTENTS_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DateTimeFunctionContentsSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DatetimeUnitSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DAY".to_string(), "DAYOFYEAR".to_string(), "HOUR".to_string(), "MILLISECOND".to_string(), "MINUTE".to_string(), "MONTH".to_string(), "QUARTER".to_string(), "SECOND".to_string(), "WEEK".to_string(), "WEEKDAY".to_string(), "YEAR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionContentsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DateTimeLiteralGrammar'
pub static DATE_TIME_LITERAL_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TimestampKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TIMESTAMP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATE".to_string(), "TIMESTAMP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::TypedParser {
    template: "single_quote",
    token_type: "date_constructor_literal",
    raw_class: "LiteralSegment",
    optional: false,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATE".to_string(), "TIMESTAMP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='Date_truncKeywordSegment'
pub static DATE_TRUNC_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DATE_TRUNC",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DatetimeUnitSegment'
pub static DATETIME_UNIT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::MultiStringParser {
    templates: vec!["DAY", "DAYOFYEAR", "HOUR", "MILLISECOND", "MINUTE", "MONTH", "QUARTER", "SECOND", "WEEK", "WEEKDAY", "YEAR"],
    token_type: "date_part",
    raw_class: "CodeSegment",
    optional: false,
})
);

// name='Datetime_interval_codeKeywordSegment'
pub static DATETIME_INTERVAL_CODE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DATETIME_INTERVAL_CODE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Datetime_interval_precisionKeywordSegment'
pub static DATETIME_INTERVAL_PRECISION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DATETIME_INTERVAL_PRECISION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DayKeywordSegment'
pub static DAY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DAY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Days_betweenKeywordSegment'
pub static DAYS_BETWEEN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DAYS_BETWEEN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DbtimezoneKeywordSegment'
pub static DBTIMEZONE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DBTIMEZONE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DeallocateKeywordSegment'
pub static DEALLOCATE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DEALLOCATE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DebugKeywordSegment'
pub static DEBUG_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DEBUG",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DecKeywordSegment'
pub static DEC_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DEC",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DecimalKeywordSegment'
pub static DECIMAL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DECIMAL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DeclareKeywordSegment'
pub static DECLARE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DECLARE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DecodeKeywordSegment'
pub static DECODE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DECODE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Dedent'
pub static DEDENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Meta("dedent"))
);

// name='DefaultKeywordSegment'
pub static DEFAULT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DEFAULT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DefaultValuesGrammar'
pub static DEFAULT_VALUES_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DefaultKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ValuesKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='Default_consumer_groupKeywordSegment'
pub static DEFAULT_CONSUMER_GROUP_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DEFAULT_CONSUMER_GROUP",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Default_like_escape_characterKeywordSegment'
pub static DEFAULT_LIKE_ESCAPE_CHARACTER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DEFAULT_LIKE_ESCAPE_CHARACTER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DefaultsKeywordSegment'
pub static DEFAULTS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DEFAULTS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DeferrableKeywordSegment'
pub static DEFERRABLE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DEFERRABLE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DeferredKeywordSegment'
pub static DEFERRED_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DEFERRED",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DefinedKeywordSegment'
pub static DEFINED_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DEFINED",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DefinerKeywordSegment'
pub static DEFINER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DEFINER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DegreesKeywordSegment'
pub static DEGREES_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DEGREES",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DeleteKeywordSegment'
pub static DELETE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DELETE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DeleteStatementSegment'
pub static DELETE_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DeleteStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DeleteKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DELETE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StarSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["*".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FromKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AliasedTableReferenceGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "WhereClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHERE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PreferringClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PREFERRING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DELETE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DelimitKeywordSegment'
pub static DELIMIT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DELIMIT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DelimiterGrammar'
pub static DELIMITER_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Ref {
    name: "SemicolonSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([";".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DelimiterKeywordSegment'
pub static DELIMITER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DELIMITER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Dense_rankKeywordSegment'
pub static DENSE_RANK_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DENSE_RANK",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DepthKeywordSegment'
pub static DEPTH_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DEPTH",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DerefKeywordSegment'
pub static DEREF_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DEREF",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DerivedKeywordSegment'
pub static DERIVED_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DERIVED",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DescKeywordSegment'
pub static DESC_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DESC",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DescribeKeywordSegment'
pub static DESCRIBE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DESCRIBE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DescribeStatementSegment'
pub static DESCRIBE_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DescribeStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DescribeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DESCRIBE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NakedIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DESCRIBE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DescriptorKeywordSegment'
pub static DESCRIPTOR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DESCRIPTOR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DeterministicKeywordSegment'
pub static DETERMINISTIC_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DETERMINISTIC",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DiagnosticsKeywordSegment'
pub static DIAGNOSTICS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DIAGNOSTICS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DictionaryKeywordSegment'
pub static DICTIONARY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DICTIONARY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DisableKeywordSegment'
pub static DISABLE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DISABLE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DisabledKeywordSegment'
pub static DISABLED_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DISABLED",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DisconnectKeywordSegment'
pub static DISCONNECT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DISCONNECT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DispatchKeywordSegment'
pub static DISPATCH_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DISPATCH",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DistinctKeywordSegment'
pub static DISTINCT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DISTINCT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DistributeKeywordSegment'
pub static DISTRIBUTE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DISTRIBUTE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DistributionKeywordSegment'
pub static DISTRIBUTION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DISTRIBUTION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DivKeywordSegment'
pub static DIV_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DIV",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DivideSegment'
pub static DIVIDE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "/",
    token_type: "binary_operator",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='DlurlcompleteKeywordSegment'
pub static DLURLCOMPLETE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DLURLCOMPLETE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DlurlpathKeywordSegment'
pub static DLURLPATH_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DLURLPATH",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DlurlpathonlyKeywordSegment'
pub static DLURLPATHONLY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DLURLPATHONLY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DlurlschemeKeywordSegment'
pub static DLURLSCHEME_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DLURLSCHEME",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DlurlserverKeywordSegment'
pub static DLURLSERVER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DLURLSERVER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DlvalueKeywordSegment'
pub static DLVALUE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DLVALUE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DoKeywordSegment'
pub static DO_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DO",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DomainKeywordSegment'
pub static DOMAIN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DOMAIN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DotSegment'
pub static DOT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: ".",
    token_type: "dot",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='DoubleKeywordSegment'
pub static DOUBLE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DOUBLE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DownKeywordSegment'
pub static DOWN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DOWN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DriverKeywordSegment'
pub static DRIVER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DRIVER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DropBehaviorGrammar'
pub static DROP_BEHAVIOR_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RestrictKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CascadeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string(), "RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DropCastStatementSegment'
pub static DROP_CAST_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DropCastStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CastKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CAST".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DatatypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BIGINT".to_string(), "BOOL".to_string(), "BOOLEAN".to_string(), "CHAR".to_string(), "CHARACTER".to_string(), "CLOB".to_string(), "DATE".to_string(), "DEC".to_string(), "DECIMAL".to_string(), "DOUBLE".to_string(), "FLOAT".to_string(), "GEOMETRY".to_string(), "HASHTYPE".to_string(), "INT".to_string(), "INTEGER".to_string(), "INTERVAL".to_string(), "LONG".to_string(), "NCHAR".to_string(), "NUMBER".to_string(), "NUMERIC".to_string(), "NVARCHAR".to_string(), "NVARCHAR2".to_string(), "REAL".to_string(), "SHORTINT".to_string(), "SMALLINT".to_string(), "TIMESTAMP".to_string(), "TINYINT".to_string(), "VARCHAR".to_string(), "VARCHAR2".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DatatypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BIGINT".to_string(), "BOOL".to_string(), "BOOLEAN".to_string(), "CHAR".to_string(), "CHARACTER".to_string(), "CLOB".to_string(), "DATE".to_string(), "DEC".to_string(), "DECIMAL".to_string(), "DOUBLE".to_string(), "FLOAT".to_string(), "GEOMETRY".to_string(), "HASHTYPE".to_string(), "INT".to_string(), "INTEGER".to_string(), "INTERVAL".to_string(), "LONG".to_string(), "NCHAR".to_string(), "NUMBER".to_string(), "NUMERIC".to_string(), "NVARCHAR".to_string(), "NVARCHAR2".to_string(), "REAL".to_string(), "SHORTINT".to_string(), "SMALLINT".to_string(), "TIMESTAMP".to_string(), "TINYINT".to_string(), "VARCHAR".to_string(), "VARCHAR2".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DropBehaviorGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string(), "RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DropConnectionStatementSegment'
pub static DROP_CONNECTION_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DropConnectionStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConnectionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONNECTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DropConsumerGroupSegment'
pub static DROP_CONSUMER_GROUP_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DropConsumerGroupSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ConsumerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSUMER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "GroupKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSUMER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DropDatabaseStatementSegment'
pub static DROP_DATABASE_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DropDatabaseStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DatabaseKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATABASE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DatabaseReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DropBehaviorGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string(), "RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DropFunctionStatementSegment'
pub static DROP_FUNCTION_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DropFunctionStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FUNCTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DropBehaviorGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string(), "RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DropIndexStatementSegment'
pub static DROP_INDEX_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DropIndexStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IndexKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INDEX".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IndexReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DropBehaviorGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string(), "RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DropKeywordSegment'
pub static DROP_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DROP",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DropModelStatementSegment'
pub static DROP_MODEL_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DropModelStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ModelKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DropRoleStatementSegment'
pub static DROP_ROLE_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DropRoleStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RoleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RoleReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "CascadeKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DropSchemaStatementSegment'
pub static DROP_SCHEMA_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DropSchemaStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ForceKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FORCE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "VirtualKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VIRTUAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DropBehaviorGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string(), "RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DropScriptStatementSegment'
pub static DROP_SCRIPT_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DropScriptStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AdapterKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADAPTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ScriptKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCRIPT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADAPTER".to_string(), "SCRIPT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ScriptReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DropSequenceStatementSegment'
pub static DROP_SEQUENCE_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DropSequenceStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SequenceKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SEQUENCE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SequenceReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DropTableStatementSegment'
pub static DROP_TABLE_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DropTableStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DropBehaviorGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string(), "RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CascadeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConstraintsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRAINTS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DropTriggerStatementSegment'
pub static DROP_TRIGGER_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DropTriggerStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TriggerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TRIGGER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TriggerReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DropTypeStatementSegment'
pub static DROP_TYPE_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DropTypeStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TypeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TYPE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DropBehaviorGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string(), "RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DropUserStatementSegment'
pub static DROP_USER_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DropUserStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UserKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RoleReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "CascadeKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DropViewStatementSegment'
pub static DROP_VIEW_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DropViewStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ViewKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VIEW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ViewReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DropBehaviorGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string(), "RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DumpKeywordSegment'
pub static DUMP_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DUMP",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DynamicKeywordSegment'
pub static DYNAMIC_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DYNAMIC",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Dynamic_functionKeywordSegment'
pub static DYNAMIC_FUNCTION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DYNAMIC_FUNCTION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Dynamic_function_codeKeywordSegment'
pub static DYNAMIC_FUNCTION_CODE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DYNAMIC_FUNCTION_CODE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='EachKeywordSegment'
pub static EACH_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "EACH",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Edit_distanceKeywordSegment'
pub static EDIT_DISTANCE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "EDIT_DISTANCE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ElseClauseSegment'
pub static ELSE_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ElseClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ElseKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ELSE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("dedent"))
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ELSE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ElseKeywordSegment'
pub static ELSE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ELSE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ElseifKeywordSegment'
pub static ELSEIF_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ELSEIF",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ElsifKeywordSegment'
pub static ELSIF_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ELSIF",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='EmitsKeywordSegment'
pub static EMITS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "EMITS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='EmitsSegment'
pub static EMITS_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// EmitsSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "EmitsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EMITS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "UDFParameterGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EMITS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='EmptyKeywordSegment'
pub static EMPTY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "EMPTY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='EmptyStructLiteralBracketsSegment'
pub static EMPTY_STRUCT_LITERAL_BRACKETS_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// EmptyStructLiteralBracketsSegment
Arc::new(Grammar::Bracketed {
    elements: vec![
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='EmptyStructLiteralSegment'
pub static EMPTY_STRUCT_LITERAL_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// EmptyStructLiteralSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "StructTypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "EmptyStructLiteralBracketsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='EnableKeywordSegment'
pub static ENABLE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ENABLE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='EnabledKeywordSegment'
pub static ENABLED_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ENABLED",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='EncodingKeywordSegment'
pub static ENCODING_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ENCODING",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='End-execKeywordSegment'
pub static END_EXEC_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "END-EXEC",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='EndBracketSegment'
pub static END_BRACKET_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='EndCurlyBracketSegment'
pub static END_CURLY_BRACKET_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "}",
    token_type: "end_curly_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='EndKeywordSegment'
pub static END_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "END",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='EndSquareBracketSegment'
pub static END_SQUARE_BRACKET_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "]",
    token_type: "end_square_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='EndifKeywordSegment'
pub static ENDIF_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ENDIF",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='EnforceKeywordSegment'
pub static ENFORCE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ENFORCE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='EqualsKeywordSegment'
pub static EQUALS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "EQUALS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='EqualsSegment'
pub static EQUALS_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// EqualsSegment
Arc::new(Grammar::Ref {
    name: "RawEqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ErrorKeywordSegment'
pub static ERROR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ERROR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ErrorsKeywordSegment'
pub static ERRORS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ERRORS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='EscapeKeywordSegment'
pub static ESCAPE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ESCAPE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='EscapedIdentifierSegment'
pub static ESCAPED_IDENTIFIER_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::TypedParser {
    template: "escaped_identifier",
    token_type: "identifier",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='EstimateKeywordSegment'
pub static ESTIMATE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ESTIMATE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='EvaluateKeywordSegment'
pub static EVALUATE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "EVALUATE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='EveryKeywordSegment'
pub static EVERY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "EVERY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ExaKeywordSegment'
pub static EXA_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "EXA",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ExceptKeywordSegment'
pub static EXCEPT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "EXCEPT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ExceptionKeywordSegment'
pub static EXCEPTION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "EXCEPTION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ExcludeKeywordSegment'
pub static EXCLUDE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "EXCLUDE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ExcludingKeywordSegment'
pub static EXCLUDING_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "EXCLUDING",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ExecKeywordSegment'
pub static EXEC_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "EXEC",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ExecuteKeywordSegment'
pub static EXECUTE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "EXECUTE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ExecuteScriptSegment'
pub static EXECUTE_SCRIPT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ExecuteScriptSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExecuteKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXECUTE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ScriptKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCRIPT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ScriptReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ArrayKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ARRAY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OutputKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OUTPUT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXECUTE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ExistsKeywordSegment'
pub static EXISTS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "EXISTS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ExitKeywordSegment'
pub static EXIT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "EXIT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ExpKeywordSegment'
pub static EXP_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "EXP",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ExperimentalKeywordSegment'
pub static EXPERIMENTAL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "EXPERIMENTAL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ExpireKeywordSegment'
pub static EXPIRE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "EXPIRE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ExplainKeywordSegment'
pub static EXPLAIN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "EXPLAIN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ExplainStatementSegment'
pub static EXPLAIN_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ExplainStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExplainKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXPLAIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SelectableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "SELECT".to_string(), "VALUES".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "InsertStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INSERT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UpdateStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UPDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DeleteStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DELETE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "DELETE".to_string(), "INSERT".to_string(), "SELECT".to_string(), "UPDATE".to_string(), "VALUES".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXPLAIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ExplainVirtualSegment'
pub static EXPLAIN_VIRTUAL_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ExplainVirtualSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExplainKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXPLAIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "VirtualKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VIRTUAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SelectableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "SELECT".to_string(), "VALUES".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXPLAIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ExportIntoClauseSegment'
pub static EXPORT_INTO_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ExportIntoClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IntoKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INTO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ImportFromExportIntoDbSrcSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXA".to_string(), "JDBC".to_string(), "ORA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ImportFromExportIntoFileSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CSV".to_string(), "FBV".to_string(), "LOCAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CSV".to_string(), "EXA".to_string(), "FBV".to_string(), "JDBC".to_string(), "LOCAL".to_string(), "ORA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RejectClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REJECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CSV".to_string(), "EXA".to_string(), "FBV".to_string(), "JDBC".to_string(), "LOCAL".to_string(), "ORA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ImportFromExportIntoScriptSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCRIPT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CSV".to_string(), "EXA".to_string(), "FBV".to_string(), "JDBC".to_string(), "LOCAL".to_string(), "ORA".to_string(), "SCRIPT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INTO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ExportKeywordSegment'
pub static EXPORT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "EXPORT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ExportStatementSegment'
pub static EXPORT_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ExportStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExportKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXPORT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierListSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SelectableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "SELECT".to_string(), "VALUES".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ExportIntoClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INTO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXPORT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ExpressionKeywordSegment'
pub static EXPRESSION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "EXPRESSION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ExpressionSegment'
pub static EXPRESSION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ExpressionSegment
Arc::new(Grammar::Ref {
    name: "Expression_A_Grammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
);

// name='Expression_A_Grammar'
pub static EXPRESSION_A_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "Tail_Recurse_Expression_A_Grammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LikeExpressionGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LIKE".to_string(), "NOT".to_string(), "REGEXP_LIKE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "BinaryOperatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["!".to_string(), "%".to_string(), "&".to_string(), "*".to_string(), "+".to_string(), "-".to_string(), "/".to_string(), "<".to_string(), "=".to_string(), ">".to_string(), "AND".to_string(), "IS".to_string(), "OR".to_string(), "^".to_string(), "|".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["like_operator".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Tail_Recurse_Expression_A_Grammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["!".to_string(), "%".to_string(), "&".to_string(), "*".to_string(), "+".to_string(), "-".to_string(), "/".to_string(), "<".to_string(), "=".to_string(), ">".to_string(), "AND".to_string(), "IS".to_string(), "OR".to_string(), "^".to_string(), "|".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["like_operator".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "InOperatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IN".to_string(), "NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NotKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IsClauseGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IsNullGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "NotNullGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "CollateGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NotKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BetweenKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BETWEEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Expression_B_Grammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AndKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AND".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Tail_Recurse_Expression_A_Grammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BETWEEN".to_string(), "NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PatternMatchingGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "Expression_A_Grammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='Expression_A_Unary_Operator_Grammar'
pub static EXPRESSION_A_UNARY_OPERATOR_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SignedSegmentGrammar",
    optional: false,
    allow_gaps: true,
    exclude: Some(Box::new(
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "QualifiedNumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["+".to_string(), "-".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["+".to_string(), "-".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    )),
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["+".to_string(), "-".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TildeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["~".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NotOperatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PriorKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PRIOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["+".to_string(), "-".to_string(), "NOT".to_string(), "PRIOR".to_string(), "~".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='Expression_B_Grammar'
pub static EXPRESSION_B_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "Tail_Recurse_Expression_B_Grammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ArithmeticBinaryOperatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["%".to_string(), "&".to_string(), "*".to_string(), "+".to_string(), "-".to_string(), "/".to_string(), "<".to_string(), ">".to_string(), "^".to_string(), "|".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StringBinaryOperatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["|".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ComparisonOperatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["!".to_string(), "<".to_string(), "=".to_string(), ">".to_string(), "IS".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["like_operator".to_string()]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["!".to_string(), "%".to_string(), "&".to_string(), "*".to_string(), "+".to_string(), "-".to_string(), "/".to_string(), "<".to_string(), "=".to_string(), ">".to_string(), "IS".to_string(), "^".to_string(), "|".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["like_operator".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Tail_Recurse_Expression_B_Grammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["!".to_string(), "%".to_string(), "&".to_string(), "*".to_string(), "+".to_string(), "-".to_string(), "/".to_string(), "<".to_string(), "=".to_string(), ">".to_string(), "IS".to_string(), "^".to_string(), "|".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["like_operator".to_string()]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["!".to_string(), "%".to_string(), "&".to_string(), "*".to_string(), "+".to_string(), "-".to_string(), "/".to_string(), "<".to_string(), "=".to_string(), ">".to_string(), "IS".to_string(), "^".to_string(), "|".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["like_operator".to_string()]),
        }),
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["!".to_string(), "%".to_string(), "&".to_string(), "*".to_string(), "+".to_string(), "-".to_string(), "/".to_string(), "<".to_string(), "=".to_string(), ">".to_string(), "IS".to_string(), "^".to_string(), "|".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["like_operator".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='Expression_B_Unary_Operator_Grammar'
pub static EXPRESSION_B_UNARY_OPERATOR_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SignedSegmentGrammar",
    optional: false,
    allow_gaps: true,
    exclude: Some(Box::new(
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "QualifiedNumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["+".to_string(), "-".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["+".to_string(), "-".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    )),
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["+".to_string(), "-".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TildeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["~".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["+".to_string(), "-".to_string(), "~".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='Expression_C_Grammar'
pub static EXPRESSION_C_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExistsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXISTS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SelectableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "SELECT".to_string(), "VALUES".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXISTS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "Expression_D_Grammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "CaseExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TimeZoneGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ShorthandCastSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='Expression_D_Grammar'
pub static EXPRESSION_D_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "BareFunctionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONNECT_BY_ISCYCLE".to_string(), "CONNECT_BY_ISLEAF".to_string(), "CONNECT_BY_ROOT".to_string(), "CURDATE".to_string(), "CURRENT_DATE".to_string(), "CURRENT_SCHEMA".to_string(), "CURRENT_SESSION".to_string(), "CURRENT_STATEMENT".to_string(), "CURRENT_TIMESTAMP".to_string(), "CURRENT_USER".to_string(), "DBTIMEZONE".to_string(), "LEVEL".to_string(), "LOCALTIMESTAMP".to_string(), "NOW".to_string(), "ROWID".to_string(), "ROWNUM".to_string(), "SESSIONTIMEZONE".to_string(), "SYSDATE".to_string(), "SYSTIMESTAMP".to_string(), "USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "SelectableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "SELECT".to_string(), "VALUES".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "FunctionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "LocalAliasSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LOCAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Greedy,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Expression_D_Potential_Select_Statement_Without_Brackets",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceDelimiterGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StarSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["*".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "StructTypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "MapTypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DatatypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BIGINT".to_string(), "BOOL".to_string(), "BOOLEAN".to_string(), "CHAR".to_string(), "CHARACTER".to_string(), "CLOB".to_string(), "DATE".to_string(), "DEC".to_string(), "DECIMAL".to_string(), "DOUBLE".to_string(), "FLOAT".to_string(), "GEOMETRY".to_string(), "HASHTYPE".to_string(), "INT".to_string(), "INTEGER".to_string(), "INTERVAL".to_string(), "LONG".to_string(), "NCHAR".to_string(), "NUMBER".to_string(), "NUMERIC".to_string(), "NVARCHAR".to_string(), "NVARCHAR2".to_string(), "REAL".to_string(), "SHORTINT".to_string(), "SMALLINT".to_string(), "TIMESTAMP".to_string(), "TINYINT".to_string(), "VARCHAR".to_string(), "VARCHAR2".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BooleanLiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FALSE".to_string(), "TRUE".to_string(), "UNKNOWN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NullLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DateTimeLiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATE".to_string(), "TIMESTAMP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATE".to_string(), "FALSE".to_string(), "NULL".to_string(), "TIMESTAMP".to_string(), "TRUE".to_string(), "UNKNOWN".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string(), "single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BIGINT".to_string(), "BOOL".to_string(), "BOOLEAN".to_string(), "CHAR".to_string(), "CHARACTER".to_string(), "CLOB".to_string(), "DATE".to_string(), "DEC".to_string(), "DECIMAL".to_string(), "DOUBLE".to_string(), "FLOAT".to_string(), "GEOMETRY".to_string(), "HASHTYPE".to_string(), "INT".to_string(), "INTEGER".to_string(), "INTERVAL".to_string(), "LONG".to_string(), "NCHAR".to_string(), "NUMBER".to_string(), "NUMERIC".to_string(), "NVARCHAR".to_string(), "NVARCHAR2".to_string(), "REAL".to_string(), "SHORTINT".to_string(), "SMALLINT".to_string(), "TIMESTAMP".to_string(), "TINYINT".to_string(), "VARCHAR".to_string(), "VARCHAR2".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LocalAliasSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LOCAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ListComprehensionGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AccessorGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["[".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='Expression_D_Potential_Select_Statement_Without_Brackets'
pub static EXPRESSION_D_POTENTIAL_SELECT_STATEMENT_WITHOUT_BRACKETS: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SelectStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SELECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "IntervalExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INTERVAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TypedStructLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ArrayExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "OverlapsClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OVERLAPS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='ExtendedNaturalJoinKeywordsGrammar'
pub static EXTENDED_NATURAL_JOIN_KEYWORDS_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Nothing())
);

// name='ExtensionReferenceSegment'
pub static EXTENSION_REFERENCE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ExtensionReferenceSegment
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "ObjectReferenceDelimiterGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "ObjectReferenceTerminatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    reset_terminators: false,
    allow_gaps: false,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='ExternalKeywordSegment'
pub static EXTERNAL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "EXTERNAL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ExtractKeywordSegment'
pub static EXTRACT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "EXTRACT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='FBVColumnDefinitionSegment'
pub static F_B_V_COLUMN_DEFINITION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// FBVColumnDefinitionSegment
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SizeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SIZE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StartKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["START".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SIZE".to_string(), "START".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SIZE".to_string(), "START".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FormatKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FORMAT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PaddingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PADDING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FORMAT".to_string(), "PADDING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FORMAT".to_string(), "PADDING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlignKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALIGN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LeftKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LEFT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RightKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RIGHT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LEFT".to_string(), "RIGHT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALIGN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALIGN".to_string(), "FORMAT".to_string(), "PADDING".to_string(), "SIZE".to_string(), "START".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALIGN".to_string(), "FORMAT".to_string(), "PADDING".to_string(), "SIZE".to_string(), "START".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='FailedKeywordSegment'
pub static FAILED_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FAILED",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='FalseKeywordSegment'
pub static FALSE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FALSE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='FalseSegment'
pub static FALSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FALSE",
    token_type: "boolean_literal",
    raw_class: "LiteralKeywordSegment",
    optional: false,
})
);

// name='FbvKeywordSegment'
pub static FBV_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FBV",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='FetchClauseSegment'
pub static FETCH_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// FetchClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FetchKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FETCH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FirstKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FIRST".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NextKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NEXT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FIRST".to_string(), "NEXT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: Some(Box::new(
Arc::new(Grammar::Ref {
    name: "RowKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    )),
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RowKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RowsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROWS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROW".to_string(), "ROWS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OnlyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ONLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TiesKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TIES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ONLY".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FETCH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='FetchKeywordSegment'
pub static FETCH_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FETCH",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='FileKeywordSegment'
pub static FILE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FILE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='FileOptionSegment'
pub static FILE_OPTION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// FileOptionSegment
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "EncodingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ENCODING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NullKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BooleanKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BOOLEAN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RowKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SeparatorKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SEPARATOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColumnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLUMN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SeparatorKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SEPARATOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DelimiterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DELIMITER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DELIMITER".to_string(), "SEPARATOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLUMN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["single_quote".to_string()]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string(), "BOOLEAN".to_string(), "COLUMN".to_string(), "ENCODING".to_string(), "NULL".to_string(), "ROW".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TrimKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TRIM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LtrimKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LTRIM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RtrimKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RTRIM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LTRIM".to_string(), "RTRIM".to_string(), "TRIM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SkipKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SKIP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RowKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SizeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SIZE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROW".to_string(), "SKIP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROW".to_string(), "SKIP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ReplaceKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REPLACE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TruncateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TRUNCATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLUMN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NamesKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NAMES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DelimitKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DELIMIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlwaysKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALWAYS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NeverKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NEVER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AutoKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AUTO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALWAYS".to_string(), "AUTO".to_string(), "NEVER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DELIMIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string(), "BOOLEAN".to_string(), "COLUMN".to_string(), "DELIMIT".to_string(), "ENCODING".to_string(), "LTRIM".to_string(), "NULL".to_string(), "REPLACE".to_string(), "ROW".to_string(), "RTRIM".to_string(), "SKIP".to_string(), "TRIM".to_string(), "TRUNCATE".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["single_quote".to_string()]),
        }),
})
);

// name='FileSegment'
pub static FILE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// FileSegment
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FunctionScriptStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "ALTER".to_string(), "CLOSE".to_string(), "COMMENT".to_string(), "COMMIT".to_string(), "CREATE".to_string(), "DELETE".to_string(), "DROP".to_string(), "EXECUTE".to_string(), "EXPLAIN".to_string(), "EXPORT".to_string(), "FLUSH".to_string(), "GRANT".to_string(), "IMPERSONATE".to_string(), "IMPORT".to_string(), "INSERT".to_string(), "KILL".to_string(), "MERGE".to_string(), "OPEN".to_string(), "PRELOAD".to_string(), "RECOMPRESS".to_string(), "RENAME".to_string(), "REORGANIZE".to_string(), "REVOKE".to_string(), "ROLLBACK".to_string(), "SELECT".to_string(), "TRUNCATE".to_string(), "UPDATE".to_string(), "VALUES".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DelimiterGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([";".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionScriptTerminatorSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["function_script_terminator".to_string()]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([";".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["function_script_terminator".to_string()]),
        }),
})
    ),
    allow_trailing: true,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "ALTER".to_string(), "CLOSE".to_string(), "COMMENT".to_string(), "COMMIT".to_string(), "CREATE".to_string(), "DELETE".to_string(), "DROP".to_string(), "EXECUTE".to_string(), "EXPLAIN".to_string(), "EXPORT".to_string(), "FLUSH".to_string(), "GRANT".to_string(), "IMPERSONATE".to_string(), "IMPORT".to_string(), "INSERT".to_string(), "KILL".to_string(), "MERGE".to_string(), "OPEN".to_string(), "PRELOAD".to_string(), "RECOMPRESS".to_string(), "RENAME".to_string(), "REORGANIZE".to_string(), "REVOKE".to_string(), "ROLLBACK".to_string(), "SELECT".to_string(), "TRUNCATE".to_string(), "UPDATE".to_string(), "VALUES".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='FilesKeywordSegment'
pub static FILES_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FILES",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='FilterClauseGrammar'
pub static FILTER_CLAUSE_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FilterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WhereKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHERE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHERE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='FinalKeywordSegment'
pub static FINAL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FINAL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='FirstKeywordSegment'
pub static FIRST_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FIRST",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='First_valueKeywordSegment'
pub static FIRST_VALUE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FIRST_VALUE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='FloatKeywordSegment'
pub static FLOAT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FLOAT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='FloorKeywordSegment'
pub static FLOOR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FLOOR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='FlushKeywordSegment'
pub static FLUSH_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FLUSH",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='FlushStatisticsSegment'
pub static FLUSH_STATISTICS_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// FlushStatisticsSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FlushKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FLUSH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StatisticsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STATISTICS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FLUSH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='FollowingKeywordSegment'
pub static FOLLOWING_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FOLLOWING",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ForKeywordSegment'
pub static FOR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FOR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ForallKeywordSegment'
pub static FORALL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FORALL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ForceKeywordSegment'
pub static FORCE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FORCE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ForeignKeyGrammar'
pub static FOREIGN_KEY_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ForeignKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOREIGN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "KeyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["KEY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOREIGN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ForeignKeyReferencesClauseGrammar'
pub static FOREIGN_KEY_REFERENCES_CLAUSE_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ReferencesKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REFERENCES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "BracketedColumnReferenceListGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REFERENCES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ForeignKeywordSegment'
pub static FOREIGN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FOREIGN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='FormatKeywordSegment'
pub static FORMAT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FORMAT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='FortranKeywordSegment'
pub static FORTRAN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FORTRAN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='FoundKeywordSegment'
pub static FOUND_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FOUND",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='FrameClauseSegment'
pub static FRAME_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// FrameClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FrameClauseUnitGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RANGE".to_string(), "ROWS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CurrentKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RowKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IntervalExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INTERVAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UnboundedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UNBOUNDED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PrecedingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PRECEDING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FollowingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOLLOWING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOLLOWING".to_string(), "PRECEDING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "BetweenKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BETWEEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CurrentKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RowKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IntervalExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INTERVAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UnboundedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UNBOUNDED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PrecedingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PRECEDING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FollowingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOLLOWING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOLLOWING".to_string(), "PRECEDING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AndKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AND".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CurrentKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RowKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IntervalExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INTERVAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UnboundedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UNBOUNDED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PrecedingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PRECEDING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FollowingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOLLOWING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOLLOWING".to_string(), "PRECEDING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BETWEEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RANGE".to_string(), "ROWS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='FrameClauseUnitGrammar'
pub static FRAME_CLAUSE_UNIT_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RowsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROWS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RangeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RANGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RANGE".to_string(), "ROWS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='FreeKeywordSegment'
pub static FREE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FREE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='FromClauseSegment'
pub static FROM_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// FromClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FromKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FromExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='FromClauseTerminatorGrammar'
pub static FROM_CLAUSE_TERMINATOR_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WhereKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHERE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConnectKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONNECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StartKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["START".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PreferringKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PREFERRING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LimitKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LIMIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "GroupKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OrderKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "HavingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["HAVING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QualifyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["QUALIFY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SetOperatorSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCEPT".to_string(), "INTERSECT".to_string(), "MINUS".to_string(), "UNION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WithDataClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CommentClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COMMENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COMMENT".to_string(), "CONNECT".to_string(), "EXCEPT".to_string(), "GROUP".to_string(), "HAVING".to_string(), "INTERSECT".to_string(), "LIMIT".to_string(), "MINUS".to_string(), "ORDER".to_string(), "PREFERRING".to_string(), "QUALIFY".to_string(), "START".to_string(), "UNION".to_string(), "WHERE".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='FromExpressionElementSegment'
pub static FROM_EXPRESSION_ELEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// FromExpressionElementSegment
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PreTableFunctionKeywordsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TableExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "TemporalQuerySegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AliasExpressionSegment",
    optional: true,
    allow_gaps: true,
    exclude: Some(Box::new(
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FromClauseTerminatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COMMENT".to_string(), "CONNECT".to_string(), "EXCEPT".to_string(), "GROUP".to_string(), "HAVING".to_string(), "INTERSECT".to_string(), "LIMIT".to_string(), "MINUS".to_string(), "ORDER".to_string(), "PREFERRING".to_string(), "QUALIFY".to_string(), "START".to_string(), "UNION".to_string(), "WHERE".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SamplingExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLESAMPLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "JoinLikeClauseGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "JoinClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
    )),
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OffsetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OFFSET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AliasExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SamplingExpressionSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLESAMPLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PostTableExpressionGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PreTableFunctionKeywordsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TableExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "TemporalQuerySegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AliasExpressionSegment",
    optional: true,
    allow_gaps: true,
    exclude: Some(Box::new(
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FromClauseTerminatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COMMENT".to_string(), "CONNECT".to_string(), "EXCEPT".to_string(), "GROUP".to_string(), "HAVING".to_string(), "INTERSECT".to_string(), "LIMIT".to_string(), "MINUS".to_string(), "ORDER".to_string(), "PREFERRING".to_string(), "QUALIFY".to_string(), "START".to_string(), "UNION".to_string(), "WHERE".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SamplingExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLESAMPLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "JoinLikeClauseGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "JoinClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
    )),
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OffsetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OFFSET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AliasExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SamplingExpressionSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLESAMPLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PostTableExpressionGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "JoinClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='FromExpressionSegment'
pub static FROM_EXPRESSION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// FromExpressionSegment
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "MLTableExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "FromExpressionElementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FromExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OrderKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "GroupKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("dedent"))
,
Arc::new(Grammar::Meta("conditional"))
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "JoinClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "JoinLikeClauseGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OrderKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "GroupKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("conditional"))
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "MLTableExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "FromExpressionElementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FromExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OrderKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "GroupKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("dedent"))
,
Arc::new(Grammar::Meta("conditional"))
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "JoinClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "JoinLikeClauseGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OrderKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "GroupKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("conditional"))
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='FromKeywordSegment'
pub static FROM_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FROM",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='From_posix_timeKeywordSegment'
pub static FROM_POSIX_TIME_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FROM_POSIX_TIME",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='FsKeywordSegment'
pub static FS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='FullKeywordSegment'
pub static FULL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FULL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='FunctionAssignmentSegment'
pub static FUNCTION_ASSIGNMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// FunctionAssignmentSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "VariableNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "WalrusOperatorSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([":=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FunctionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "VariableNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "LiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "SemicolonSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([";".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='FunctionBodySegment'
pub static FUNCTION_BODY_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// FunctionBodySegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FunctionAssignmentSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "FunctionIfBranchSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionForLoopSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionWhileLoopSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHILE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='FunctionContentsExpressionGrammar'
pub static FUNCTION_CONTENTS_EXPRESSION_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
);

// name='FunctionContentsGrammar'
pub static FUNCTION_CONTENTS_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DatatypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BIGINT".to_string(), "BOOL".to_string(), "BOOLEAN".to_string(), "CHAR".to_string(), "CHARACTER".to_string(), "CLOB".to_string(), "DATE".to_string(), "DEC".to_string(), "DECIMAL".to_string(), "DOUBLE".to_string(), "FLOAT".to_string(), "GEOMETRY".to_string(), "HASHTYPE".to_string(), "INT".to_string(), "INTEGER".to_string(), "INTERVAL".to_string(), "LONG".to_string(), "NCHAR".to_string(), "NUMBER".to_string(), "NUMERIC".to_string(), "NVARCHAR".to_string(), "NVARCHAR2".to_string(), "REAL".to_string(), "SHORTINT".to_string(), "SMALLINT".to_string(), "TIMESTAMP".to_string(), "TINYINT".to_string(), "VARCHAR".to_string(), "VARCHAR2".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TrimParametersGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BOTH".to_string(), "LEADING".to_string(), "TRAILING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: true,
    allow_gaps: true,
    exclude: Some(Box::new(
Arc::new(Grammar::Ref {
    name: "FromKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    )),
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "FromKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BOTH".to_string(), "LEADING".to_string(), "TRAILING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DatetimeUnitSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DAY".to_string(), "DAYOFYEAR".to_string(), "HOUR".to_string(), "MILLISECOND".to_string(), "MINUTE".to_string(), "MONTH".to_string(), "QUARTER".to_string(), "SECOND".to_string(), "WEEK".to_string(), "WEEKDAY".to_string(), "YEAR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "FromKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DistinctKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DISTINCT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "StarSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["*".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FunctionContentsExpressionGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AggregateOrderByClause",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SeparatorKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SEPARATOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SEPARATOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "InKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "IgnoreRespectNullsGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IGNORE".to_string(), "RESPECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IndexColumnDefinitionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "EmptyStructLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='FunctionContentsSegment'
pub static FUNCTION_CONTENTS_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// FunctionContentsSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FunctionContentsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='FunctionDefinitionGrammar'
pub static FUNCTION_DEFINITION_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
// FunctionDefinitionGrammar
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LanguageKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LANGUAGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NakedIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LANGUAGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='FunctionForLoopSegment'
pub static FUNCTION_FOR_LOOP_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// FunctionForLoopSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ForKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NakedIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WalrusOperatorSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([":=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DoKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FunctionBodySegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    min_times: 1,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "EndKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["END".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ForKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([":=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "InKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "RangeOperator",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["range_operator".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "LoopKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LOOP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FunctionBodySegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    min_times: 1,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "EndKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["END".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LoopKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LOOP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([":=".to_string(), "IN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SemicolonSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([";".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='FunctionIfBranchSegment'
pub static FUNCTION_IF_BRANCH_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// FunctionIfBranchSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IfKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ThenKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["THEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FunctionBodySegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    min_times: 1,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("dedent"))
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ElsifKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ELSIF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ElseifKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ELSEIF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ELSEIF".to_string(), "ELSIF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ThenKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["THEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FunctionBodySegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    min_times: 1,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("dedent"))
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ELSEIF".to_string(), "ELSIF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ELSEIF".to_string(), "ELSIF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ElseKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ELSE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FunctionBodySegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    min_times: 1,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("dedent"))
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ELSE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EndKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["END".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SemicolonSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([";".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='FunctionKeywordSegment'
pub static FUNCTION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FUNCTION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='FunctionNameIdentifierSegment'
pub static FUNCTION_NAME_IDENTIFIER_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::TypedParser {
    template: "word",
    token_type: "function_name_identifier",
    raw_class: "WordSegment",
    optional: false,
})
);

// name='FunctionNameSegment'
pub static FUNCTION_NAME_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// FunctionNameSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DotSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "BracketedSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FunctionNameIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["word".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["double_quote".to_string()]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "BracketedSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["double_quote".to_string(), "word".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: false,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='FunctionParameterGrammar'
pub static FUNCTION_PARAMETER_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AnyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ANY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TypeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TYPE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ANY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DatatypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BIGINT".to_string(), "BOOL".to_string(), "BOOLEAN".to_string(), "CHAR".to_string(), "CHARACTER".to_string(), "CLOB".to_string(), "DATE".to_string(), "DEC".to_string(), "DECIMAL".to_string(), "DOUBLE".to_string(), "FLOAT".to_string(), "GEOMETRY".to_string(), "HASHTYPE".to_string(), "INT".to_string(), "INTEGER".to_string(), "INTERVAL".to_string(), "LONG".to_string(), "NCHAR".to_string(), "NUMBER".to_string(), "NUMERIC".to_string(), "NVARCHAR".to_string(), "NVARCHAR2".to_string(), "REAL".to_string(), "SHORTINT".to_string(), "SMALLINT".to_string(), "TIMESTAMP".to_string(), "TINYINT".to_string(), "VARCHAR".to_string(), "VARCHAR2".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ANY".to_string(), "BIGINT".to_string(), "BOOL".to_string(), "BOOLEAN".to_string(), "CHAR".to_string(), "CHARACTER".to_string(), "CLOB".to_string(), "DATE".to_string(), "DEC".to_string(), "DECIMAL".to_string(), "DOUBLE".to_string(), "FLOAT".to_string(), "GEOMETRY".to_string(), "HASHTYPE".to_string(), "INT".to_string(), "INTEGER".to_string(), "INTERVAL".to_string(), "LONG".to_string(), "NCHAR".to_string(), "NUMBER".to_string(), "NUMERIC".to_string(), "NVARCHAR".to_string(), "NVARCHAR2".to_string(), "REAL".to_string(), "SHORTINT".to_string(), "SMALLINT".to_string(), "TIMESTAMP".to_string(), "TINYINT".to_string(), "VARCHAR".to_string(), "VARCHAR2".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AnyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ANY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TypeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TYPE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ANY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DatatypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BIGINT".to_string(), "BOOL".to_string(), "BOOLEAN".to_string(), "CHAR".to_string(), "CHARACTER".to_string(), "CLOB".to_string(), "DATE".to_string(), "DEC".to_string(), "DECIMAL".to_string(), "DOUBLE".to_string(), "FLOAT".to_string(), "GEOMETRY".to_string(), "HASHTYPE".to_string(), "INT".to_string(), "INTEGER".to_string(), "INTERVAL".to_string(), "LONG".to_string(), "NCHAR".to_string(), "NUMBER".to_string(), "NUMERIC".to_string(), "NVARCHAR".to_string(), "NVARCHAR2".to_string(), "REAL".to_string(), "SHORTINT".to_string(), "SMALLINT".to_string(), "TIMESTAMP".to_string(), "TINYINT".to_string(), "VARCHAR".to_string(), "VARCHAR2".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ANY".to_string(), "BIGINT".to_string(), "BOOL".to_string(), "BOOLEAN".to_string(), "CHAR".to_string(), "CHARACTER".to_string(), "CLOB".to_string(), "DATE".to_string(), "DEC".to_string(), "DECIMAL".to_string(), "DOUBLE".to_string(), "FLOAT".to_string(), "GEOMETRY".to_string(), "HASHTYPE".to_string(), "INT".to_string(), "INTEGER".to_string(), "INTERVAL".to_string(), "LONG".to_string(), "NCHAR".to_string(), "NUMBER".to_string(), "NUMERIC".to_string(), "NVARCHAR".to_string(), "NVARCHAR2".to_string(), "REAL".to_string(), "SHORTINT".to_string(), "SMALLINT".to_string(), "TIMESTAMP".to_string(), "TINYINT".to_string(), "VARCHAR".to_string(), "VARCHAR2".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='FunctionParameterListGrammar'
pub static FUNCTION_PARAMETER_LIST_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
// FunctionParameterListGrammar
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FunctionParameterGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: true,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='FunctionReferenceSegment'
pub static FUNCTION_REFERENCE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// FunctionReferenceSegment
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "ObjectReferenceDelimiterGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "ObjectReferenceTerminatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    reset_terminators: false,
    allow_gaps: false,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='FunctionScriptStatementSegment'
pub static FUNCTION_SCRIPT_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// FunctionScriptStatementSegment
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateFunctionStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CreateScriptingLuaScriptStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CreateUDFScriptStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CreateAdapterScriptStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='FunctionScriptTerminatorSegment'
pub static FUNCTION_SCRIPT_TERMINATOR_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::TypedParser {
    template: "function_script_terminator",
    token_type: "function_script_terminator",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='FunctionSegment'
pub static FUNCTION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// FunctionSegment
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DatePartFunctionNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD_DAYS".to_string(), "ADD_HOURS".to_string(), "ADD_MINUTES".to_string(), "ADD_MONTHS".to_string(), "ADD_SECONDS".to_string(), "ADD_WEEKS".to_string(), "ADD_YEARS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DateTimeFunctionContentsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD_DAYS".to_string(), "ADD_HOURS".to_string(), "ADD_MINUTES".to_string(), "ADD_MONTHS".to_string(), "ADD_SECONDS".to_string(), "ADD_WEEKS".to_string(), "ADD_YEARS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnsExpressionGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FunctionNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: Some(Box::new(
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DatePartFunctionNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD_DAYS".to_string(), "ADD_HOURS".to_string(), "ADD_MINUTES".to_string(), "ADD_MONTHS".to_string(), "ADD_SECONDS".to_string(), "ADD_WEEKS".to_string(), "ADD_YEARS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnsExpressionFunctionNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ValuesClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
    )),
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "FunctionContentsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "PostFunctionGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='FunctionWhileLoopSegment'
pub static FUNCTION_WHILE_LOOP_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// FunctionWhileLoopSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WhileKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHILE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DoKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FunctionBodySegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    min_times: 1,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "EndKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["END".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WhileKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHILE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SemicolonSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([";".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHILE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='GeneralKeywordSegment'
pub static GENERAL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "GENERAL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='GeneratedKeywordSegment'
pub static GENERATED_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "GENERATED",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='GeometryKeywordSegment'
pub static GEOMETRY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "GEOMETRY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='GetKeywordSegment'
pub static GET_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "GET",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='GlobOperatorSegment'
pub static GLOB_OPERATOR_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::TypedParser {
    template: "glob_operator",
    token_type: "glob_operator",
    raw_class: "ComparisonOperatorSegment",
    optional: false,
})
);

// name='GlobalKeywordSegment'
pub static GLOBAL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "GLOBAL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='GoKeywordSegment'
pub static GO_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "GO",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='GotoKeywordSegment'
pub static GOTO_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "GOTO",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='GrantKeywordSegment'
pub static GRANT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "GRANT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='GrantRevokeConnectionRestrictedSegment'
pub static GRANT_REVOKE_CONNECTION_RESTRICTED_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// GrantRevokeConnectionRestrictedSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AccessKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ACCESS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConnectionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONNECTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ForKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ScriptKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCRIPT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string(), "SCRIPT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FromKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string(), "TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ACCESS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='GrantRevokeConnectionSegment'
pub static GRANT_REVOKE_CONNECTION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// GrantRevokeConnectionSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ConnectionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONNECTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FromKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FromKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string(), "TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AdminKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADMIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OptionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OPTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONNECTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='GrantRevokeImpersonationSegment'
pub static GRANT_REVOKE_IMPERSONATION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// GrantRevokeImpersonationSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ImpersonationKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IMPERSONATION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FromKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FromKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string(), "TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IMPERSONATION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='GrantRevokeObjectPrivilegesSegment'
pub static GRANT_REVOKE_OBJECT_PRIVILEGES_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// GrantRevokeObjectPrivilegesSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AllKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PrivilegesKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PRIVILEGES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ObjectPrivilegesSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string(), "DELETE".to_string(), "EXECUTE".to_string(), "EXPORT".to_string(), "IMPORT".to_string(), "INSERT".to_string(), "REFERENCES".to_string(), "SELECT".to_string(), "UPDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string(), "DELETE".to_string(), "EXECUTE".to_string(), "EXPORT".to_string(), "IMPORT".to_string(), "INSERT".to_string(), "REFERENCES".to_string(), "SELECT".to_string(), "UPDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string(), "ALTER".to_string(), "DELETE".to_string(), "EXECUTE".to_string(), "EXPORT".to_string(), "IMPORT".to_string(), "INSERT".to_string(), "REFERENCES".to_string(), "SELECT".to_string(), "UPDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SchemaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ViewKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VIEW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FUNCTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ScriptKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCRIPT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FUNCTION".to_string(), "SCHEMA".to_string(), "SCRIPT".to_string(), "TABLE".to_string(), "VIEW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AllKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectsKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OBJECTS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string(), "FUNCTION".to_string(), "SCHEMA".to_string(), "SCRIPT".to_string(), "TABLE".to_string(), "VIEW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FromKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CascadeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConstraintsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRAINTS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string(), "TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string(), "ALTER".to_string(), "DELETE".to_string(), "EXECUTE".to_string(), "EXPORT".to_string(), "IMPORT".to_string(), "INSERT".to_string(), "REFERENCES".to_string(), "SELECT".to_string(), "UPDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='GrantRevokeRolesSegment'
pub static GRANT_REVOKE_ROLES_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// GrantRevokeRolesSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AllKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RolesKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROLES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RoleReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FromKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FromKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string(), "TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RoleReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AdminKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADMIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OptionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OPTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='GrantRevokeSystemPrivilegesSegment'
pub static GRANT_REVOKE_SYSTEM_PRIVILEGES_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// GrantRevokeSystemPrivilegesSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AllKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PrivilegesKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PRIVILEGES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SystemPrivilegesSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ACCESS".to_string(), "ALTER".to_string(), "CREATE".to_string(), "DELETE".to_string(), "DROP".to_string(), "EXECUTE".to_string(), "EXPORT".to_string(), "GRANT".to_string(), "IMPERSONATE".to_string(), "IMPORT".to_string(), "INSERT".to_string(), "KILL".to_string(), "MANAGE".to_string(), "SELECT".to_string(), "SET".to_string(), "UPDATE".to_string(), "USE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FromKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ACCESS".to_string(), "ALTER".to_string(), "CREATE".to_string(), "DELETE".to_string(), "DROP".to_string(), "EXECUTE".to_string(), "EXPORT".to_string(), "GRANT".to_string(), "IMPERSONATE".to_string(), "IMPORT".to_string(), "INSERT".to_string(), "KILL".to_string(), "MANAGE".to_string(), "SELECT".to_string(), "SET".to_string(), "UPDATE".to_string(), "USE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ACCESS".to_string(), "ALL".to_string(), "ALTER".to_string(), "CREATE".to_string(), "DELETE".to_string(), "DROP".to_string(), "EXECUTE".to_string(), "EXPORT".to_string(), "GRANT".to_string(), "IMPERSONATE".to_string(), "IMPORT".to_string(), "INSERT".to_string(), "KILL".to_string(), "MANAGE".to_string(), "SELECT".to_string(), "SET".to_string(), "UPDATE".to_string(), "USE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FromKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string(), "TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NakedIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AdminKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADMIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OptionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OPTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ACCESS".to_string(), "ALL".to_string(), "ALTER".to_string(), "CREATE".to_string(), "DELETE".to_string(), "DROP".to_string(), "EXECUTE".to_string(), "EXPORT".to_string(), "GRANT".to_string(), "IMPERSONATE".to_string(), "IMPORT".to_string(), "INSERT".to_string(), "KILL".to_string(), "MANAGE".to_string(), "SELECT".to_string(), "SET".to_string(), "UPDATE".to_string(), "USE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='GrantedKeywordSegment'
pub static GRANTED_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "GRANTED",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='GraphKeywordSegment'
pub static GRAPH_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "GRAPH",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='GreaterThanOrEqualToSegment'
pub static GREATER_THAN_OR_EQUAL_TO_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// GreaterThanOrEqualToSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RawGreaterThanSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([">".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RawEqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: false,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([">".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='GreaterThanSegment'
pub static GREATER_THAN_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// GreaterThanSegment
Arc::new(Grammar::Ref {
    name: "RawGreaterThanSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([">".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='GreatestKeywordSegment'
pub static GREATEST_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "GREATEST",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='GroupByClauseSegment'
pub static GROUP_BY_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// GroupByClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "GroupKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CubeRollupClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CUBE".to_string(), "ROLLUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "GroupingSetsClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUPING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OrderKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LimitKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LIMIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "HavingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["HAVING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QualifyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["QUALIFY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SetOperatorSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCEPT".to_string(), "INTERSECT".to_string(), "MINUS".to_string(), "UNION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("dedent"))
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='GroupByClauseTerminatorGrammar'
pub static GROUP_BY_CLAUSE_TERMINATOR_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OrderKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LimitClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LIMIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "HavingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["HAVING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QualifyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["QUALIFY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WindowKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WINDOW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FetchKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FETCH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FETCH".to_string(), "HAVING".to_string(), "LIMIT".to_string(), "ORDER".to_string(), "QUALIFY".to_string(), "WINDOW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='GroupKeywordSegment'
pub static GROUP_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "GROUP",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Group_concatKeywordSegment'
pub static GROUP_CONCAT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "GROUP_CONCAT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Group_temp_db_ram_limitKeywordSegment'
pub static GROUP_TEMP_DB_RAM_LIMIT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "GROUP_TEMP_DB_RAM_LIMIT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='GroupingExpressionList'
pub static GROUPING_EXPRESSION_LIST: Lazy<Arc<Grammar>> = Lazy::new(||
// GroupingExpressionList
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "GroupByClauseTerminatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FETCH".to_string(), "HAVING".to_string(), "LIMIT".to_string(), "ORDER".to_string(), "QUALIFY".to_string(), "WINDOW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='GroupingKeywordSegment'
pub static GROUPING_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "GROUPING",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='GroupingSetsClauseSegment'
pub static GROUPING_SETS_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// GroupingSetsClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "GroupingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUPING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SetsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SETS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CubeRollupClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CUBE".to_string(), "ROLLUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "GroupingExpressionList",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUPING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='Grouping_idKeywordSegment'
pub static GROUPING_ID_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "GROUPING_ID",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='GroupsKeywordSegment'
pub static GROUPS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "GROUPS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='HandlerKeywordSegment'
pub static HANDLER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "HANDLER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='HasKeywordSegment'
pub static HAS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "HAS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='HashKeywordSegment'
pub static HASH_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "HASH",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Hash_md5KeywordSegment'
pub static HASH_MD5_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "HASH_MD5",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Hash_sha1KeywordSegment'
pub static HASH_SHA1_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "HASH_SHA1",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Hash_sha256KeywordSegment'
pub static HASH_SHA256_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "HASH_SHA256",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Hash_sha512KeywordSegment'
pub static HASH_SHA512_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "HASH_SHA512",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Hash_shaKeywordSegment'
pub static HASH_SHA_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "HASH_SHA",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Hash_tigerKeywordSegment'
pub static HASH_TIGER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "HASH_TIGER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='HashtypeKeywordSegment'
pub static HASHTYPE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "HASHTYPE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Hashtype_formatKeywordSegment'
pub static HASHTYPE_FORMAT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "HASHTYPE_FORMAT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Hashtype_md5KeywordSegment'
pub static HASHTYPE_MD5_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "HASHTYPE_MD5",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Hashtype_sha1KeywordSegment'
pub static HASHTYPE_SHA1_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "HASHTYPE_SHA1",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Hashtype_sha256KeywordSegment'
pub static HASHTYPE_SHA256_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "HASHTYPE_SHA256",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Hashtype_sha512KeywordSegment'
pub static HASHTYPE_SHA512_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "HASHTYPE_SHA512",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Hashtype_shaKeywordSegment'
pub static HASHTYPE_SHA_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "HASHTYPE_SHA",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Hashtype_tigerKeywordSegment'
pub static HASHTYPE_TIGER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "HASHTYPE_TIGER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='HavingClauseSegment'
pub static HAVING_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// HavingClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "HavingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["HAVING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("dedent"))
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["HAVING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='HavingClauseTerminatorGrammar'
pub static HAVING_CLAUSE_TERMINATOR_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OrderKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LimitClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LIMIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QualifyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["QUALIFY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WindowKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WINDOW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FetchKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FETCH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FETCH".to_string(), "LIMIT".to_string(), "ORDER".to_string(), "QUALIFY".to_string(), "WINDOW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='HavingKeywordSegment'
pub static HAVING_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "HAVING",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='HierarchyKeywordSegment'
pub static HIERARCHY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "HIERARCHY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='HighKeywordSegment'
pub static HIGH_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "HIGH",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='HoldKeywordSegment'
pub static HOLD_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "HOLD",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='HorizontalJoinKeywordsGrammar'
pub static HORIZONTAL_JOIN_KEYWORDS_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Nothing())
);

// name='HourKeywordSegment'
pub static HOUR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "HOUR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Hours_betweenKeywordSegment'
pub static HOURS_BETWEEN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "HOURS_BETWEEN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='IdentifiedKeywordSegment'
pub static IDENTIFIED_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "IDENTIFIED",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='IdentifierSegment'
pub static IDENTIFIER_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Token{
    token_type: "identifier",
//    token_type: "IdentifierSegment",
})
);

// name='IdentityKeywordSegment'
pub static IDENTITY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "IDENTITY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Idle_timeoutKeywordSegment'
pub static IDLE_TIMEOUT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "IDLE_TIMEOUT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='IfExistsGrammar'
pub static IF_EXISTS_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IfKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExistsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXISTS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='IfKeywordSegment'
pub static IF_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "IF",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='IfNotExistsGrammar'
pub static IF_NOT_EXISTS_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IfKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NotKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExistsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXISTS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='IfnullKeywordSegment'
pub static IFNULL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "IFNULL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='IgnoreKeywordSegment'
pub static IGNORE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "IGNORE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='IgnoreRespectNullsGrammar'
pub static IGNORE_RESPECT_NULLS_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IgnoreKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IGNORE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RespectKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESPECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IGNORE".to_string(), "RESPECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NullsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NULLS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IGNORE".to_string(), "RESPECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ImmediateKeywordSegment'
pub static IMMEDIATE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "IMMEDIATE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ImpersonateKeywordSegment'
pub static IMPERSONATE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "IMPERSONATE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ImpersonateSegment'
pub static IMPERSONATE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ImpersonateSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ImpersonateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IMPERSONATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IMPERSONATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ImpersonationKeywordSegment'
pub static IMPERSONATION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "IMPERSONATION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ImplementationKeywordSegment'
pub static IMPLEMENTATION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "IMPLEMENTATION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ImplicitIndent'
pub static IMPLICIT_INDENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Meta("indent"))
);

// name='ImportColumnsSegment'
pub static IMPORT_COLUMNS_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ImportColumnsSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColumnDatatypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "CreateTableLikeClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LIKE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='ImportErrorDestinationSegment'
pub static IMPORT_ERROR_DESTINATION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ImportErrorDestinationSegment
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CsvKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CSV".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AtKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConnectionDefinition",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FileKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FILE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CSV".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LocalKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LOCAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SecureKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SECURE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CsvKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CSV".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FileKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FILE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LOCAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='ImportErrorsClauseSegment'
pub static IMPORT_ERRORS_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ImportErrorsClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ErrorsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ERRORS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IntoKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INTO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ImportErrorDestinationSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ReplaceKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REPLACE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TruncateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TRUNCATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REPLACE".to_string(), "TRUNCATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RejectClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REJECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ERRORS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ImportFromClauseSegment'
pub static IMPORT_FROM_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ImportFromClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FromKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ImportFromExportIntoDbSrcSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXA".to_string(), "JDBC".to_string(), "ORA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ImportFromExportIntoFileSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CSV".to_string(), "FBV".to_string(), "LOCAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CSV".to_string(), "EXA".to_string(), "FBV".to_string(), "JDBC".to_string(), "LOCAL".to_string(), "ORA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ImportErrorsClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ERRORS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CSV".to_string(), "EXA".to_string(), "FBV".to_string(), "JDBC".to_string(), "LOCAL".to_string(), "ORA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ImportFromExportIntoScriptSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCRIPT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CSV".to_string(), "EXA".to_string(), "FBV".to_string(), "JDBC".to_string(), "LOCAL".to_string(), "ORA".to_string(), "SCRIPT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ImportFromExportIntoDbSrcSegment'
pub static IMPORT_FROM_EXPORT_INTO_DB_SRC_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ImportFromExportIntoDbSrcSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OraKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "JdbcKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["JDBC".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DriverKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DRIVER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DRIVER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["JDBC".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXA".to_string(), "JDBC".to_string(), "ORA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AtKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConnectionDefinition",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierListSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ReplaceKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REPLACE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TruncateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TRUNCATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REPLACE".to_string(), "TRUNCATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreatedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 0,
    max_times: Some(2),
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATED".to_string(), "REPLACE".to_string(), "TRUNCATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATED".to_string(), "REPLACE".to_string(), "TRUNCATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "StatementKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STATEMENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STATEMENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 1,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STATEMENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STATEMENT".to_string(), "TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXA".to_string(), "JDBC".to_string(), "ORA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ImportFromExportIntoFileSegment'
pub static IMPORT_FROM_EXPORT_INTO_FILE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ImportFromExportIntoFileSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CsvKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CSV".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FbvKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FBV".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CSV".to_string(), "FBV".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AtKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConnectionDefinition",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FileKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FILE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["single_quote".to_string()]),
        }),
})
,
    ],
    min_times: 1,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FILE".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["single_quote".to_string()]),
        }),
})
,
    ],
    min_times: 1,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AT".to_string(), "FILE".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CSV".to_string(), "FBV".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LocalKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LOCAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SecureKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SECURE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CsvKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CSV".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FbvKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FBV".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CSV".to_string(), "FBV".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FileKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FILE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["single_quote".to_string()]),
        }),
})
,
    ],
    min_times: 1,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FILE".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LOCAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CSV".to_string(), "FBV".to_string(), "LOCAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CSVColumnDefinitionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FBVColumnDefinitionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FileOptionSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string(), "BOOLEAN".to_string(), "COLUMN".to_string(), "DELIMIT".to_string(), "ENCODING".to_string(), "LTRIM".to_string(), "NULL".to_string(), "REPLACE".to_string(), "ROW".to_string(), "RTRIM".to_string(), "SKIP".to_string(), "TRIM".to_string(), "TRUNCATE".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CSV".to_string(), "FBV".to_string(), "LOCAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ImportFromExportIntoScriptSegment'
pub static IMPORT_FROM_EXPORT_INTO_SCRIPT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ImportFromExportIntoScriptSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ScriptKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCRIPT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AtKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConnectionDefinition",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    min_times: 1,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCRIPT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ImportKeywordSegment'
pub static IMPORT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "IMPORT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ImportStatementSegment'
pub static IMPORT_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ImportStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ImportKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IMPORT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IntoKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INTO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierListSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ImportColumnsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INTO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ImportFromClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IMPORT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='InKeywordSegment'
pub static IN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "IN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='InOperatorGrammar'
pub static IN_OPERATOR_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NotKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "InKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "Expression_A_Grammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "SelectableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "SELECT".to_string(), "VALUES".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Greedy,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IN".to_string(), "NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='IncludingKeywordSegment'
pub static INCLUDING_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "INCLUDING",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Indent'
pub static INDENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Meta("indent"))
);

// name='IndexColumnDefinitionSegment'
pub static INDEX_COLUMN_DEFINITION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// IndexColumnDefinitionSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AscKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ASC".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DescKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DESC".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ASC".to_string(), "DESC".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='IndexKeywordSegment'
pub static INDEX_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "INDEX",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='IndexReferenceSegment'
pub static INDEX_REFERENCE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// IndexReferenceSegment
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "ObjectReferenceDelimiterGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "ObjectReferenceTerminatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    reset_terminators: false,
    allow_gaps: false,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='IndicatorKeywordSegment'
pub static INDICATOR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "INDICATOR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='InitcapKeywordSegment'
pub static INITCAP_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "INITCAP",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='InitiallyKeywordSegment'
pub static INITIALLY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "INITIALLY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='InnerKeywordSegment'
pub static INNER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "INNER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='InoutKeywordSegment'
pub static INOUT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "INOUT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='InputKeywordSegment'
pub static INPUT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "INPUT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='InsensitiveKeywordSegment'
pub static INSENSITIVE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "INSENSITIVE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='InsertKeywordSegment'
pub static INSERT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "INSERT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='InsertStatementSegment'
pub static INSERT_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// InsertStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "InsertKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INSERT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IntoKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INTO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ValuesRangeClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DefaultKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ValuesKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SelectableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "SELECT".to_string(), "VALUES".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BracketedColumnReferenceListGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "DEFAULT".to_string(), "SELECT".to_string(), "VALUES".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INSERT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='InstanceKeywordSegment'
pub static INSTANCE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "INSTANCE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='InstantiableKeywordSegment'
pub static INSTANTIABLE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "INSTANTIABLE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='InstrKeywordSegment'
pub static INSTR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "INSTR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='IntKeywordSegment'
pub static INT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "INT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='IntegerKeywordSegment'
pub static INTEGER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "INTEGER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='IntegrityKeywordSegment'
pub static INTEGRITY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "INTEGRITY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='IntersectKeywordSegment'
pub static INTERSECT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "INTERSECT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='IntervalExpressionSegment'
pub static INTERVAL_EXPRESSION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// IntervalExpressionSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IntervalKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INTERVAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "MonthKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MONTH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MONTH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "YearKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["YEAR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MonthKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MONTH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["YEAR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DayKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DAY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "HourKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["HOUR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MinuteKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MINUTE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DAY".to_string(), "HOUR".to_string(), "MINUTE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DAY".to_string(), "HOUR".to_string(), "MINUTE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SecondKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SECOND".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SECOND".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DAY".to_string(), "HOUR".to_string(), "MINUTE".to_string(), "SECOND".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "HourKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["HOUR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MinuteKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MINUTE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SecondKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SECOND".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SECOND".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["HOUR".to_string(), "MINUTE".to_string(), "SECOND".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DAY".to_string(), "HOUR".to_string(), "MINUTE".to_string(), "SECOND".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DAY".to_string(), "HOUR".to_string(), "MINUTE".to_string(), "MONTH".to_string(), "SECOND".to_string(), "YEAR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INTERVAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='IntervalKeywordSegment'
pub static INTERVAL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "INTERVAL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='IntoKeywordSegment'
pub static INTO_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "INTO",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='IntoTableSegment'
pub static INTO_TABLE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// IntoTableSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IntoKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INTO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INTO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='InvalidKeywordSegment'
pub static INVALID_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "INVALID",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='InverseKeywordSegment'
pub static INVERSE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "INVERSE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='InvokerKeywordSegment'
pub static INVOKER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "INVOKER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='IprocKeywordSegment'
pub static IPROC_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "IPROC",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='IsClauseGrammar'
pub static IS_CLAUSE_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NullLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NanLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "UnknownLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "BooleanLiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FALSE".to_string(), "TRUE".to_string(), "UNKNOWN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NormalizedGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='IsDistinctFromGrammar'
pub static IS_DISTINCT_FROM_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NotKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DistinctKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DISTINCT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FromKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='IsKeywordSegment'
pub static IS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "IS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='IsNullGrammar'
pub static IS_NULL_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Nothing())
);

// name='Is_booleanKeywordSegment'
pub static IS_BOOLEAN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "IS_BOOLEAN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Is_dateKeywordSegment'
pub static IS_DATE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "IS_DATE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Is_dsintervalKeywordSegment'
pub static IS_DSINTERVAL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "IS_DSINTERVAL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Is_numberKeywordSegment'
pub static IS_NUMBER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "IS_NUMBER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Is_timestampKeywordSegment'
pub static IS_TIMESTAMP_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "IS_TIMESTAMP",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Is_ymintervalKeywordSegment'
pub static IS_YMINTERVAL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "IS_YMINTERVAL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='IsolationKeywordSegment'
pub static ISOLATION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ISOLATION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='IterateKeywordSegment'
pub static ITERATE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ITERATE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='JavaKeywordSegment'
pub static JAVA_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "JAVA",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='JavascriptKeywordSegment'
pub static JAVASCRIPT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "JAVASCRIPT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='JdbcKeywordSegment'
pub static JDBC_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "JDBC",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='JoinClauseSegment'
pub static JOIN_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// JoinClauseSegment
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ConditionalJoinKeywordsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "JoinKeywordsGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["JOIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::Ref {
    name: "FromExpressionElementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NestedJoinGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("dedent"))
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Meta("conditional"))
,
Arc::new(Grammar::Ref {
    name: "MatchConditionSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "JoinOnConditionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "JoinUsingConditionGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string(), "USING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("conditional"))
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "UnconditionalJoinKeywordsGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "JoinKeywordsGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["JOIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::Ref {
    name: "FromExpressionElementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "MatchConditionSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("dedent"))
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExtendedNaturalJoinKeywordsGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::Ref {
    name: "FromExpressionElementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("dedent"))
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='JoinKeywordSegment'
pub static JOIN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "JOIN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='JoinKeywordsGrammar'
pub static JOIN_KEYWORDS_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "JoinKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["JOIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["JOIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='JoinLikeClauseGrammar'
pub static JOIN_LIKE_CLAUSE_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Nothing())
);

// name='JoinOnConditionSegment'
pub static JOIN_ON_CONDITION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// JoinOnConditionSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("conditional"))
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("conditional"))
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='JoinTypeKeywordsGrammar'
pub static JOIN_TYPE_KEYWORDS_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "InnerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INNER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FullKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LeftKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LEFT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RightKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RIGHT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FULL".to_string(), "LEFT".to_string(), "RIGHT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OuterKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OUTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FULL".to_string(), "LEFT".to_string(), "RIGHT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FULL".to_string(), "INNER".to_string(), "LEFT".to_string(), "RIGHT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='JoinUsingConditionGrammar'
pub static JOIN_USING_CONDITION_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "UsingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Greedy,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("dedent"))
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='JsonKeywordSegment'
pub static JSON_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "JSON",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Json_extractKeywordSegment'
pub static JSON_EXTRACT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "JSON_EXTRACT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Json_valueKeywordSegment'
pub static JSON_VALUE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "JSON_VALUE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='KeepKeywordSegment'
pub static KEEP_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "KEEP",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='KerberosKeywordSegment'
pub static KERBEROS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "KERBEROS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='KeyKeywordSegment'
pub static KEY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "KEY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Key_memberKeywordSegment'
pub static KEY_MEMBER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "KEY_MEMBER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Key_typeKeywordSegment'
pub static KEY_TYPE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "KEY_TYPE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='KeysKeywordSegment'
pub static KEYS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "KEYS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='KeywordSegment'
pub static KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Token{
    token_type: "keyword",
//    token_type: "KeywordSegment",
})
);

// name='KillKeywordSegment'
pub static KILL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "KILL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='KillSegment'
pub static KILL_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// KillSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "KillKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["KILL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SessionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SESSION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "Current_sessionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_SESSION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_SESSION".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SESSION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "StatementKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STATEMENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "InKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SessionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SESSION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MessageKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MESSAGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["single_quote".to_string()]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STATEMENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SESSION".to_string(), "STATEMENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["KILL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='LagKeywordSegment'
pub static LAG_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LAG",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LanguageKeywordSegment'
pub static LANGUAGE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LANGUAGE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LargeKeywordSegment'
pub static LARGE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LARGE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LastKeywordSegment'
pub static LAST_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LAST",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Last_valueKeywordSegment'
pub static LAST_VALUE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LAST_VALUE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LateralKeywordSegment'
pub static LATERAL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LATERAL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LcaseKeywordSegment'
pub static LCASE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LCASE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LdapKeywordSegment'
pub static LDAP_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LDAP",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LeadKeywordSegment'
pub static LEAD_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LEAD",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LeadingKeywordSegment'
pub static LEADING_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LEADING",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LeastKeywordSegment'
pub static LEAST_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LEAST",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LeaveKeywordSegment'
pub static LEAVE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LEAVE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LeftKeywordSegment'
pub static LEFT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LEFT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LengthKeywordSegment'
pub static LENGTH_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LENGTH",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LessThanOrEqualToSegment'
pub static LESS_THAN_OR_EQUAL_TO_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// LessThanOrEqualToSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RawLessThanSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["<".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RawEqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: false,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["<".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='LessThanSegment'
pub static LESS_THAN_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// LessThanSegment
Arc::new(Grammar::Ref {
    name: "RawLessThanSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["<".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='LevelKeywordSegment'
pub static LEVEL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LEVEL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LikeExpressionGrammar'
pub static LIKE_EXPRESSION_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NotKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LikeGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LIKE".to_string(), "REGEXP_LIKE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LIKE".to_string(), "NOT".to_string(), "REGEXP_LIKE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Expression_A_Grammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "EscapeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ESCAPE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Tail_Recurse_Expression_A_Grammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ESCAPE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LIKE".to_string(), "NOT".to_string(), "REGEXP_LIKE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='LikeGrammar'
pub static LIKE_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LikeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LIKE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Regexp_likeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REGEXP_LIKE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LIKE".to_string(), "REGEXP_LIKE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='LikeKeywordSegment'
pub static LIKE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LIKE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LikeOperatorSegment'
pub static LIKE_OPERATOR_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::TypedParser {
    template: "like_operator",
    token_type: "like_operator",
    raw_class: "ComparisonOperatorSegment",
    optional: false,
})
);

// name='LimitClauseSegment'
pub static LIMIT_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// LimitClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LimitKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LIMIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OffsetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OFFSET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OFFSET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LIMIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='LimitKeywordSegment'
pub static LIMIT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LIMIT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LinkKeywordSegment'
pub static LINK_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LINK",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ListComprehensionGrammar'
pub static LIST_COMPREHENSION_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Nothing())
);

// name='ListaggKeywordSegment'
pub static LISTAGG_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LISTAGG",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LiteralGrammar'
pub static LITERAL_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BooleanLiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FALSE".to_string(), "TRUE".to_string(), "UNKNOWN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QualifiedNumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["+".to_string(), "-".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NullLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DateTimeLiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATE".to_string(), "TIMESTAMP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ArrayLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["[".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TypedArrayLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ObjectLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["{".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='LiteralKeywordSegment'
pub static LITERAL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Token{
    token_type: "literal",
//    token_type: "LiteralKeywordSegment",
})
);

// name='LiteralSegment'
pub static LITERAL_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Token{
    token_type: "literal",
//    token_type: "LiteralSegment",
})
);

// name='LnKeywordSegment'
pub static LN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LocalAliasSegment'
pub static LOCAL_ALIAS_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// LocalAliasSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LocalKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LOCAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DotSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LOCAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='LocalKeywordSegment'
pub static LOCAL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LOCAL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LocaltimeKeywordSegment'
pub static LOCALTIME_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LOCALTIME",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LocaltimestampKeywordSegment'
pub static LOCALTIMESTAMP_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LOCALTIMESTAMP",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LocateKeywordSegment'
pub static LOCATE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LOCATE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LocatorKeywordSegment'
pub static LOCATOR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LOCATOR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LockKeywordSegment'
pub static LOCK_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LOCK",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Log10KeywordSegment'
pub static LOG10_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LOG10",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Log2KeywordSegment'
pub static LOG2_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LOG2",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LogKeywordSegment'
pub static LOG_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LOG",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LoginKeywordSegment'
pub static LOGIN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LOGIN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LogsKeywordSegment'
pub static LOGS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LOGS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LongKeywordSegment'
pub static LONG_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LONG",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LongvarcharKeywordSegment'
pub static LONGVARCHAR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LONGVARCHAR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LoopKeywordSegment'
pub static LOOP_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LOOP",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LowKeywordSegment'
pub static LOW_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LOW",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LowerKeywordSegment'
pub static LOWER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LOWER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LpadKeywordSegment'
pub static LPAD_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LPAD",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LtrimKeywordSegment'
pub static LTRIM_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LTRIM",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LuaKeywordSegment'
pub static LUA_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LUA",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MLTableExpressionSegment'
pub static M_L_TABLE_EXPRESSION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// MLTableExpressionSegment
Arc::new(Grammar::Nothing())
);

// name='ManageKeywordSegment'
pub static MANAGE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MANAGE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MapKeywordSegment'
pub static MAP_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MAP",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MapTypeSegment'
pub static MAP_TYPE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// MapTypeSegment
Arc::new(Grammar::Nothing())
);

// name='MatchConditionSegment'
pub static MATCH_CONDITION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// MatchConditionSegment
Arc::new(Grammar::Nothing())
);

// name='MatchKeywordSegment'
pub static MATCH_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MATCH",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MatchedKeywordSegment'
pub static MATCHED_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MATCHED",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MaxKeywordSegment'
pub static MAX_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MAX",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MaximalKeywordSegment'
pub static MAXIMAL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MAXIMAL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MedianKeywordSegment'
pub static MEDIAN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MEDIAN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MergeDeleteClauseSegment'
pub static MERGE_DELETE_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// MergeDeleteClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DeleteKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DELETE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WhereClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHERE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DELETE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='MergeInsertClauseSegment'
pub static MERGE_INSERT_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// MergeInsertClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "InsertKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INSERT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::Ref {
    name: "BracketedColumnReferenceListGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("dedent"))
,
Arc::new(Grammar::Ref {
    name: "ValuesClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WhereClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHERE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INSERT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='MergeIntoLiteralGrammar'
pub static MERGE_INTO_LITERAL_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "MergeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MERGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IntoKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INTO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MERGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='MergeKeywordSegment'
pub static MERGE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MERGE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MergeMatchSegment'
pub static MERGE_MATCH_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// MergeMatchSegment
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "MergeMatchedClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MergeNotMatchedClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "MergeNotMatchedClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MergeMatchedClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='MergeMatchedClauseSegment'
pub static MERGE_MATCHED_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// MergeMatchedClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WhenKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MatchedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MATCHED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ThenKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["THEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "MergeUpdateClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UPDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MergeDeleteClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DELETE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DELETE".to_string(), "UPDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='MergeNotMatchedClauseSegment'
pub static MERGE_NOT_MATCHED_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// MergeNotMatchedClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WhenKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NotKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MatchedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MATCHED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ThenKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["THEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MergeInsertClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INSERT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='MergeStatementSegment'
pub static MERGE_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// MergeStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "MergeIntoLiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MERGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AliasedTableReferenceGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("dedent"))
,
Arc::new(Grammar::Ref {
    name: "UsingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AliasedTableReferenceGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SelectableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "SELECT".to_string(), "VALUES".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AliasExpressionSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("dedent"))
,
Arc::new(Grammar::Meta("conditional"))
,
Arc::new(Grammar::Ref {
    name: "JoinOnConditionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("conditional"))
,
Arc::new(Grammar::Ref {
    name: "MergeMatchSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MERGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='MergeUpdateClauseSegment'
pub static MERGE_UPDATE_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// MergeUpdateClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "UpdateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UPDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SetClauseListSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WhereClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHERE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UPDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='MessageKeywordSegment'
pub static MESSAGE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MESSAGE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MethodKeywordSegment'
pub static METHOD_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "METHOD",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MidKeywordSegment'
pub static MID_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MID",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MinKeywordSegment'
pub static MIN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MIN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Min_scaleKeywordSegment'
pub static MIN_SCALE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MIN_SCALE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MinusKeywordSegment'
pub static MINUS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MINUS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MinusSegment'
pub static MINUS_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "-",
    token_type: "binary_operator",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='MinuteKeywordSegment'
pub static MINUTE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MINUTE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Minutes_betweenKeywordSegment'
pub static MINUTES_BETWEEN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MINUTES_BETWEEN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ModKeywordSegment'
pub static MOD_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MOD",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ModifiesKeywordSegment'
pub static MODIFIES_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MODIFIES",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ModifyKeywordSegment'
pub static MODIFY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MODIFY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ModuleKeywordSegment'
pub static MODULE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MODULE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ModuloSegment'
pub static MODULO_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "%",
    token_type: "binary_operator",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='MonthKeywordSegment'
pub static MONTH_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MONTH",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Months_betweenKeywordSegment'
pub static MONTHS_BETWEEN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MONTHS_BETWEEN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MulKeywordSegment'
pub static MUL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MUL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MultipleKeywordSegment'
pub static MULTIPLE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MULTIPLE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MultiplySegment'
pub static MULTIPLY_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "*",
    token_type: "binary_operator",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='MumpsKeywordSegment'
pub static MUMPS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MUMPS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NakedIdentifierSegment'
pub static NAKED_IDENTIFIER_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::RegexParser {
    template: regex::RegexBuilder::new(r#"[A-Z0-9_]*[A-Z][A-Z0-9_]*"#)
         .case_insensitive(true)
         .build()
         .unwrap(),
    token_type: "naked_identifier",
    raw_class: "IdentifierSegment",
    optional: false,
    anti_template: Some(regex::RegexBuilder::new(r#"^(BYTE|COLLATION_CATALOG|OR|IS|DYNAMIC|YEAR|YES|DLURLSCHEME|MOD|ROW|LOOP|SETS|RECOVERY|EXTRACT|INTERSECT|RIGHT|FILE|LISTAGG|DECLARE|CONSTRAINTS|OF|FUNCTION|ROUTINE|WHENEVER|SQL_DECIMAL|ORDINALITY|DISABLE|SQL_BIT|CUBE|LOCALTIME|STATEMENT|MINUTE|ESCAPE|LARGE|SQL_CHAR|PARALLEL_ENABLE|ALTER|EXEC|INTEGRITY|PARAMETER|PAD|SQL_SMALLINT|CROSS|DLURLCOMPLETE|SUBSTRING|AUTHID|CONNECTION|CURRENT_STATEMENT|CONDITION|PRIVILEGES|SCOPE|SESSION|ABSOLUTE|GO|PROFILE|VARCHAR2|CURRENT_SCHEMA|SQL_REAL|CLOSE|DISPATCH|MAP|SIMILAR|SEQUENCE|ERRORS|ONLY|OUTER|SQL_DATE|MODULE|OBJECT|SQL_DOUBLE|NEXT|IMPLEMENTATION|DAY|IF|LEVEL|HIGH|REFRESH|TINYINT|BY|PARAMETER_SPECIFIC_NAME|CHARACTER_SET_NAME|METHOD|SYSDATE|NATURAL|VALUES|DISTINCT|DISCONNECT|SPACE|DOMAIN|NLS_DATE_FORMAT|SCHEMA|END|ASC|RECURSIVE|OTHERS|CONSTRUCTOR|WORK|RANDOM|DBTIMEZONE|QUALIFY|INNER|CS|ALLOCATE|ITERATE|STATE|SEPARATOR|CSV|ORDERING|SQLSTATE|SECTION|BOOL|WHEN|TRIGGER|FS|BINARY|FORMAT|LOG|TRUE|OVER|WHERE|LAST|NVARCHAR2|ASSERTION|SECOND|DECIMAL|PLACING|WITHOUT|EMITS|FREE|FOLLOWING|RANGE|CURRENT_ROLE|CALLED|DEFERRED|DYNAMIC_FUNCTION_CODE|PARTIAL|CALL|IMPERSONATE|RETURN|SPECIFICTYPE|NEW|LONGVARCHAR|GROUP|NCLOB|NCHAR|COMMIT|SQL_LONGVARCHAR|WITHIN|GROUP_CONCAT|CURRENT|REFERENCES|BLOCKED|AS|OPEN|NAMES|ROWTYPE|COALESCE|OLD|SQL_VARCHAR|MERGE|NATIONAL|CONNECT_BY_ISCYCLE|STRUCTURE|USER|SENSITIVE|COLLATION_SCHEMA|CURRENT_PATH|CONTROL|LOCATOR|KEY_TYPE|CONSTANT|SET|MONTH|ATTRIBUTE|CASE|SCROLL|INDEX|SEARCH|VARCHAR|SOME|AT|DATE|FBV|OPTION|ROLLBACK|PRECEDING|OVERLAY|DEC|GLOBAL|PRESERVE|USING|TIMEZONE_MINUTE|HASHTYPE|REVOKE|TRANSLATION|CURRENT_TIMESTAMP|SQL_TINYINT|MODIFY|LOCALTIMESTAMP|CONNECT_BY_ISLEAF|CASESPECIFIC|COLLATION|DESCRIBE|UNLINK|ARRAY|START|BOTH|GRANTED|INPUT|JOIN|DLURLPATH|OUT|DATETIME_INTERVAL_PRECISION|DEFERRABLE|LEADING|ROLLUP|INSTANTIABLE|ENDIF|NVARCHAR|EXPORT|IFNULL|CAST|VALUE|ORDER|GROUPS|RETURNED_LENGTH|RENAME|LOW|COLLATION_NAME|DROP|OFF|TEMPORARY|TIMESTAMP|AUTHORIZATION|CURRENT_USER|INTERVAL|INTO|HOUR|TIMEZONE_HOUR|CATALOG|INVOKER|BEGIN|WINDOW|HAVING|LEAVE|BEFORE|USAGE|DO|INTEGER|NUMERIC|IMMEDIATE|ELSE|SHORTINT|SQL|CHECK|DISABLED|CHECKED|FOR|NO|ASENSITIVE|DERIVED|WHILE|DEFINER|DYNAMIC_FUNCTION|SCOPE_USER|DOUBLE|EXTERNAL|DEFAULT_LIKE_ESCAPE_CHARACTER|UNION|EQUALS|APPEND|FIRST|PATH|UNDER|COLUMN|DLVALUE|REPLACE|FINAL|SUBTYPE|SQL_TIMESTAMP|INOUT|NOLOGGING|DESC|NOT|CREATE|ARE|REFERENCING|SQL_PREPROCESSOR_SCRIPT|SQL_NUMERIC|BIGINT|PRIOR|DLURLPATHONLY|NULLIF|NOCYCLE|LEFT|THEN|UNKNOWN|SQL_BIGINT|OVERLAPS|CHARACTER|PARTITION|PREFERRING|WITH|TRANSACTION|CHAIN|REF|CHARACTER_SET_SCHEMA|BETWEEN|SCRIPT|REGEXP_LIKE|CONSTRAINT|SQL_FLOAT|PARAMETER_SPECIFIC_CATALOG|ELSEIF|INSTANCE|PROCEDURE|AFTER|IN|SPECIFIC|ROWS|TRANSFORMS|CHARACTERISTICS|UPDATE|FORALL|AND|INSERT|DESCRIPTOR|NLS_FIRST_DAY_OF_WEEK|SESSIONTIMEZONE|POSITION|IDENTITY|UNTIL|DATA|NONE|TO|GENERATED|SYSTIMESTAMP|TRUNCATE|SOURCE|ELSIF|FLOAT|DETERMINISTIC|CLOB|PREPARE|CARDINALITY|SYSTEM_USER|CONSTRAINT_STATE_DEFAULT|EXIT|CORRESPONDING|MATCH|DATETIME_INTERVAL_CODE|EXECUTE|GROUPING|INT|OUTPUT|SQL_TYPE_TIMESTAMP|TEXT|ANY|CHARACTER_SET_CATALOG|MODIFIES|HASHTYPE_FORMAT|DLURLSERVER|CONTAINS|MINUS|KEY_MEMBER|RESTORE|TABLE|EXCEPT|PARAMETER_SPECIFIC_SCHEMA|DEFINED|REAL|RESULT|BOOLEAN|GOTO|SQL_TYPE_DATE|MATCHED|FETCH|INVERSE|FORCE|LIKE|RESTRICT|EXCEPTION|OPTIONS|STYLE|NLS_DATE_LANGUAGE|LDAP|DEFAULT|ON|DELETE|SQLWARNING|END-EXEC|TRIM|FULL|FOUND|ADD|CYCLE|UNIQUE|FROM|ACTION|BLOB|TRANSFORM|READ|CONVERT|TIME|INDICATOR|CURRENT_TIME|TREAT|NUMBER|TRAILING|SQL_INTEGER|CURSOR|ENABLE|SAVEPOINT|STATIC|SESSION_USER|SYSTEM|ENABLED|DEALLOCATE|PLUS|VIEW|FALSE|ALL|NULL|READS|RETURNS|CURRENT_SESSION|SQLEXCEPTION|SELECTIVE|BIT|SECURITY|GEOMETRY|ENFORCE|GENERAL|SELF|SMALLINT|COLLATE|DATALINK|NLS_NUMERIC_CHARACTERS|INSENSITIVE|SELECT|PERMISSION|CASCADE|NLS_TIMESTAMP_FORMAT|ZONE|RELEASE|CASCADED|VERIFY|LATERAL|IMPORT|RELATIVE|CURRENT_DATE|UNNEST|DEREF|REPEAT|VARRAY|CHAR|EACH|CONNECT_BY_ROOT|CONTINUE|LIMIT|RETURNED_OCTET_LENGTH|LOCAL|GRANT|OVERRIDING|HOLD|EXISTS|GET)$"#)         .case_insensitive(true)         .build()         .unwrap()     ),
})
);

// name='NamedWindowExpressionSegment'
pub static NAMED_WINDOW_EXPRESSION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// NamedWindowExpressionSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WindowSpecificationSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Greedy,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='NamedWindowSegment'
pub static NAMED_WINDOW_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// NamedWindowSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WindowKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WINDOW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NamedWindowExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("dedent"))
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WINDOW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='NamesKeywordSegment'
pub static NAMES_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NAMES",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NanLiteralSegment'
pub static NAN_LITERAL_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Nothing())
);

// name='NationalKeywordSegment'
pub static NATIONAL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NATIONAL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NaturalJoinKeywordsGrammar'
pub static NATURAL_JOIN_KEYWORDS_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NaturalKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NATURAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "JoinTypeKeywordsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FULL".to_string(), "INNER".to_string(), "LEFT".to_string(), "RIGHT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NATURAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='NaturalKeywordSegment'
pub static NATURAL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NATURAL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NcharKeywordSegment'
pub static NCHAR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NCHAR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NclobKeywordSegment'
pub static NCLOB_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NCLOB",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NegativeSegment'
pub static NEGATIVE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "-",
    token_type: "sign_indicator",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='NestedJoinGrammar'
pub static NESTED_JOIN_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Nothing())
);

// name='NeverKeywordSegment'
pub static NEVER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NEVER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NewKeywordSegment'
pub static NEW_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NEW",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NewlineSegment'
pub static NEWLINE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Token{
    token_type: "newline",
//    token_type: "NewlineSegment",
})
);

// name='NextKeywordSegment'
pub static NEXT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NEXT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NiceKeywordSegment'
pub static NICE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NICE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Nls_date_formatKeywordSegment'
pub static NLS_DATE_FORMAT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NLS_DATE_FORMAT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Nls_date_languageKeywordSegment'
pub static NLS_DATE_LANGUAGE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NLS_DATE_LANGUAGE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Nls_first_day_of_weekKeywordSegment'
pub static NLS_FIRST_DAY_OF_WEEK_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NLS_FIRST_DAY_OF_WEEK",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Nls_numeric_charactersKeywordSegment'
pub static NLS_NUMERIC_CHARACTERS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NLS_NUMERIC_CHARACTERS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Nls_timestamp_formatKeywordSegment'
pub static NLS_TIMESTAMP_FORMAT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NLS_TIMESTAMP_FORMAT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NoKeywordSegment'
pub static NO_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NO",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NocycleKeywordSegment'
pub static NOCYCLE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NOCYCLE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NologgingKeywordSegment'
pub static NOLOGGING_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NOLOGGING",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NonSetSelectableGrammar'
pub static NON_SET_SELECTABLE_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ValuesClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UnorderedSelectStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SELECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SelectStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SELECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithCompoundStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NonSetSelectableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "SELECT".to_string(), "VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BracketedSetExpressionGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "SELECT".to_string(), "VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='NonStandardJoinTypeKeywordsGrammar'
pub static NON_STANDARD_JOIN_TYPE_KEYWORDS_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Nothing())
);

// name='NonWithNonSelectableGrammar'
pub static NON_WITH_NON_SELECTABLE_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "UpdateStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UPDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "InsertStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INSERT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DeleteStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DELETE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MergeStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MERGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DELETE".to_string(), "INSERT".to_string(), "MERGE".to_string(), "UPDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='NonWithSelectableGrammar'
pub static NON_WITH_SELECTABLE_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "SELECT".to_string(), "VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SelectStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SELECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SelectStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SELECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "SELECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NonSetSelectableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "SELECT".to_string(), "VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "SELECT".to_string(), "VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='NoneKeywordSegment'
pub static NONE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NONE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NormalizedGrammar'
pub static NORMALIZED_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Nothing())
);

// name='NormalizedKeywordSegment'
pub static NORMALIZED_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NORMALIZED",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NotEnforcedGrammar'
pub static NOT_ENFORCED_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Nothing())
);

// name='NotEqualToSegment'
pub static NOT_EQUAL_TO_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// NotEqualToSegment
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RawNotSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["!".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RawEqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: false,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["!".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RawLessThanSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["<".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RawGreaterThanSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([">".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: false,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["<".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["!".to_string(), "<".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='NotKeywordSegment'
pub static NOT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NOT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NotNullGrammar'
pub static NOT_NULL_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Nothing())
);

// name='NotOperatorGrammar'
pub static NOT_OPERATOR_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NOT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NoticeKeywordSegment'
pub static NOTICE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NOTICE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NowKeywordSegment'
pub static NOW_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NOW",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NprocKeywordSegment'
pub static NPROC_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NPROC",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NullKeywordSegment'
pub static NULL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NULL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NullLiteralSegment'
pub static NULL_LITERAL_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NULL",
    token_type: "null_literal",
    raw_class: "LiteralKeywordSegment",
    optional: false,
})
);

// name='NullifKeywordSegment'
pub static NULLIF_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NULLIF",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NullifzeroKeywordSegment'
pub static NULLIFZERO_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NULLIFZERO",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NullsKeywordSegment'
pub static NULLS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NULLS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NumberKeywordSegment'
pub static NUMBER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NUMBER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NumericKeywordSegment'
pub static NUMERIC_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NUMERIC",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NumericLiteralSegment'
pub static NUMERIC_LITERAL_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::TypedParser {
    template: "numeric_literal",
    token_type: "numeric_literal",
    raw_class: "LiteralSegment",
    optional: false,
})
);

// name='NumtodsintervalKeywordSegment'
pub static NUMTODSINTERVAL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NUMTODSINTERVAL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NumtoymintervalKeywordSegment'
pub static NUMTOYMINTERVAL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NUMTOYMINTERVAL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Nvarchar2KeywordSegment'
pub static NVARCHAR2_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NVARCHAR2",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NvarcharKeywordSegment'
pub static NVARCHAR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NVARCHAR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Nvl2KeywordSegment'
pub static NVL2_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NVL2",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NvlKeywordSegment'
pub static NVL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NVL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ObjectKeywordSegment'
pub static OBJECT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OBJECT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ObjectLiteralElementSegment'
pub static OBJECT_LITERAL_ELEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ObjectLiteralElementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColonSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([":".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BaseExpressionElementGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["single_quote".to_string()]),
        }),
})
);

// name='ObjectLiteralSegment'
pub static OBJECT_LITERAL_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ObjectLiteralSegment
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ObjectLiteralElementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["single_quote".to_string()]),
        }),
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: true,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["single_quote".to_string()]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "{",
    token_type: "start_curly_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: "}",
    token_type: "end_curly_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["{".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ObjectPrivilegesSegment'
pub static OBJECT_PRIVILEGES_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ObjectPrivilegesSegment
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SelectKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SELECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "InsertKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INSERT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UpdateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UPDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DeleteKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DELETE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ReferencesKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REFERENCES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExecuteKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXECUTE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ImportKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IMPORT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExportKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXPORT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string(), "DELETE".to_string(), "EXECUTE".to_string(), "EXPORT".to_string(), "IMPORT".to_string(), "INSERT".to_string(), "REFERENCES".to_string(), "SELECT".to_string(), "UPDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ObjectReferenceDelimiterGrammar'
pub static OBJECT_REFERENCE_DELIMITER_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DotSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DotSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DotSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ObjectReferenceSegment'
pub static OBJECT_REFERENCE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ObjectReferenceSegment
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "ObjectReferenceDelimiterGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "ObjectReferenceTerminatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    reset_terminators: false,
    allow_gaps: false,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='ObjectReferenceTerminatorGrammar'
pub static OBJECT_REFERENCE_TERMINATOR_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UsingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CastOperatorSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["::".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StartSquareBracketSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["[".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StartBracketSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BinaryOperatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["!".to_string(), "%".to_string(), "&".to_string(), "*".to_string(), "+".to_string(), "-".to_string(), "/".to_string(), "<".to_string(), "=".to_string(), ">".to_string(), "AND".to_string(), "IS".to_string(), "OR".to_string(), "^".to_string(), "|".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["like_operator".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColonSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([":".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DelimiterGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([";".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "JoinLikeClauseGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Token{
    token_type: "bracketed",
//    token_type: "BracketedSegment",
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='ObjectsKeywordSegment'
pub static OBJECTS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OBJECTS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Octet_lengthKeywordSegment'
pub static OCTET_LENGTH_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OCTET_LENGTH",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OctetsKeywordSegment'
pub static OCTETS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OCTETS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OfKeywordSegment'
pub static OF_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OF",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OffKeywordSegment'
pub static OFF_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OFF",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OffsetClauseSegment'
pub static OFFSET_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// OffsetClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OffsetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OFFSET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: Some(Box::new(
Arc::new(Grammar::Ref {
    name: "RowKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    )),
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RowKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RowsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROWS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROW".to_string(), "ROWS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OFFSET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='OffsetKeywordSegment'
pub static OFFSET_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OFFSET",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OldKeywordSegment'
pub static OLD_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OLD",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OnKeywordSegment'
pub static ON_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ON",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OnlyKeywordSegment'
pub static ONLY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ONLY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OpenKeywordSegment'
pub static OPEN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OPEN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OpenSchemaSegment'
pub static OPEN_SCHEMA_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// OpenSchemaSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OpenKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OPEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OPEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='OpenidKeywordSegment'
pub static OPENID_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OPENID",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OptimizeKeywordSegment'
pub static OPTIMIZE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OPTIMIZE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OptimizerKeywordSegment'
pub static OPTIMIZER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OPTIMIZER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OptionKeywordSegment'
pub static OPTION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OPTION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OptionsKeywordSegment'
pub static OPTIONS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OPTIONS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OrKeywordSegment'
pub static OR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OrOperatorGrammar'
pub static OR_OPERATOR_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OR",
    token_type: "binary_operator",
    raw_class: "BinaryOperatorSegment",
    optional: false,
})
);

// name='OrReplaceGrammar'
pub static OR_REPLACE_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OrKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ReplaceKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REPLACE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='OraKeywordSegment'
pub static ORA_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ORA",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OrderByClauseSegment'
pub static ORDER_BY_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// OrderByClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OrderKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AscKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ASC".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DescKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DESC".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ASC".to_string(), "DESC".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NullsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NULLS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FirstKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FIRST".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LastKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LAST".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FIRST".to_string(), "LAST".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NULLS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WithFillSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "LimitClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LIMIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FrameClauseUnitGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RANGE".to_string(), "ROWS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("dedent"))
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='OrderByClauseTerminators'
pub static ORDER_BY_CLAUSE_TERMINATORS: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LimitClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LIMIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "HavingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["HAVING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QualifyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["QUALIFY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WindowKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WINDOW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FrameClauseUnitGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RANGE".to_string(), "ROWS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SeparatorKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SEPARATOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FetchKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FETCH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FETCH".to_string(), "HAVING".to_string(), "LIMIT".to_string(), "QUALIFY".to_string(), "RANGE".to_string(), "ROWS".to_string(), "SEPARATOR".to_string(), "WINDOW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='OrderKeywordSegment'
pub static ORDER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ORDER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OrderNoOrderGrammar'
pub static ORDER_NO_ORDER_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OrderKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NoorderKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='OrderingKeywordSegment'
pub static ORDERING_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ORDERING",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OrdinalityKeywordSegment'
pub static ORDINALITY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ORDINALITY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OthersKeywordSegment'
pub static OTHERS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OTHERS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OutKeywordSegment'
pub static OUT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OUT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OuterKeywordSegment'
pub static OUTER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OUTER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OutputKeywordSegment'
pub static OUTPUT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OUTPUT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OverClauseSegment'
pub static OVER_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// OverClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::Ref {
    name: "IgnoreRespectNullsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IGNORE".to_string(), "RESPECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OverKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OVER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WindowSpecificationSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Greedy,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("dedent"))
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='OverKeywordSegment'
pub static OVER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OVER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OverflowKeywordSegment'
pub static OVERFLOW_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OVERFLOW",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OverlapsClauseSegment'
pub static OVERLAPS_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// OverlapsClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OverlapsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OVERLAPS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DateTimeLiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATE".to_string(), "TIMESTAMP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DateTimeLiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATE".to_string(), "TIMESTAMP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OVERLAPS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='OverlapsKeywordSegment'
pub static OVERLAPS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OVERLAPS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OverlayKeywordSegment'
pub static OVERLAY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OVERLAY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OverridingKeywordSegment'
pub static OVERRIDING_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OVERRIDING",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OwnerKeywordSegment'
pub static OWNER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OWNER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PadKeywordSegment'
pub static PAD_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PAD",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PaddingKeywordSegment'
pub static PADDING_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PADDING",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Parallel_enableKeywordSegment'
pub static PARALLEL_ENABLE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PARALLEL_ENABLE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ParameterKeywordSegment'
pub static PARAMETER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PARAMETER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ParameterNameSegment'
pub static PARAMETER_NAME_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::RegexParser {
    template: regex::RegexBuilder::new(r#"\"?[A-Z][A-Z0-9_]*\"?"#)
         .case_insensitive(true)
         .build()
         .unwrap(),
    token_type: "parameter",
    raw_class: "CodeSegment",
    optional: false,
    anti_template: None,
})
);

// name='ParameterSegment'
pub static PARAMETER_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "?",
    token_type: "parameter",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='Parameter_specific_catalogKeywordSegment'
pub static PARAMETER_SPECIFIC_CATALOG_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PARAMETER_SPECIFIC_CATALOG",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Parameter_specific_nameKeywordSegment'
pub static PARAMETER_SPECIFIC_NAME_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PARAMETER_SPECIFIC_NAME",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Parameter_specific_schemaKeywordSegment'
pub static PARAMETER_SPECIFIC_SCHEMA_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PARAMETER_SPECIFIC_SCHEMA",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PartialKeywordSegment'
pub static PARTIAL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PARTIAL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PartitionClauseSegment'
pub static PARTITION_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// PartitionClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PartitionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PARTITION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("dedent"))
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PARTITION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='PartitionKeywordSegment'
pub static PARTITION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PARTITION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PascalKeywordSegment'
pub static PASCAL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PASCAL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PasswordKeywordSegment'
pub static PASSWORD_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PASSWORD",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PasswordLiteralSegment'
pub static PASSWORD_LITERAL_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::TypedParser {
    template: "double_quote",
    token_type: "password_literal",
    raw_class: "CodeSegment",
    optional: false,
})
);

// name='Password_expiry_policyKeywordSegment'
pub static PASSWORD_EXPIRY_POLICY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PASSWORD_EXPIRY_POLICY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Password_security_policyKeywordSegment'
pub static PASSWORD_SECURITY_POLICY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PASSWORD_SECURITY_POLICY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PathKeywordSegment'
pub static PATH_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PATH",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PathSegment'
pub static PATH_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// PathSegment
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SlashSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["/".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::TypedParser {
    template: "word",
    token_type: "path_segment",
    raw_class: "WordSegment",
    optional: false,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "SlashSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["/".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: false,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["word".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["/".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["single_quote".to_string()]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["/".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["single_quote".to_string()]),
        }),
})
);

// name='PatternMatchingGrammar'
pub static PATTERN_MATCHING_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Nothing())
);

// name='Percentile_contKeywordSegment'
pub static PERCENTILE_CONT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PERCENTILE_CONT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Percentile_discKeywordSegment'
pub static PERCENTILE_DISC_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PERCENTILE_DISC",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PermissionKeywordSegment'
pub static PERMISSION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PERMISSION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PiKeywordSegment'
pub static PI_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PI",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PipeSegment'
pub static PIPE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "|",
    token_type: "pipe",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='PlacingKeywordSegment'
pub static PLACING_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PLACING",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PliKeywordSegment'
pub static PLI_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PLI",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PlusKeywordSegment'
pub static PLUS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PLUS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PlusSegment'
pub static PLUS_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "+",
    token_type: "binary_operator",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='PositionKeywordSegment'
pub static POSITION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "POSITION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PositiveSegment'
pub static POSITIVE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "+",
    token_type: "sign_indicator",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='Posix_timeKeywordSegment'
pub static POSIX_TIME_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "POSIX_TIME",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PostFunctionGrammar'
pub static POST_FUNCTION_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "EmitsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EMITS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IgnoreKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IGNORE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RespectKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESPECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IGNORE".to_string(), "RESPECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NullsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NULLS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IGNORE".to_string(), "RESPECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OverClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='PostTableExpressionGrammar'
pub static POST_TABLE_EXPRESSION_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Nothing())
);

// name='PowerKeywordSegment'
pub static POWER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "POWER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PreTableFunctionKeywordsGrammar'
pub static PRE_TABLE_FUNCTION_KEYWORDS_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Ref {
    name: "TableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='PrecedenceKeywordSegment'
pub static PRECEDENCE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PRECEDENCE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PrecedingKeywordSegment'
pub static PRECEDING_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PRECEDING",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PrecisionKeywordSegment'
pub static PRECISION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PRECISION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PreferringClauseSegment'
pub static PREFERRING_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// PreferringClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PreferringKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PREFERRING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PreferringPreferenceTermSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PreferringPreferenceTermSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "PartitionClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PARTITION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PREFERRING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='PreferringKeywordSegment'
pub static PREFERRING_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PREFERRING",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PreferringPlusPriorTermSegment'
pub static PREFERRING_PLUS_PRIOR_TERM_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// PreferringPlusPriorTermSegment
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PlusKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PLUS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PriorKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PRIOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PRIOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PLUS".to_string(), "PRIOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PreferringPreferenceTermSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PLUS".to_string(), "PRIOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PLUS".to_string(), "PRIOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "InverseKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INVERSE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PreferringPreferenceTermSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INVERSE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INVERSE".to_string(), "PLUS".to_string(), "PRIOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='PreferringPreferenceTermSegment'
pub static PREFERRING_PREFERENCE_TERM_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// PreferringPreferenceTermSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "HighKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["HIGH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LowKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LOW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["HIGH".to_string(), "LOW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "BareFunctionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONNECT_BY_ISCYCLE".to_string(), "CONNECT_BY_ISLEAF".to_string(), "CONNECT_BY_ROOT".to_string(), "CURDATE".to_string(), "CURRENT_DATE".to_string(), "CURRENT_SCHEMA".to_string(), "CURRENT_SESSION".to_string(), "CURRENT_STATEMENT".to_string(), "CURRENT_TIMESTAMP".to_string(), "CURRENT_USER".to_string(), "DBTIMEZONE".to_string(), "LEVEL".to_string(), "LOCALTIMESTAMP".to_string(), "NOW".to_string(), "ROWID".to_string(), "ROWNUM".to_string(), "SESSIONTIMEZONE".to_string(), "SYSDATE".to_string(), "SYSTIMESTAMP".to_string(), "USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "LocalAliasSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LOCAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["HIGH".to_string(), "LOW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "BareFunctionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONNECT_BY_ISCYCLE".to_string(), "CONNECT_BY_ISLEAF".to_string(), "CONNECT_BY_ROOT".to_string(), "CURDATE".to_string(), "CURRENT_DATE".to_string(), "CURRENT_SCHEMA".to_string(), "CURRENT_SESSION".to_string(), "CURRENT_STATEMENT".to_string(), "CURRENT_TIMESTAMP".to_string(), "CURRENT_USER".to_string(), "DBTIMEZONE".to_string(), "LEVEL".to_string(), "LOCALTIMESTAMP".to_string(), "NOW".to_string(), "ROWID".to_string(), "ROWNUM".to_string(), "SESSIONTIMEZONE".to_string(), "SYSDATE".to_string(), "SYSTIMESTAMP".to_string(), "USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "LocalAliasSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LOCAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "PreferringPlusPriorTermSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INVERSE".to_string(), "PLUS".to_string(), "PRIOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='PreloadKeywordSegment'
pub static PRELOAD_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PRELOAD",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PreloadSegment'
pub static PRELOAD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// PreloadSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PreloadKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PRELOAD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "BracketedColumnReferenceListGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TablesKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SchemaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SchemasKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMAS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SchemaReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMAS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DatabaseKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATABASE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATABASE".to_string(), "SCHEMA".to_string(), "SCHEMAS".to_string(), "TABLE".to_string(), "TABLES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PRELOAD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='PrepareKeywordSegment'
pub static PREPARE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PREPARE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PreserveKeywordSegment'
pub static PRESERVE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PRESERVE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PrimaryKeyGrammar'
pub static PRIMARY_KEY_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PrimaryKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PRIMARY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "KeyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["KEY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PRIMARY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='PrimaryKeywordSegment'
pub static PRIMARY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PRIMARY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PrincipalKeywordSegment'
pub static PRINCIPAL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PRINCIPAL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PriorKeywordSegment'
pub static PRIOR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PRIOR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PrivilegeKeywordSegment'
pub static PRIVILEGE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PRIVILEGE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PrivilegesKeywordSegment'
pub static PRIVILEGES_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PRIVILEGES",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ProcedureKeywordSegment'
pub static PROCEDURE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PROCEDURE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ProfileKeywordSegment'
pub static PROFILE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PROFILE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PythonKeywordSegment'
pub static PYTHON_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PYTHON",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='QualifiedNumericLiteralSegment'
pub static QUALIFIED_NUMERIC_LITERAL_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// QualifiedNumericLiteralSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SignedSegmentGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["+".to_string(), "-".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["+".to_string(), "-".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='QualifyClauseSegment'
pub static QUALIFY_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// QualifyClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "QualifyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["QUALIFY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("dedent"))
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["QUALIFY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='QualifyKeywordSegment'
pub static QUALIFY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "QUALIFY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='QueryKeywordSegment'
pub static QUERY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "QUERY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Query_cacheKeywordSegment'
pub static QUERY_CACHE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "QUERY_CACHE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Query_timeoutKeywordSegment'
pub static QUERY_TIMEOUT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "QUERY_TIMEOUT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='QuietKeywordSegment'
pub static QUIET_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "QUIET",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='QuotedIdentifierSegment'
pub static QUOTED_IDENTIFIER_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::TypedParser {
    template: "double_quote",
    token_type: "quoted_identifier",
    raw_class: "IdentifierSegment",
    optional: false,
})
);

// name='QuotedLiteralSegment'
pub static QUOTED_LITERAL_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::TypedParser {
    template: "single_quote",
    token_type: "quoted_literal",
    raw_class: "LiteralSegment",
    optional: false,
})
);

// name='RKeywordSegment'
pub static R_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "R",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RadiansKeywordSegment'
pub static RADIANS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "RADIANS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RandKeywordSegment'
pub static RAND_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "RAND",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RandomKeywordSegment'
pub static RANDOM_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "RANDOM",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RangeKeywordSegment'
pub static RANGE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "RANGE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RangeOperator'
pub static RANGE_OPERATOR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::TypedParser {
    template: "range_operator",
    token_type: "range_operator",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='RankKeywordSegment'
pub static RANK_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "RANK",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Ratio_to_reportKeywordSegment'
pub static RATIO_TO_REPORT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "RATIO_TO_REPORT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RawEqualsSegment'
pub static RAW_EQUALS_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "=",
    token_type: "raw_comparison_operator",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='RawGreaterThanSegment'
pub static RAW_GREATER_THAN_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: ">",
    token_type: "raw_comparison_operator",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='RawLessThanSegment'
pub static RAW_LESS_THAN_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "<",
    token_type: "raw_comparison_operator",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='RawNotSegment'
pub static RAW_NOT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "!",
    token_type: "raw_comparison_operator",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='RawSegment'
pub static RAW_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Token{
    token_type: "raw",
//    token_type: "RawSegment",
})
);

// name='Raw_size_limitKeywordSegment'
pub static RAW_SIZE_LIMIT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "RAW_SIZE_LIMIT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ReadKeywordSegment'
pub static READ_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "READ",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ReadsKeywordSegment'
pub static READS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "READS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RealKeywordSegment'
pub static REAL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "REAL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RecompressKeywordSegment'
pub static RECOMPRESS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "RECOMPRESS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RecompressReorganizeSegment'
pub static RECOMPRESS_REORGANIZE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// RecompressReorganizeSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RecompressKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RECOMPRESS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ReorganizeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REORGANIZE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RECOMPRESS".to_string(), "REORGANIZE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "BracketedColumnReferenceListGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TablesKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SchemaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SchemasKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMAS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SchemaReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMAS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DatabaseKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATABASE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATABASE".to_string(), "SCHEMA".to_string(), "SCHEMAS".to_string(), "TABLE".to_string(), "TABLES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EnforceKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ENFORCE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RECOMPRESS".to_string(), "REORGANIZE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='RecordKeywordSegment'
pub static RECORD_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "RECORD",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RecoveryKeywordSegment'
pub static RECOVERY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "RECOVERY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RecursiveKeywordSegment'
pub static RECURSIVE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "RECURSIVE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RefKeywordSegment'
pub static REF_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "REF",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ReferenceDefinitionGrammar'
pub static REFERENCE_DEFINITION_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ReferencesKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REFERENCES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "BracketedColumnReferenceListGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ReferenceMatchGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MATCH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::AnySetOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DeleteKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DELETE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ReferentialActionGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string(), "NO".to_string(), "RESTRICT".to_string(), "SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UpdateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UPDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ReferentialActionGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string(), "NO".to_string(), "RESTRICT".to_string(), "SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 0,
    max_times: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REFERENCES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ReferenceMatchGrammar'
pub static REFERENCE_MATCH_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "MatchKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MATCH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FullKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PartialKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PARTIAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SimpleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SIMPLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FULL".to_string(), "PARTIAL".to_string(), "SIMPLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MATCH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ReferencesKeywordSegment'
pub static REFERENCES_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "REFERENCES",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ReferencingClauseSegment'
pub static REFERENCING_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ReferencingClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ReferencingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REFERENCING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "BracketedColumnReferenceListGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REFERENCING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ReferencingKeywordSegment'
pub static REFERENCING_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "REFERENCING",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ReferentialActionGrammar'
pub static REFERENTIAL_ACTION_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RestrictKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CascadeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NullKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NoKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ActionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ACTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DefaultKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string(), "NO".to_string(), "RESTRICT".to_string(), "SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='RefreshKeywordSegment'
pub static REFRESH_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "REFRESH",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Regexp_instrKeywordSegment'
pub static REGEXP_INSTR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "REGEXP_INSTR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Regexp_likeKeywordSegment'
pub static REGEXP_LIKE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "REGEXP_LIKE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Regexp_replaceKeywordSegment'
pub static REGEXP_REPLACE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "REGEXP_REPLACE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Regexp_substrKeywordSegment'
pub static REGEXP_SUBSTR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "REGEXP_SUBSTR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Regr_avgxKeywordSegment'
pub static REGR_AVGX_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "REGR_AVGX",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Regr_avgyKeywordSegment'
pub static REGR_AVGY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "REGR_AVGY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Regr_countKeywordSegment'
pub static REGR_COUNT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "REGR_COUNT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Regr_interceptKeywordSegment'
pub static REGR_INTERCEPT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "REGR_INTERCEPT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Regr_r2KeywordSegment'
pub static REGR_R2_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "REGR_R2",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Regr_slopeKeywordSegment'
pub static REGR_SLOPE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "REGR_SLOPE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Regr_sxxKeywordSegment'
pub static REGR_SXX_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "REGR_SXX",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Regr_sxyKeywordSegment'
pub static REGR_SXY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "REGR_SXY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Regr_syyKeywordSegment'
pub static REGR_SYY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "REGR_SYY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RejectClauseSegment'
pub static REJECT_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// RejectClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RejectKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REJECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LimitKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LIMIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UnlimitedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UNLIMITED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UNLIMITED".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ErrorsKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ERRORS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REJECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='RejectKeywordSegment'
pub static REJECT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "REJECT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RelativeKeywordSegment'
pub static RELATIVE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "RELATIVE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ReleaseKeywordSegment'
pub static RELEASE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "RELEASE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RenameKeywordSegment'
pub static RENAME_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "RENAME",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RenameStatementSegment'
pub static RENAME_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// RenameStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RenameKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SchemaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ViewKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VIEW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FUNCTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ScriptKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCRIPT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UserKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RoleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConnectionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONNECTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ConsumerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSUMER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "GroupKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSUMER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONNECTION".to_string(), "CONSUMER".to_string(), "FUNCTION".to_string(), "ROLE".to_string(), "SCHEMA".to_string(), "SCRIPT".to_string(), "TABLE".to_string(), "USER".to_string(), "VIEW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ReorganizeKeywordSegment'
pub static REORGANIZE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "REORGANIZE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RepeatKeywordSegment'
pub static REPEAT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "REPEAT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RepeatableKeywordSegment'
pub static REPEATABLE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "REPEATABLE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ReplaceKeywordSegment'
pub static REPLACE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "REPLACE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ResetKeywordSegment'
pub static RESET_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "RESET",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RespectKeywordSegment'
pub static RESPECT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "RESPECT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RestoreKeywordSegment'
pub static RESTORE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "RESTORE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RestrictKeywordSegment'
pub static RESTRICT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "RESTRICT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ResultKeywordSegment'
pub static RESULT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "RESULT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ReturnKeywordSegment'
pub static RETURN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "RETURN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Returned_lengthKeywordSegment'
pub static RETURNED_LENGTH_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "RETURNED_LENGTH",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Returned_octet_lengthKeywordSegment'
pub static RETURNED_OCTET_LENGTH_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "RETURNED_OCTET_LENGTH",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ReturningKeywordSegment'
pub static RETURNING_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "RETURNING",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ReturnsKeywordSegment'
pub static RETURNS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "RETURNS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ReverseKeywordSegment'
pub static REVERSE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "REVERSE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RevokeKeywordSegment'
pub static REVOKE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "REVOKE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RightKeywordSegment'
pub static RIGHT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "RIGHT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RoleKeywordSegment'
pub static ROLE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ROLE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RoleReferenceSegment'
pub static ROLE_REFERENCE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// RoleReferenceSegment
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
);

// name='RolesKeywordSegment'
pub static ROLES_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ROLES",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RollbackKeywordSegment'
pub static ROLLBACK_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ROLLBACK",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RollupFunctionNameSegment'
pub static ROLLUP_FUNCTION_NAME_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// RollupFunctionNameSegment
Arc::new(Grammar::StringParser {
    template: "ROLLUP",
    token_type: "function_name_identifier",
    raw_class: "CodeSegment",
    optional: false,
})
);

// name='RollupKeywordSegment'
pub static ROLLUP_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ROLLUP",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RoundKeywordSegment'
pub static ROUND_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ROUND",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RoutineKeywordSegment'
pub static ROUTINE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ROUTINE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RowKeywordSegment'
pub static ROW_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ROW",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Row_numberKeywordSegment'
pub static ROW_NUMBER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ROW_NUMBER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RowcountKeywordSegment'
pub static ROWCOUNT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ROWCOUNT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RowidKeywordSegment'
pub static ROWID_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ROWID",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RowsKeywordSegment'
pub static ROWS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ROWS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RowtypeKeywordSegment'
pub static ROWTYPE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ROWTYPE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RpadKeywordSegment'
pub static RPAD_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "RPAD",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RtrimKeywordSegment'
pub static RTRIM_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "RTRIM",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SamplingExpressionSegment'
pub static SAMPLING_EXPRESSION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// SamplingExpressionSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TablesampleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLESAMPLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "BernoulliKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BERNOULLI".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SystemKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SYSTEM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BERNOULLI".to_string(), "SYSTEM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RepeatableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REPEATABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REPEATABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REPEATABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLESAMPLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='SavepointKeywordSegment'
pub static SAVEPOINT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SAVEPOINT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ScalarKeywordSegment'
pub static SCALAR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SCALAR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SchemaKeywordSegment'
pub static SCHEMA_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SCHEMA",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SchemaReferenceSegment'
pub static SCHEMA_REFERENCE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// SchemaReferenceSegment
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "ObjectReferenceDelimiterGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "ObjectReferenceTerminatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    reset_terminators: false,
    allow_gaps: false,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='SchemasKeywordSegment'
pub static SCHEMAS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SCHEMAS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SchemeKeywordSegment'
pub static SCHEME_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SCHEME",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ScopeKeywordSegment'
pub static SCOPE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SCOPE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Scope_userKeywordSegment'
pub static SCOPE_USER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SCOPE_USER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ScriptContentSegment'
pub static SCRIPT_CONTENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ScriptContentSegment
Arc::new(Grammar::Anything)
);

// name='ScriptKeywordSegment'
pub static SCRIPT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SCRIPT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ScriptReferenceSegment'
pub static SCRIPT_REFERENCE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ScriptReferenceSegment
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "ObjectReferenceDelimiterGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "ObjectReferenceTerminatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    reset_terminators: false,
    allow_gaps: false,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='Script_languagesKeywordSegment'
pub static SCRIPT_LANGUAGES_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SCRIPT_LANGUAGES",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Script_output_addressKeywordSegment'
pub static SCRIPT_OUTPUT_ADDRESS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SCRIPT_OUTPUT_ADDRESS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ScrollKeywordSegment'
pub static SCROLL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SCROLL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SearchKeywordSegment'
pub static SEARCH_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SEARCH",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SecondKeywordSegment'
pub static SECOND_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SECOND",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Seconds_betweenKeywordSegment'
pub static SECONDS_BETWEEN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SECONDS_BETWEEN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SectionKeywordSegment'
pub static SECTION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SECTION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SecureKeywordSegment'
pub static SECURE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SECURE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SecurityKeywordSegment'
pub static SECURITY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SECURITY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SelectClauseElementSegment'
pub static SELECT_CLAUSE_ELEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// SelectClauseElementSegment
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WildcardExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "BaseExpressionElementGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AliasExpressionSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='SelectClauseModifierSegment'
pub static SELECT_CLAUSE_MODIFIER_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// SelectClauseModifierSegment
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DistinctKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DISTINCT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AllKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string(), "DISTINCT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='SelectClauseSegment'
pub static SELECT_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// SelectClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SelectKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SELECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SelectClauseModifierSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string(), "DISTINCT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SelectClauseElementSegment",
    optional: false,
    allow_gaps: true,
    exclude: Some(Box::new(
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "InvalidKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INVALID".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ForeignKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOREIGN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PrimaryKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PRIMARY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOREIGN".to_string(), "PRIMARY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INVALID".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IntoKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INTO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INTO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INTO".to_string(), "INVALID".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    )),
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: true,
    optional: true,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "WithInvalidForeignKeySegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INVALID".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WithInvalidUniquePKSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INVALID".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IntoTableSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INTO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("dedent"))
,
    ],
    optional: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "SelectClauseTerminatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COMMENT".to_string(), "EXCEPT".to_string(), "FROM".to_string(), "INTERSECT".to_string(), "LIMIT".to_string(), "MINUS".to_string(), "ORDER".to_string(), "UNION".to_string(), "WHERE".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::GreedyOnceStarted,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SELECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='SelectClauseTerminatorGrammar'
pub static SELECT_CLAUSE_TERMINATOR_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FromKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WhereKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHERE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OrderKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LimitKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LIMIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SetOperatorSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCEPT".to_string(), "INTERSECT".to_string(), "MINUS".to_string(), "UNION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WithDataClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CommentClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COMMENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COMMENT".to_string(), "EXCEPT".to_string(), "FROM".to_string(), "INTERSECT".to_string(), "LIMIT".to_string(), "MINUS".to_string(), "ORDER".to_string(), "UNION".to_string(), "WHERE".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='SelectKeywordSegment'
pub static SELECT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SELECT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SelectStatementSegment'
pub static SELECT_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// SelectStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SelectClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SELECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FromClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ReferencingClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REFERENCING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WhereClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHERE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConnectByClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONNECT".to_string(), "START".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PreferringClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PREFERRING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "GroupByClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "HavingClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["HAVING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QualifyClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["QUALIFY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OrderByClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LimitClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LIMIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "SetOperatorSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCEPT".to_string(), "INTERSECT".to_string(), "MINUS".to_string(), "UNION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WithDataClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CommentClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COMMENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::GreedyOnceStarted,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SELECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='SelectableGrammar'
pub static SELECTABLE_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithCompoundStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WithCompoundStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithCompoundNonSelectStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WithCompoundNonSelectStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NonWithSelectableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "SELECT".to_string(), "VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SelectableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "SELECT".to_string(), "VALUES".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "SELECT".to_string(), "VALUES".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='SelectiveKeywordSegment'
pub static SELECTIVE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SELECTIVE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SelfKeywordSegment'
pub static SELF_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SELF",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SemicolonSegment'
pub static SEMICOLON_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: ";",
    token_type: "statement_terminator",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='SensitiveKeywordSegment'
pub static SENSITIVE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SENSITIVE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SeparatorKeywordSegment'
pub static SEPARATOR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SEPARATOR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SequenceKeywordSegment'
pub static SEQUENCE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SEQUENCE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SequenceMaxValueGrammar'
pub static SEQUENCE_MAX_VALUE_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "MaxvalueKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NoKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MaxvalueKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='SequenceMinValueGrammar'
pub static SEQUENCE_MIN_VALUE_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "MinvalueKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NoKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MinvalueKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='SequenceReferenceSegment'
pub static SEQUENCE_REFERENCE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// SequenceReferenceSegment
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "ObjectReferenceDelimiterGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "ObjectReferenceTerminatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    reset_terminators: false,
    allow_gaps: false,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='SerializableKeywordSegment'
pub static SERIALIZABLE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SERIALIZABLE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SessionKeywordSegment'
pub static SESSION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SESSION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SessionParameterSegment'
pub static SESSION_PARAMETER_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::MultiStringParser {
    templates: vec!["CONSTRAINT_STATE_DEFAULT", "DEFAULT_LIKE_ESCAPE_CHARACTER", "HASHTYPE_FORMAT", "IDLE_TIMEOUT", "NICE", "NLS_DATE_FORMAT", "NLS_DATE_LANGUAGE", "NLS_FIRST_DAY_OF_WEEK", "NLS_NUMERIC_CHARACTERS", "NLS_TIMESTAMP_FORMAT", "PROFILE", "QUERY_CACHE", "QUERY_TIMEOUT", "SCRIPT_LANGUAGES", "SCRIPT_OUTPUT_ADDRESS", "SESSION_TEMP_DB_RAM_LIMIT", "SNAPSHOT_MODE", "SQL_PREPROCESSOR_SCRIPT", "ST_MAX_DECIMAL_DIGITS", "TIMESTAMP_ARITHMETIC_BEHAVIOR", "TIME_ZONE", "TIME_ZONE_BEHAVIOR"],
    token_type: "session_parameter",
    raw_class: "CodeSegment",
    optional: false,
})
);

// name='Session_parameterKeywordSegment'
pub static SESSION_PARAMETER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SESSION_PARAMETER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Session_temp_db_ram_limitKeywordSegment'
pub static SESSION_TEMP_DB_RAM_LIMIT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SESSION_TEMP_DB_RAM_LIMIT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Session_userKeywordSegment'
pub static SESSION_USER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SESSION_USER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SessiontimezoneKeywordSegment'
pub static SESSIONTIMEZONE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SESSIONTIMEZONE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SetClauseListSegment'
pub static SET_CLAUSE_LIST_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// SetClauseListSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "FromKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("dedent"))
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='SetClauseSegment'
pub static SET_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// SetClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "LiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "BareFunctionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONNECT_BY_ISCYCLE".to_string(), "CONNECT_BY_ISLEAF".to_string(), "CONNECT_BY_ROOT".to_string(), "CURDATE".to_string(), "CURRENT_DATE".to_string(), "CURRENT_SCHEMA".to_string(), "CURRENT_SESSION".to_string(), "CURRENT_STATEMENT".to_string(), "CURRENT_TIMESTAMP".to_string(), "CURRENT_USER".to_string(), "DBTIMEZONE".to_string(), "LEVEL".to_string(), "LOCALTIMESTAMP".to_string(), "NOW".to_string(), "ROWID".to_string(), "ROWNUM".to_string(), "SESSIONTIMEZONE".to_string(), "SYSDATE".to_string(), "SYSTIMESTAMP".to_string(), "USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "NullKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DefaultKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='SetExpressionSegment'
pub static SET_EXPRESSION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// SetExpressionSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NonSetSelectableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "SELECT".to_string(), "VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetOperatorSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCEPT".to_string(), "INTERSECT".to_string(), "MINUS".to_string(), "UNION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NonSetSelectableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "SELECT".to_string(), "VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCEPT".to_string(), "INTERSECT".to_string(), "MINUS".to_string(), "UNION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 1,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCEPT".to_string(), "INTERSECT".to_string(), "MINUS".to_string(), "UNION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OrderByClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LimitClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LIMIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NamedWindowSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WINDOW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "SELECT".to_string(), "VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='SetKeywordSegment'
pub static SET_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SET",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SetOperatorSegment'
pub static SET_OPERATOR_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// SetOperatorSegment
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "UnionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UNION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AllKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UNION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IntersectKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INTERSECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "MinusKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MINUS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExceptKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCEPT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCEPT".to_string(), "MINUS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCEPT".to_string(), "INTERSECT".to_string(), "MINUS".to_string(), "UNION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='SetSchemaStatementSegment'
pub static SET_SCHEMA_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// SetSchemaStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfNotExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='SetsKeywordSegment'
pub static SETS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SETS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ShorthandCastSegment'
pub static SHORTHAND_CAST_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ShorthandCastSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "Expression_D_Grammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "CaseExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CastOperatorSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["::".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DatatypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BIGINT".to_string(), "BOOL".to_string(), "BOOLEAN".to_string(), "CHAR".to_string(), "CHARACTER".to_string(), "CLOB".to_string(), "DATE".to_string(), "DEC".to_string(), "DECIMAL".to_string(), "DOUBLE".to_string(), "FLOAT".to_string(), "GEOMETRY".to_string(), "HASHTYPE".to_string(), "INT".to_string(), "INTEGER".to_string(), "INTERVAL".to_string(), "LONG".to_string(), "NCHAR".to_string(), "NUMBER".to_string(), "NUMERIC".to_string(), "NVARCHAR".to_string(), "NVARCHAR2".to_string(), "REAL".to_string(), "SHORTINT".to_string(), "SMALLINT".to_string(), "TIMESTAMP".to_string(), "TINYINT".to_string(), "VARCHAR".to_string(), "VARCHAR2".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TimeZoneGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["::".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 1,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["::".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='ShortintKeywordSegment'
pub static SHORTINT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SHORTINT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ShutKeywordSegment'
pub static SHUT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SHUT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SignKeywordSegment'
pub static SIGN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SIGN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SignedSegmentGrammar'
pub static SIGNED_SEGMENT_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PositiveSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["+".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NegativeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["-".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["+".to_string(), "-".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='SimilarKeywordSegment'
pub static SIMILAR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SIMILAR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SimpleKeywordSegment'
pub static SIMPLE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SIMPLE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SinKeywordSegment'
pub static SIN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SIN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SingleIdentifierGrammar'
pub static SINGLE_IDENTIFIER_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NakedIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "QuotedIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["double_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EscapedIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["escaped_identifier".to_string()]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='SingleIdentifierListSegment'
pub static SINGLE_IDENTIFIER_LIST_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// SingleIdentifierListSegment
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='SingleQuotedIdentifierSegment'
pub static SINGLE_QUOTED_IDENTIFIER_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::TypedParser {
    template: "single_quote",
    token_type: "quoted_identifier",
    raw_class: "IdentifierSegment",
    optional: false,
})
);

// name='SinhKeywordSegment'
pub static SINH_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SINH",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SizeKeywordSegment'
pub static SIZE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SIZE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SizedArrayTypeSegment'
pub static SIZED_ARRAY_TYPE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// SizedArrayTypeSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ArrayTypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ArrayAccessorSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["[".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='SkipKeywordSegment'
pub static SKIP_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SKIP",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SlashSegment'
pub static SLASH_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "/",
    token_type: "slash",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='SliceSegment'
pub static SLICE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: ":",
    token_type: "slice",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='SmallintKeywordSegment'
pub static SMALLINT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SMALLINT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Snapshot_modeKeywordSegment'
pub static SNAPSHOT_MODE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SNAPSHOT_MODE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SomeKeywordSegment'
pub static SOME_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SOME",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SoundexKeywordSegment'
pub static SOUNDEX_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SOUNDEX",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SourceKeywordSegment'
pub static SOURCE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SOURCE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SpaceKeywordSegment'
pub static SPACE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SPACE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SpecificKeywordSegment'
pub static SPECIFIC_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SPECIFIC",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SpecifictypeKeywordSegment'
pub static SPECIFICTYPE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SPECIFICTYPE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SqlKeywordSegment'
pub static SQL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SQL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Sql_bigintKeywordSegment'
pub static SQL_BIGINT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SQL_BIGINT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Sql_bitKeywordSegment'
pub static SQL_BIT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SQL_BIT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Sql_charKeywordSegment'
pub static SQL_CHAR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SQL_CHAR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Sql_dateKeywordSegment'
pub static SQL_DATE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SQL_DATE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Sql_decimalKeywordSegment'
pub static SQL_DECIMAL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SQL_DECIMAL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Sql_doubleKeywordSegment'
pub static SQL_DOUBLE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SQL_DOUBLE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Sql_floatKeywordSegment'
pub static SQL_FLOAT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SQL_FLOAT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Sql_integerKeywordSegment'
pub static SQL_INTEGER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SQL_INTEGER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Sql_longvarcharKeywordSegment'
pub static SQL_LONGVARCHAR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SQL_LONGVARCHAR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Sql_numericKeywordSegment'
pub static SQL_NUMERIC_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SQL_NUMERIC",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Sql_preprocessor_scriptKeywordSegment'
pub static SQL_PREPROCESSOR_SCRIPT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SQL_PREPROCESSOR_SCRIPT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Sql_realKeywordSegment'
pub static SQL_REAL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SQL_REAL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Sql_smallintKeywordSegment'
pub static SQL_SMALLINT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SQL_SMALLINT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Sql_timestampKeywordSegment'
pub static SQL_TIMESTAMP_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SQL_TIMESTAMP",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Sql_tinyintKeywordSegment'
pub static SQL_TINYINT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SQL_TINYINT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Sql_type_dateKeywordSegment'
pub static SQL_TYPE_DATE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SQL_TYPE_DATE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Sql_type_timestampKeywordSegment'
pub static SQL_TYPE_TIMESTAMP_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SQL_TYPE_TIMESTAMP",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Sql_varcharKeywordSegment'
pub static SQL_VARCHAR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SQL_VARCHAR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SqlexceptionKeywordSegment'
pub static SQLEXCEPTION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SQLEXCEPTION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SqlstateKeywordSegment'
pub static SQLSTATE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SQLSTATE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SqlwarningKeywordSegment'
pub static SQLWARNING_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SQLWARNING",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SqrtKeywordSegment'
pub static SQRT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SQRT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='St_areaKeywordSegment'
pub static ST_AREA_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ST_AREA",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='St_boundaryKeywordSegment'
pub static ST_BOUNDARY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ST_BOUNDARY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='St_bufferKeywordSegment'
pub static ST_BUFFER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ST_BUFFER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='St_centroidKeywordSegment'
pub static ST_CENTROID_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ST_CENTROID",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='St_containsKeywordSegment'
pub static ST_CONTAINS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ST_CONTAINS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='St_convexhullKeywordSegment'
pub static ST_CONVEXHULL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ST_CONVEXHULL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='St_crossesKeywordSegment'
pub static ST_CROSSES_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ST_CROSSES",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='St_differenceKeywordSegment'
pub static ST_DIFFERENCE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ST_DIFFERENCE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='St_dimensionKeywordSegment'
pub static ST_DIMENSION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ST_DIMENSION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='St_disjointKeywordSegment'
pub static ST_DISJOINT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ST_DISJOINT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='St_distanceKeywordSegment'
pub static ST_DISTANCE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ST_DISTANCE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='St_endpointKeywordSegment'
pub static ST_ENDPOINT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ST_ENDPOINT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='St_envelopeKeywordSegment'
pub static ST_ENVELOPE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ST_ENVELOPE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='St_equalsKeywordSegment'
pub static ST_EQUALS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ST_EQUALS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='St_exteriorringKeywordSegment'
pub static ST_EXTERIORRING_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ST_EXTERIORRING",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='St_force2dKeywordSegment'
pub static ST_FORCE2D_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ST_FORCE2D",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='St_geometrynKeywordSegment'
pub static ST_GEOMETRYN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ST_GEOMETRYN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='St_geometrytypeKeywordSegment'
pub static ST_GEOMETRYTYPE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ST_GEOMETRYTYPE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='St_interiorringnKeywordSegment'
pub static ST_INTERIORRINGN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ST_INTERIORRINGN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='St_intersectionKeywordSegment'
pub static ST_INTERSECTION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ST_INTERSECTION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='St_intersectsKeywordSegment'
pub static ST_INTERSECTS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ST_INTERSECTS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='St_isclosedKeywordSegment'
pub static ST_ISCLOSED_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ST_ISCLOSED",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='St_isemptyKeywordSegment'
pub static ST_ISEMPTY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ST_ISEMPTY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='St_isringKeywordSegment'
pub static ST_ISRING_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ST_ISRING",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='St_issimpleKeywordSegment'
pub static ST_ISSIMPLE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ST_ISSIMPLE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='St_lengthKeywordSegment'
pub static ST_LENGTH_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ST_LENGTH",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='St_max_decimal_digitsKeywordSegment'
pub static ST_MAX_DECIMAL_DIGITS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ST_MAX_DECIMAL_DIGITS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='St_numgeometriesKeywordSegment'
pub static ST_NUMGEOMETRIES_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ST_NUMGEOMETRIES",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='St_numinteriorringsKeywordSegment'
pub static ST_NUMINTERIORRINGS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ST_NUMINTERIORRINGS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='St_numpointsKeywordSegment'
pub static ST_NUMPOINTS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ST_NUMPOINTS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='St_overlapsKeywordSegment'
pub static ST_OVERLAPS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ST_OVERLAPS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='St_pointnKeywordSegment'
pub static ST_POINTN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ST_POINTN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='St_setsridKeywordSegment'
pub static ST_SETSRID_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ST_SETSRID",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='St_startpointKeywordSegment'
pub static ST_STARTPOINT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ST_STARTPOINT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='St_symdifferenceKeywordSegment'
pub static ST_SYMDIFFERENCE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ST_SYMDIFFERENCE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='St_touchesKeywordSegment'
pub static ST_TOUCHES_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ST_TOUCHES",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='St_transformKeywordSegment'
pub static ST_TRANSFORM_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ST_TRANSFORM",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='St_unionKeywordSegment'
pub static ST_UNION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ST_UNION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='St_withinKeywordSegment'
pub static ST_WITHIN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ST_WITHIN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='St_xKeywordSegment'
pub static ST_X_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ST_X",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='St_yKeywordSegment'
pub static ST_Y_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ST_Y",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='StarSegment'
pub static STAR_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "*",
    token_type: "star",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='StartBracketSegment'
pub static START_BRACKET_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='StartCurlyBracketSegment'
pub static START_CURLY_BRACKET_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "{",
    token_type: "start_curly_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='StartKeywordSegment'
pub static START_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "START",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='StartSquareBracketSegment'
pub static START_SQUARE_BRACKET_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "[",
    token_type: "start_square_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='StateKeywordSegment'
pub static STATE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "STATE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='StatementKeywordSegment'
pub static STATEMENT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "STATEMENT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='StatementSegment'
pub static STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// StatementSegment
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SelectableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "SELECT".to_string(), "VALUES".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DeleteStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DELETE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExportStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXPORT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ImportStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IMPORT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "InsertStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INSERT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MergeStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MERGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TruncateStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TRUNCATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UpdateStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UPDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AlterTableStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AlterSchemaStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AlterVirtualSchemaStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CommentStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COMMENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CreateSchemaStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CreateTableStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CreateViewStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CreateVirtualSchemaStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DropViewStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DropFunctionStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DropScriptStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DropSchemaStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DropTableStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RenameStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AccessStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GRANT".to_string(), "REVOKE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AlterConnectionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AlterUserStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CreateConnectionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CreateRoleStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CreateUserStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DropRoleStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DropUserStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DropConnectionStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CreateConsumerGroupSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AlterConsumerGroupSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DropConsumerGroupSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AlterRoleStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AlterSessionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AlterSystemSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OpenSchemaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OPEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CloseSchemaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CLOSE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FlushStatisticsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FLUSH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ImpersonateSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IMPERSONATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RecompressReorganizeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RECOMPRESS".to_string(), "REORGANIZE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "KillSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["KILL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PreloadSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PRELOAD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TruncateAuditLogsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TRUNCATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExplainVirtualSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXPLAIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TransactionStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COMMIT".to_string(), "ROLLBACK".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExecuteScriptSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXECUTE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "DelimiterGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([";".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "ALTER".to_string(), "CLOSE".to_string(), "COMMENT".to_string(), "COMMIT".to_string(), "CREATE".to_string(), "DELETE".to_string(), "DROP".to_string(), "EXECUTE".to_string(), "EXPLAIN".to_string(), "EXPORT".to_string(), "FLUSH".to_string(), "GRANT".to_string(), "IMPERSONATE".to_string(), "IMPORT".to_string(), "INSERT".to_string(), "KILL".to_string(), "MERGE".to_string(), "OPEN".to_string(), "PRELOAD".to_string(), "RECOMPRESS".to_string(), "RENAME".to_string(), "REORGANIZE".to_string(), "REVOKE".to_string(), "ROLLBACK".to_string(), "SELECT".to_string(), "TRUNCATE".to_string(), "UPDATE".to_string(), "VALUES".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='StaticKeywordSegment'
pub static STATIC_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "STATIC",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='StatisticsKeywordSegment'
pub static STATISTICS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "STATISTICS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='StddevKeywordSegment'
pub static STDDEV_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "STDDEV",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Stddev_popKeywordSegment'
pub static STDDEV_POP_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "STDDEV_POP",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Stddev_sampKeywordSegment'
pub static STDDEV_SAMP_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "STDDEV_SAMP",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='StepKeywordSegment'
pub static STEP_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "STEP",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='StringBinaryOperatorGrammar'
pub static STRING_BINARY_OPERATOR_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ConcatSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["|".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["|".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='StructLiteralSegment'
pub static STRUCT_LITERAL_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// StructLiteralSegment
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "BaseExpressionElementGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AliasExpressionSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='StructTypeSegment'
pub static STRUCT_TYPE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// StructTypeSegment
Arc::new(Grammar::Nothing())
);

// name='StructureKeywordSegment'
pub static STRUCTURE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "STRUCTURE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='StyleKeywordSegment'
pub static STYLE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "STYLE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SubjectKeywordSegment'
pub static SUBJECT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SUBJECT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SubstrKeywordSegment'
pub static SUBSTR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SUBSTR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SubstringKeywordSegment'
pub static SUBSTRING_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SUBSTRING",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SubtypeKeywordSegment'
pub static SUBTYPE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SUBTYPE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SumKeywordSegment'
pub static SUM_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SUM",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SymbolSegment'
pub static SYMBOL_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Token{
    token_type: "symbol",
//    token_type: "SymbolSegment",
})
);

// name='SymmetricKeywordSegment'
pub static SYMMETRIC_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SYMMETRIC",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Sys_connect_by_pathKeywordSegment'
pub static SYS_CONNECT_BY_PATH_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SYS_CONNECT_BY_PATH",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Sys_guidKeywordSegment'
pub static SYS_GUID_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SYS_GUID",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SysdateKeywordSegment'
pub static SYSDATE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SYSDATE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SystemKeywordSegment'
pub static SYSTEM_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SYSTEM",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SystemParameterSegment'
pub static SYSTEM_PARAMETER_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::MultiStringParser {
    templates: vec!["CONSTRAINT_STATE_DEFAULT", "DEFAULT_CONSUMER_GROUP", "DEFAULT_LIKE_ESCAPE_CHARACTER", "HASHTYPE_FORMAT", "IDLE_TIMEOUT", "NLS_DATE_FORMAT", "NLS_DATE_LANGUAGE", "NLS_FIRST_DAY_OF_WEEK", "NLS_NUMERIC_CHARACTERS", "NLS_TIMESTAMP_FORMAT", "PASSWORD_EXPIRY_POLICY", "PASSWORD_SECURITY_POLICY", "PROFILE", "QUERY_CACHE", "QUERY_TIMEOUT", "SCRIPT_LANGUAGES", "SCRIPT_OUTPUT_ADDRESS", "SESSION_TEMP_DB_RAM_LIMIT", "SNAPSHOT_MODE", "SQL_PREPROCESSOR_SCRIPT", "ST_MAX_DECIMAL_DIGITS", "TEMP_DB_RAM_LIMIT", "TIMESTAMP_ARITHMETIC_BEHAVIOR", "TIME_ZONE", "TIME_ZONE_BEHAVIOR", "USER_TEMP_DB_RAM_LIMIT"],
    token_type: "system_parameter",
    raw_class: "CodeSegment",
    optional: false,
})
);

// name='SystemPrivilegesSegment'
pub static SYSTEM_PRIVILEGES_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// SystemPrivilegesSegment
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "GrantKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GRANT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AnyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ANY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OBJECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PrivilegeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PRIVILEGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GRANT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "GrantKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GRANT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AnyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ANY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PrivilegeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PRIVILEGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GRANT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AnyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ANY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConsumerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSUMER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "GroupKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ManageKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MANAGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConsumerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSUMER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "GroupsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUPS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MANAGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "KillKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["KILL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AnyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ANY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SessionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SESSION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["KILL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SystemKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SYSTEM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AlterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string(), "CREATE".to_string(), "DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UserKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string(), "CREATE".to_string(), "DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ImpersonateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IMPERSONATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AnyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ANY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UserKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IMPERSONATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "GrantKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GRANT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string(), "GRANT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AnyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ANY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RoleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string(), "GRANT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "GrantKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GRANT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UseKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AccessKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ACCESS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ACCESS".to_string(), "ALTER".to_string(), "DROP".to_string(), "GRANT".to_string(), "USE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AnyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ANY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConnectionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONNECTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ACCESS".to_string(), "ALTER".to_string(), "DROP".to_string(), "GRANT".to_string(), "USE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "VirtualKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VIRTUAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UseKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string(), "DROP".to_string(), "USE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AnyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ANY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "VirtualKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VIRTUAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RefreshKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REFRESH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string(), "DROP".to_string(), "USE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ViewKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VIEW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConnectionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONNECTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RoleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SessionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SESSION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FUNCTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ScriptKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCRIPT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONNECTION".to_string(), "FUNCTION".to_string(), "ROLE".to_string(), "SCRIPT".to_string(), "SESSION".to_string(), "TABLE".to_string(), "VIEW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AlterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DeleteKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DELETE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "InsertKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INSERT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SelectKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SELECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UpdateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UPDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string(), "CREATE".to_string(), "DELETE".to_string(), "DROP".to_string(), "INSERT".to_string(), "SELECT".to_string(), "UPDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AnyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ANY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string(), "CREATE".to_string(), "DELETE".to_string(), "DROP".to_string(), "INSERT".to_string(), "SELECT".to_string(), "UPDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SelectKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SELECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AnyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ANY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DictionaryKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DICTIONARY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SELECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string(), "DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AnyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ANY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ViewKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VIEW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string(), "DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExecuteKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXECUTE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string(), "DROP".to_string(), "EXECUTE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AnyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ANY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ScriptKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCRIPT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FUNCTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FUNCTION".to_string(), "SCRIPT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string(), "DROP".to_string(), "EXECUTE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ImportKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IMPORT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExportKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXPORT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ACCESS".to_string(), "ALTER".to_string(), "CREATE".to_string(), "DELETE".to_string(), "DROP".to_string(), "EXECUTE".to_string(), "EXPORT".to_string(), "GRANT".to_string(), "IMPERSONATE".to_string(), "IMPORT".to_string(), "INSERT".to_string(), "KILL".to_string(), "MANAGE".to_string(), "SELECT".to_string(), "SET".to_string(), "UPDATE".to_string(), "USE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='System_userKeywordSegment'
pub static SYSTEM_USER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SYSTEM_USER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SystimestampKeywordSegment'
pub static SYSTIMESTAMP_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SYSTIMESTAMP",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TableConstraintEnableDisableGrammar'
pub static TABLE_CONSTRAINT_ENABLE_DISABLE_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "EnableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ENABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DisableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DISABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DISABLE".to_string(), "ENABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='TableConstraintSegment'
pub static TABLE_CONSTRAINT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// TableConstraintSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ConstraintKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRAINT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRAINT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "UniqueKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UNIQUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BracketedColumnReferenceListGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UNIQUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PrimaryKeyGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PRIMARY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BracketedColumnReferenceListGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PRIMARY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ForeignKeyGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOREIGN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BracketedColumnReferenceListGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ReferenceDefinitionGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REFERENCES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOREIGN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOREIGN".to_string(), "PRIMARY".to_string(), "UNIQUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRAINT".to_string(), "FOREIGN".to_string(), "PRIMARY".to_string(), "UNIQUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='TableContentDefinitionSegment'
pub static TABLE_CONTENT_DEFINITION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// TableContentDefinitionSegment
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColumnDefinitionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "TableOutOfLineConstraintSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRAINT".to_string(), "FOREIGN".to_string(), "PRIMARY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CreateTableLikeClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LIKE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='TableDistributeByGrammar'
pub static TABLE_DISTRIBUTE_BY_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DistributeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DISTRIBUTE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "TablePartitionByGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PARTITION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DelimiterGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([";".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DISTRIBUTE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='TableDistributionPartitionClause'
pub static TABLE_DISTRIBUTION_PARTITION_CLAUSE: Lazy<Arc<Grammar>> = Lazy::new(||
// TableDistributionPartitionClause
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TableDistributeByGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DISTRIBUTE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TablePartitionByGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PARTITION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DISTRIBUTE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TablePartitionByGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PARTITION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableDistributeByGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DISTRIBUTE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PARTITION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DISTRIBUTE".to_string(), "PARTITION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='TableEndClauseSegment'
pub static TABLE_END_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// TableEndClauseSegment
Arc::new(Grammar::Nothing())
);

// name='TableExpressionSegment'
pub static TABLE_EXPRESSION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// TableExpressionSegment
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "BareFunctionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONNECT_BY_ISCYCLE".to_string(), "CONNECT_BY_ISLEAF".to_string(), "CONNECT_BY_ROOT".to_string(), "CURDATE".to_string(), "CURRENT_DATE".to_string(), "CURRENT_SCHEMA".to_string(), "CURRENT_SESSION".to_string(), "CURRENT_STATEMENT".to_string(), "CURRENT_TIMESTAMP".to_string(), "CURRENT_USER".to_string(), "DBTIMEZONE".to_string(), "LEVEL".to_string(), "LOCALTIMESTAMP".to_string(), "NOW".to_string(), "ROWID".to_string(), "ROWNUM".to_string(), "SESSIONTIMEZONE".to_string(), "SYSDATE".to_string(), "SYSTIMESTAMP".to_string(), "USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SelectableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "SELECT".to_string(), "VALUES".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ValuesRangeClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ValuesClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ImportStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IMPORT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExplainVirtualSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXPLAIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='TableInlineConstraintSegment'
pub static TABLE_INLINE_CONSTRAINT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// TableInlineConstraintSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ConstraintKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRAINT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: true,
    allow_gaps: true,
    exclude: Some(Box::new(
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NotKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NullKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PrimaryKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PRIMARY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ForeignKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOREIGN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOREIGN".to_string(), "NOT".to_string(), "NULL".to_string(), "PRIMARY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    )),
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRAINT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NotKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NullKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOT".to_string(), "NULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PrimaryKeyGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PRIMARY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ForeignKeyReferencesClauseGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REFERENCES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOT".to_string(), "NULL".to_string(), "PRIMARY".to_string(), "REFERENCES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableConstraintEnableDisableGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DISABLE".to_string(), "ENABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRAINT".to_string(), "NOT".to_string(), "NULL".to_string(), "PRIMARY".to_string(), "REFERENCES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='TableKeywordSegment'
pub static TABLE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TABLE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TableOutOfLineConstraintSegment'
pub static TABLE_OUT_OF_LINE_CONSTRAINT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// TableOutOfLineConstraintSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ConstraintKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRAINT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: true,
    allow_gaps: true,
    exclude: Some(Box::new(
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NotKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NullKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PrimaryKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PRIMARY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ForeignKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOREIGN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOREIGN".to_string(), "NOT".to_string(), "NULL".to_string(), "PRIMARY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    )),
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRAINT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PrimaryKeyGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PRIMARY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BracketedColumnReferenceListGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PRIMARY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ForeignKeyGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOREIGN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BracketedColumnReferenceListGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ForeignKeyReferencesClauseGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REFERENCES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOREIGN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOREIGN".to_string(), "PRIMARY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableConstraintEnableDisableGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DISABLE".to_string(), "ENABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRAINT".to_string(), "FOREIGN".to_string(), "PRIMARY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='TablePartitionByGrammar'
pub static TABLE_PARTITION_BY_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PartitionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PARTITION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "TableDistributeByGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DISTRIBUTE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DelimiterGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([";".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PARTITION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='TableReferenceSegment'
pub static TABLE_REFERENCE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// TableReferenceSegment
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "ObjectReferenceDelimiterGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "ObjectReferenceTerminatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    reset_terminators: false,
    allow_gaps: false,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='TablesKeywordSegment'
pub static TABLES_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TABLES",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TablesampleKeywordSegment'
pub static TABLESAMPLE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TABLESAMPLE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TablespaceReferenceSegment'
pub static TABLESPACE_REFERENCE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// TablespaceReferenceSegment
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "ObjectReferenceDelimiterGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "ObjectReferenceTerminatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    reset_terminators: false,
    allow_gaps: false,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='TagReferenceSegment'
pub static TAG_REFERENCE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// TagReferenceSegment
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "ObjectReferenceDelimiterGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "ObjectReferenceTerminatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    reset_terminators: false,
    allow_gaps: false,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='Tail_Recurse_Expression_A_Grammar'
pub static TAIL_RECURSE_EXPRESSION_A_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "Expression_A_Unary_Operator_Grammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["+".to_string(), "-".to_string(), "NOT".to_string(), "PRIOR".to_string(), "~".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "BinaryOperatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["!".to_string(), "%".to_string(), "&".to_string(), "*".to_string(), "+".to_string(), "-".to_string(), "/".to_string(), "<".to_string(), "=".to_string(), ">".to_string(), "AND".to_string(), "IS".to_string(), "OR".to_string(), "^".to_string(), "|".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["like_operator".to_string()]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["+".to_string(), "-".to_string(), "NOT".to_string(), "PRIOR".to_string(), "~".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Expression_C_Grammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='Tail_Recurse_Expression_B_Grammar'
pub static TAIL_RECURSE_EXPRESSION_B_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "Expression_B_Unary_Operator_Grammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["+".to_string(), "-".to_string(), "~".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["+".to_string(), "-".to_string(), "~".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Expression_C_Grammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='TanKeywordSegment'
pub static TAN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TAN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TanhKeywordSegment'
pub static TANH_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TANH",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TasksKeywordSegment'
pub static TASKS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TASKS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Temp_db_ram_limitKeywordSegment'
pub static TEMP_DB_RAM_LIMIT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TEMP_DB_RAM_LIMIT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TemporalQuerySegment'
pub static TEMPORAL_QUERY_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// TemporalQuerySegment
Arc::new(Grammar::Nothing())
);

// name='TemporaryGrammar'
pub static TEMPORARY_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TempKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "TemporaryKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TEMPORARY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='TemporaryKeywordSegment'
pub static TEMPORARY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TEMPORARY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TemporaryTransientGrammar'
pub static TEMPORARY_TRANSIENT_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TransientKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "TemporaryGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='TextKeywordSegment'
pub static TEXT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TEXT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ThenKeywordSegment'
pub static THEN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "THEN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TiesKeywordSegment'
pub static TIES_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TIES",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TildeSegment'
pub static TILDE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "~",
    token_type: "tilde",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='TimeKeywordSegment'
pub static TIME_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TIME",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TimeWithTZGrammar'
pub static TIME_WITH_T_Z_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TimeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TIME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TimestampKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TIMESTAMP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TIME".to_string(), "TIMESTAMP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BracketedArguments",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WithoutKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITHOUT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string(), "WITHOUT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TimeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TIME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ZoneKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ZONE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string(), "WITHOUT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TIME".to_string(), "TIMESTAMP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='TimeZoneGrammar'
pub static TIME_ZONE_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
// TimeZoneGrammar
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AtKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TimeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TIME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ZoneKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ZONE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='Time_zoneKeywordSegment'
pub static TIME_ZONE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TIME_ZONE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Time_zone_behaviorKeywordSegment'
pub static TIME_ZONE_BEHAVIOR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TIME_ZONE_BEHAVIOR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TimestampKeywordSegment'
pub static TIMESTAMP_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TIMESTAMP",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Timestamp_arithmetic_behaviorKeywordSegment'
pub static TIMESTAMP_ARITHMETIC_BEHAVIOR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TIMESTAMP_ARITHMETIC_BEHAVIOR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Timezone_hourKeywordSegment'
pub static TIMEZONE_HOUR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TIMEZONE_HOUR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Timezone_minuteKeywordSegment'
pub static TIMEZONE_MINUTE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TIMEZONE_MINUTE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TinyintKeywordSegment'
pub static TINYINT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TINYINT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ToKeywordSegment'
pub static TO_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TO",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='To_charKeywordSegment'
pub static TO_CHAR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TO_CHAR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='To_dateKeywordSegment'
pub static TO_DATE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TO_DATE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='To_dsintervalKeywordSegment'
pub static TO_DSINTERVAL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TO_DSINTERVAL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='To_numberKeywordSegment'
pub static TO_NUMBER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TO_NUMBER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='To_timestampKeywordSegment'
pub static TO_TIMESTAMP_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TO_TIMESTAMP",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='To_ymintervalKeywordSegment'
pub static TO_YMINTERVAL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TO_YMINTERVAL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TraceKeywordSegment'
pub static TRACE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TRACE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TrailingKeywordSegment'
pub static TRAILING_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TRAILING",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TransactionKeywordSegment'
pub static TRANSACTION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TRANSACTION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TransactionStatementSegment'
pub static TRANSACTION_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// TransactionStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CommitKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COMMIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RollbackKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROLLBACK".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COMMIT".to_string(), "ROLLBACK".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WorkKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WORK".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COMMIT".to_string(), "ROLLBACK".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='TransformKeywordSegment'
pub static TRANSFORM_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TRANSFORM",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TransformsKeywordSegment'
pub static TRANSFORMS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TRANSFORMS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TranslateKeywordSegment'
pub static TRANSLATE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TRANSLATE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TranslationKeywordSegment'
pub static TRANSLATION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TRANSLATION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TreatKeywordSegment'
pub static TREAT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TREAT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TriggerKeywordSegment'
pub static TRIGGER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TRIGGER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TriggerReferenceSegment'
pub static TRIGGER_REFERENCE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// TriggerReferenceSegment
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "ObjectReferenceDelimiterGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "ObjectReferenceTerminatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    reset_terminators: false,
    allow_gaps: false,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='TrimKeywordSegment'
pub static TRIM_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TRIM",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TrimParametersGrammar'
pub static TRIM_PARAMETERS_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "BothKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BOTH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LeadingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LEADING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TrailingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TRAILING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BOTH".to_string(), "LEADING".to_string(), "TRAILING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='TrueKeywordSegment'
pub static TRUE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TRUE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TrueSegment'
pub static TRUE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TRUE",
    token_type: "boolean_literal",
    raw_class: "LiteralKeywordSegment",
    optional: false,
})
);

// name='TruncKeywordSegment'
pub static TRUNC_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TRUNC",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TruncateAuditLogsSegment'
pub static TRUNCATE_AUDIT_LOGS_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// TruncateAuditLogsSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TruncateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TRUNCATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AuditKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AUDIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LogsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LOGS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "KeepKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["KEEP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LastKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LAST".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DayKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DAY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MonthKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MONTH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "YearKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["YEAR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DAY".to_string(), "MONTH".to_string(), "YEAR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LAST".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FromKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string(), "LAST".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["KEEP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TRUNCATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='TruncateKeywordSegment'
pub static TRUNCATE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TRUNCATE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TruncateStatementSegment'
pub static TRUNCATE_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// TruncateStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TruncateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TRUNCATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TRUNCATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='TupleSegment'
pub static TUPLE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// TupleSegment
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "BaseExpressionElementGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='TypeKeywordSegment'
pub static TYPE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TYPE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TypedArrayLiteralSegment'
pub static TYPED_ARRAY_LITERAL_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// TypedArrayLiteralSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ArrayTypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ArrayLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["[".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='TypedStructLiteralSegment'
pub static TYPED_STRUCT_LITERAL_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// TypedStructLiteralSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "StructTypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "StructLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='TypeofKeywordSegment'
pub static TYPEOF_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TYPEOF",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='UDFParameterDotSyntaxSegment'
pub static U_D_F_PARAMETER_DOT_SYNTAX_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::TypedParser {
    template: "udf_param_dot_syntax",
    token_type: "identifier",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='UDFParameterGrammar'
pub static U_D_F_PARAMETER_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColumnDatatypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "UDFParameterDotSyntaxSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["udf_param_dot_syntax".to_string()]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='UcaseKeywordSegment'
pub static UCASE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "UCASE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='UnboundedKeywordSegment'
pub static UNBOUNDED_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "UNBOUNDED",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='UncommittedKeywordSegment'
pub static UNCOMMITTED_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "UNCOMMITTED",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='UnconditionalCrossJoinKeywordsGrammar'
pub static UNCONDITIONAL_CROSS_JOIN_KEYWORDS_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Nothing())
);

// name='UnconditionalJoinKeywordsGrammar'
pub static UNCONDITIONAL_JOIN_KEYWORDS_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NaturalJoinKeywordsGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NATURAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UnconditionalCrossJoinKeywordsGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "HorizontalJoinKeywordsGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='UnderKeywordSegment'
pub static UNDER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "UNDER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='UndoKeywordSegment'
pub static UNDO_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "UNDO",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='UnicodeKeywordSegment'
pub static UNICODE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "UNICODE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='UnicodechrKeywordSegment'
pub static UNICODECHR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "UNICODECHR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='UnionGrammar'
pub static UNION_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "UnionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UNION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DistinctKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DISTINCT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AllKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string(), "DISTINCT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UNION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='UnionKeywordSegment'
pub static UNION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "UNION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='UniqueKeyGrammar'
pub static UNIQUE_KEY_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "UniqueKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UNIQUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UNIQUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='UniqueKeywordSegment'
pub static UNIQUE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "UNIQUE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='UnknownKeywordSegment'
pub static UNKNOWN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "UNKNOWN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='UnknownLiteralSegment'
pub static UNKNOWN_LITERAL_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Nothing())
);

// name='UnknownSegment'
pub static UNKNOWN_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "UNKNOWN",
    token_type: "boolean_literal",
    raw_class: "LiteralKeywordSegment",
    optional: false,
})
);

// name='UnlimitedKeywordSegment'
pub static UNLIMITED_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "UNLIMITED",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='UnlinkKeywordSegment'
pub static UNLINK_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "UNLINK",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='UnnestKeywordSegment'
pub static UNNEST_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "UNNEST",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='UnorderedSelectStatementSegment'
pub static UNORDERED_SELECT_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// UnorderedSelectStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SelectClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SELECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FromClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ReferencingClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REFERENCING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WhereClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHERE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConnectByClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONNECT".to_string(), "START".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PreferringClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PREFERRING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "GroupByClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "HavingClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["HAVING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QualifyClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["QUALIFY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "SetOperatorSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCEPT".to_string(), "INTERSECT".to_string(), "MINUS".to_string(), "UNION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WithDataClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CommentClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COMMENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OrderByClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LimitClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LIMIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::GreedyOnceStarted,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SELECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='UnorderedSetExpressionSegment'
pub static UNORDERED_SET_EXPRESSION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// UnorderedSetExpressionSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NonSetSelectableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "SELECT".to_string(), "VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetOperatorSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCEPT".to_string(), "INTERSECT".to_string(), "MINUS".to_string(), "UNION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NonSetSelectableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "SELECT".to_string(), "VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCEPT".to_string(), "INTERSECT".to_string(), "MINUS".to_string(), "UNION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 1,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCEPT".to_string(), "INTERSECT".to_string(), "MINUS".to_string(), "UNION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "SELECT".to_string(), "VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='UntilKeywordSegment'
pub static UNTIL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "UNTIL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='UpdateKeywordSegment'
pub static UPDATE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "UPDATE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='UpdateStatementSegment'
pub static UPDATE_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// UpdateStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "UpdateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UPDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AliasedTableReferenceGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("dedent"))
,
Arc::new(Grammar::Ref {
    name: "SetClauseListSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FromClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WhereClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHERE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PreferringClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PREFERRING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UPDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='UpperKeywordSegment'
pub static UPPER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "UPPER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='UsageKeywordSegment'
pub static USAGE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "USAGE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='UseKeywordSegment'
pub static USE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "USE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='UseStatementSegment'
pub static USE_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// UseStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "UseKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DatabaseReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='UserKerberosAuthSegment'
pub static USER_KERBEROS_AUTH_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// UserKerberosAuthSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "KerberosKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["KERBEROS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PrincipalKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PRINCIPAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='UserKeywordSegment'
pub static USER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "USER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='UserLDAPAuthSegment'
pub static USER_L_D_A_P_AUTH_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// UserLDAPAuthSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AtKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LdapKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LDAP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ForceKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FORCE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='UserOpenIDAuthSegment'
pub static USER_OPEN_I_D_AUTH_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// UserOpenIDAuthSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OpenidKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OPENID".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SubjectKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SUBJECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='UserPasswordAuthSegment'
pub static USER_PASSWORD_AUTH_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// UserPasswordAuthSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PasswordLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["double_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='User_temp_db_ram_limitKeywordSegment'
pub static USER_TEMP_DB_RAM_LIMIT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "USER_TEMP_DB_RAM_LIMIT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='UsingKeywordSegment'
pub static USING_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "USING",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Utf8KeywordSegment'
pub static UTF8_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "UTF8",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Value2procKeywordSegment'
pub static VALUE2PROC_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "VALUE2PROC",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ValueKeywordSegment'
pub static VALUE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "VALUE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ValuesClauseSegment'
pub static VALUES_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ValuesClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ValuesKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DefaultKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Greedy,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DefaultKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AliasExpressionSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ValuesKeywordSegment'
pub static VALUES_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "VALUES",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ValuesRangeClauseSegment'
pub static VALUES_RANGE_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ValuesRangeClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ValuesKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BetweenKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BETWEEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BareFunctionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONNECT_BY_ISCYCLE".to_string(), "CONNECT_BY_ISLEAF".to_string(), "CONNECT_BY_ROOT".to_string(), "CURDATE".to_string(), "CURRENT_DATE".to_string(), "CURRENT_SCHEMA".to_string(), "CURRENT_SESSION".to_string(), "CURRENT_STATEMENT".to_string(), "CURRENT_TIMESTAMP".to_string(), "CURRENT_USER".to_string(), "DBTIMEZONE".to_string(), "LEVEL".to_string(), "LOCALTIMESTAMP".to_string(), "NOW".to_string(), "ROWID".to_string(), "ROWNUM".to_string(), "SESSIONTIMEZONE".to_string(), "SYSDATE".to_string(), "SYSTIMESTAMP".to_string(), "USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AndKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AND".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BareFunctionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONNECT_BY_ISCYCLE".to_string(), "CONNECT_BY_ISLEAF".to_string(), "CONNECT_BY_ROOT".to_string(), "CURDATE".to_string(), "CURRENT_DATE".to_string(), "CURRENT_SCHEMA".to_string(), "CURRENT_SESSION".to_string(), "CURRENT_STATEMENT".to_string(), "CURRENT_TIMESTAMP".to_string(), "CURRENT_USER".to_string(), "DBTIMEZONE".to_string(), "LEVEL".to_string(), "LOCALTIMESTAMP".to_string(), "NOW".to_string(), "ROWID".to_string(), "ROWNUM".to_string(), "SESSIONTIMEZONE".to_string(), "SYSDATE".to_string(), "SYSTIMESTAMP".to_string(), "USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StepKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STEP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='Var_popKeywordSegment'
pub static VAR_POP_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "VAR_POP",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Var_sampKeywordSegment'
pub static VAR_SAMP_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "VAR_SAMP",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Varchar2KeywordSegment'
pub static VARCHAR2_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "VARCHAR2",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='VarcharKeywordSegment'
pub static VARCHAR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "VARCHAR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='VariableNameSegment'
pub static VARIABLE_NAME_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::RegexParser {
    template: regex::RegexBuilder::new(r#"[A-Z][A-Z0-9_]*"#)
         .case_insensitive(true)
         .build()
         .unwrap(),
    token_type: "variable",
    raw_class: "CodeSegment",
    optional: false,
    anti_template: None,
})
);

// name='VarianceKeywordSegment'
pub static VARIANCE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "VARIANCE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='VarrayKeywordSegment'
pub static VARRAY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "VARRAY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='VaryingKeywordSegment'
pub static VARYING_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "VARYING",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='VerifyKeywordSegment'
pub static VERIFY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "VERIFY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ViewKeywordSegment'
pub static VIEW_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "VIEW",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ViewReferenceSegment'
pub static VIEW_REFERENCE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ViewReferenceSegment
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "ObjectReferenceDelimiterGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "ObjectReferenceTerminatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    reset_terminators: false,
    allow_gaps: false,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='VirtualKeywordSegment'
pub static VIRTUAL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "VIRTUAL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='WalrusOperatorSegment'
pub static WALRUS_OPERATOR_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: ":=",
    token_type: "assignment_operator",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='WeekKeywordSegment'
pub static WEEK_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "WEEK",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='WhenClauseSegment'
pub static WHEN_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// WhenClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WhenKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("dedent"))
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("conditional"))
,
Arc::new(Grammar::Ref {
    name: "ThenKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["THEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("conditional"))
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("conditional"))
,
Arc::new(Grammar::Meta("conditional"))
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='WhenKeywordSegment'
pub static WHEN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "WHEN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='WheneverKeywordSegment'
pub static WHENEVER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "WHENEVER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='WhereClauseSegment'
pub static WHERE_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// WhereClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WhereKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHERE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("dedent"))
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHERE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='WhereClauseTerminatorGrammar'
pub static WHERE_CLAUSE_TERMINATOR_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ConnectKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONNECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StartKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["START".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PreferringKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PREFERRING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LimitKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LIMIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "GroupKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OrderKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "HavingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["HAVING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QualifyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["QUALIFY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SetOperatorSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCEPT".to_string(), "INTERSECT".to_string(), "MINUS".to_string(), "UNION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WithDataClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CommentClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COMMENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COMMENT".to_string(), "CONNECT".to_string(), "EXCEPT".to_string(), "GROUP".to_string(), "HAVING".to_string(), "INTERSECT".to_string(), "LIMIT".to_string(), "MINUS".to_string(), "ORDER".to_string(), "PREFERRING".to_string(), "QUALIFY".to_string(), "START".to_string(), "UNION".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='WhereKeywordSegment'
pub static WHERE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "WHERE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='WhileKeywordSegment'
pub static WHILE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "WHILE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='WhitespaceSegment'
pub static WHITESPACE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Token{
    token_type: "whitespace",
//    token_type: "WhitespaceSegment",
})
);

// name='WildcardExpressionSegment'
pub static WILDCARD_EXPRESSION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// WildcardExpressionSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WildcardIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='WildcardIdentifierSegment'
pub static WILDCARD_IDENTIFIER_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// WildcardIdentifierSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceDelimiterGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "StarSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["*".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DotSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["*".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "StarSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["*".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: false,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='WindowKeywordSegment'
pub static WINDOW_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "WINDOW",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='WindowSpecificationSegment'
pub static WINDOW_SPECIFICATION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// WindowSpecificationSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: true,
    allow_gaps: true,
    exclude: Some(Box::new(
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PartitionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PARTITION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OrderKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string(), "PARTITION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    )),
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "PartitionClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PARTITION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OrderByClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FrameClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RANGE".to_string(), "ROWS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='WithCompoundNonSelectStatementSegment'
pub static WITH_COMPOUND_NON_SELECT_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// WithCompoundNonSelectStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RecursiveKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RECURSIVE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("conditional"))
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CTEDefinitionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: true,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "SelectKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SELECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("conditional"))
,
Arc::new(Grammar::Ref {
    name: "NonWithNonSelectableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DELETE".to_string(), "INSERT".to_string(), "MERGE".to_string(), "UPDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='WithCompoundStatementSegment'
pub static WITH_COMPOUND_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// WithCompoundStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RecursiveKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RECURSIVE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("conditional"))
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CTEDefinitionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: true,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "SelectKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SELECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("conditional"))
,
Arc::new(Grammar::Ref {
    name: "NonWithSelectableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "SELECT".to_string(), "VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='WithDataClauseSegment'
pub static WITH_DATA_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// WithDataClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NoKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DataKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='WithFillSegment'
pub static WITH_FILL_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// WithFillSegment
Arc::new(Grammar::Nothing())
);

// name='WithInvalidForeignKeySegment'
pub static WITH_INVALID_FOREIGN_KEY_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// WithInvalidForeignKeySegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "InvalidKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INVALID".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ForeignKeyGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOREIGN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BracketedColumnReferenceListGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INVALID".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='WithInvalidUniquePKSegment'
pub static WITH_INVALID_UNIQUE_P_K_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// WithInvalidUniquePKSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "InvalidKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INVALID".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "UniqueKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UNIQUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PrimaryKeyGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PRIMARY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PRIMARY".to_string(), "UNIQUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BracketedColumnReferenceListGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INVALID".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='WithKeywordSegment'
pub static WITH_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "WITH",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='WithNoSchemaBindingClauseSegment'
pub static WITH_NO_SCHEMA_BINDING_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// WithNoSchemaBindingClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NoKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BindingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='WithinKeywordSegment'
pub static WITHIN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "WITHIN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='WithoutKeywordSegment'
pub static WITHOUT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "WITHOUT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='WordSegment'
pub static WORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Token{
    token_type: "word",
//    token_type: "WordSegment",
})
);

// name='WorkKeywordSegment'
pub static WORK_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "WORK",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='WriteKeywordSegment'
pub static WRITE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "WRITE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='YearKeywordSegment'
pub static YEAR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "YEAR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Years_betweenKeywordSegment'
pub static YEARS_BETWEEN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "YEARS_BETWEEN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='YesKeywordSegment'
pub static YES_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "YES",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ZeroifnullKeywordSegment'
pub static ZEROIFNULL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ZEROIFNULL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ZoneKeywordSegment'
pub static ZONE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ZONE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

pub fn get_exasol_segment_grammar(name: &str) -> Option<Arc<Grammar>> {
    match name {
            "AbsKeywordSegment" => Some(ABS_KEYWORD_SEGMENT.clone()),
            "AbsoluteKeywordSegment" => Some(ABSOLUTE_KEYWORD_SEGMENT.clone()),
            "AccessKeywordSegment" => Some(ACCESS_KEYWORD_SEGMENT.clone()),
            "AccessStatementSegment" => Some(ACCESS_STATEMENT_SEGMENT.clone()),
            "AccessorGrammar" => Some(ACCESSOR_GRAMMAR.clone()),
            "AcosKeywordSegment" => Some(ACOS_KEYWORD_SEGMENT.clone()),
            "ActionKeywordSegment" => Some(ACTION_KEYWORD_SEGMENT.clone()),
            "AdapterKeywordSegment" => Some(ADAPTER_KEYWORD_SEGMENT.clone()),
            "AddKeywordSegment" => Some(ADD_KEYWORD_SEGMENT.clone()),
            "Add_daysKeywordSegment" => Some(ADD_DAYS_KEYWORD_SEGMENT.clone()),
            "Add_hoursKeywordSegment" => Some(ADD_HOURS_KEYWORD_SEGMENT.clone()),
            "Add_minutesKeywordSegment" => Some(ADD_MINUTES_KEYWORD_SEGMENT.clone()),
            "Add_monthsKeywordSegment" => Some(ADD_MONTHS_KEYWORD_SEGMENT.clone()),
            "Add_secondsKeywordSegment" => Some(ADD_SECONDS_KEYWORD_SEGMENT.clone()),
            "Add_weeksKeywordSegment" => Some(ADD_WEEKS_KEYWORD_SEGMENT.clone()),
            "Add_yearsKeywordSegment" => Some(ADD_YEARS_KEYWORD_SEGMENT.clone()),
            "AdminKeywordSegment" => Some(ADMIN_KEYWORD_SEGMENT.clone()),
            "AfterKeywordSegment" => Some(AFTER_KEYWORD_SEGMENT.clone()),
            "AggregateOrderByClause" => Some(AGGREGATE_ORDER_BY_CLAUSE.clone()),
            "AliasExpressionSegment" => Some(ALIAS_EXPRESSION_SEGMENT.clone()),
            "AliasedTableReferenceGrammar" => Some(ALIASED_TABLE_REFERENCE_GRAMMAR.clone()),
            "AlignKeywordSegment" => Some(ALIGN_KEYWORD_SEGMENT.clone()),
            "AllKeywordSegment" => Some(ALL_KEYWORD_SEGMENT.clone()),
            "AllocateKeywordSegment" => Some(ALLOCATE_KEYWORD_SEGMENT.clone()),
            "AlterConnectionSegment" => Some(ALTER_CONNECTION_SEGMENT.clone()),
            "AlterConsumerGroupSegment" => Some(ALTER_CONSUMER_GROUP_SEGMENT.clone()),
            "AlterKeywordSegment" => Some(ALTER_KEYWORD_SEGMENT.clone()),
            "AlterRoleStatementSegment" => Some(ALTER_ROLE_STATEMENT_SEGMENT.clone()),
            "AlterSchemaStatementSegment" => Some(ALTER_SCHEMA_STATEMENT_SEGMENT.clone()),
            "AlterSequenceOptionsSegment" => Some(ALTER_SEQUENCE_OPTIONS_SEGMENT.clone()),
            "AlterSequenceStatementSegment" => Some(ALTER_SEQUENCE_STATEMENT_SEGMENT.clone()),
            "AlterSessionSegment" => Some(ALTER_SESSION_SEGMENT.clone()),
            "AlterSystemSegment" => Some(ALTER_SYSTEM_SEGMENT.clone()),
            "AlterTableAddColumnSegment" => Some(ALTER_TABLE_ADD_COLUMN_SEGMENT.clone()),
            "AlterTableAlterColumnSegment" => Some(ALTER_TABLE_ALTER_COLUMN_SEGMENT.clone()),
            "AlterTableColumnSegment" => Some(ALTER_TABLE_COLUMN_SEGMENT.clone()),
            "AlterTableConstraintSegment" => Some(ALTER_TABLE_CONSTRAINT_SEGMENT.clone()),
            "AlterTableDistributePartitionSegment" => Some(ALTER_TABLE_DISTRIBUTE_PARTITION_SEGMENT.clone()),
            "AlterTableDropColumnGrammar" => Some(ALTER_TABLE_DROP_COLUMN_GRAMMAR.clone()),
            "AlterTableDropColumnSegment" => Some(ALTER_TABLE_DROP_COLUMN_SEGMENT.clone()),
            "AlterTableModifyColumnSegment" => Some(ALTER_TABLE_MODIFY_COLUMN_SEGMENT.clone()),
            "AlterTableOptionsGrammar" => Some(ALTER_TABLE_OPTIONS_GRAMMAR.clone()),
            "AlterTableRenameColumnSegment" => Some(ALTER_TABLE_RENAME_COLUMN_SEGMENT.clone()),
            "AlterTableStatementSegment" => Some(ALTER_TABLE_STATEMENT_SEGMENT.clone()),
            "AlterUserStatementSegment" => Some(ALTER_USER_STATEMENT_SEGMENT.clone()),
            "AlterVirtualSchemaStatementSegment" => Some(ALTER_VIRTUAL_SCHEMA_STATEMENT_SEGMENT.clone()),
            "AlwaysKeywordSegment" => Some(ALWAYS_KEYWORD_SEGMENT.clone()),
            "AmpersandSegment" => Some(AMPERSAND_SEGMENT.clone()),
            "AnalyzeKeywordSegment" => Some(ANALYZE_KEYWORD_SEGMENT.clone()),
            "AndKeywordSegment" => Some(AND_KEYWORD_SEGMENT.clone()),
            "AndOperatorGrammar" => Some(AND_OPERATOR_GRAMMAR.clone()),
            "AnsiKeywordSegment" => Some(ANSI_KEYWORD_SEGMENT.clone()),
            "AnyKeywordSegment" => Some(ANY_KEYWORD_SEGMENT.clone()),
            "AppendKeywordSegment" => Some(APPEND_KEYWORD_SEGMENT.clone()),
            "Approximate_count_distinctKeywordSegment" => Some(APPROXIMATE_COUNT_DISTINCT_KEYWORD_SEGMENT.clone()),
            "AreKeywordSegment" => Some(ARE_KEYWORD_SEGMENT.clone()),
            "ArithmeticBinaryOperatorGrammar" => Some(ARITHMETIC_BINARY_OPERATOR_GRAMMAR.clone()),
            "ArrayAccessorSegment" => Some(ARRAY_ACCESSOR_SEGMENT.clone()),
            "ArrayExpressionSegment" => Some(ARRAY_EXPRESSION_SEGMENT.clone()),
            "ArrayKeywordSegment" => Some(ARRAY_KEYWORD_SEGMENT.clone()),
            "ArrayLiteralSegment" => Some(ARRAY_LITERAL_SEGMENT.clone()),
            "ArrayTypeSegment" => Some(ARRAY_TYPE_SEGMENT.clone()),
            "AsAliasOperatorSegment" => Some(AS_ALIAS_OPERATOR_SEGMENT.clone()),
            "AsKeywordSegment" => Some(AS_KEYWORD_SEGMENT.clone()),
            "AscKeywordSegment" => Some(ASC_KEYWORD_SEGMENT.clone()),
            "AsciiKeywordSegment" => Some(ASCII_KEYWORD_SEGMENT.clone()),
            "AsensitiveKeywordSegment" => Some(ASENSITIVE_KEYWORD_SEGMENT.clone()),
            "AsinKeywordSegment" => Some(ASIN_KEYWORD_SEGMENT.clone()),
            "AssertionKeywordSegment" => Some(ASSERTION_KEYWORD_SEGMENT.clone()),
            "AssignmentKeywordSegment" => Some(ASSIGNMENT_KEYWORD_SEGMENT.clone()),
            "AsymmetricKeywordSegment" => Some(ASYMMETRIC_KEYWORD_SEGMENT.clone()),
            "AtKeywordSegment" => Some(AT_KEYWORD_SEGMENT.clone()),
            "Atan2KeywordSegment" => Some(ATAN2_KEYWORD_SEGMENT.clone()),
            "AtanKeywordSegment" => Some(ATAN_KEYWORD_SEGMENT.clone()),
            "AtomicKeywordSegment" => Some(ATOMIC_KEYWORD_SEGMENT.clone()),
            "AttemptsKeywordSegment" => Some(ATTEMPTS_KEYWORD_SEGMENT.clone()),
            "AttributeKeywordSegment" => Some(ATTRIBUTE_KEYWORD_SEGMENT.clone()),
            "AuditKeywordSegment" => Some(AUDIT_KEYWORD_SEGMENT.clone()),
            "AuthenticatedKeywordSegment" => Some(AUTHENTICATED_KEYWORD_SEGMENT.clone()),
            "AuthidKeywordSegment" => Some(AUTHID_KEYWORD_SEGMENT.clone()),
            "AuthorizationKeywordSegment" => Some(AUTHORIZATION_KEYWORD_SEGMENT.clone()),
            "AutoIncrementGrammar" => Some(AUTO_INCREMENT_GRAMMAR.clone()),
            "AutoKeywordSegment" => Some(AUTO_KEYWORD_SEGMENT.clone()),
            "AvgKeywordSegment" => Some(AVG_KEYWORD_SEGMENT.clone()),
            "BackupKeywordSegment" => Some(BACKUP_KEYWORD_SEGMENT.clone()),
            "BareFunctionSegment" => Some(BARE_FUNCTION_SEGMENT.clone()),
            "BaseExpressionElementGrammar" => Some(BASE_EXPRESSION_ELEMENT_GRAMMAR.clone()),
            "BaseFileSegment" => Some(BASE_FILE_SEGMENT.clone()),
            "BaseSegment" => Some(BASE_SEGMENT.clone()),
            "BeforeKeywordSegment" => Some(BEFORE_KEYWORD_SEGMENT.clone()),
            "BeginKeywordSegment" => Some(BEGIN_KEYWORD_SEGMENT.clone()),
            "BernoulliKeywordSegment" => Some(BERNOULLI_KEYWORD_SEGMENT.clone()),
            "BetweenKeywordSegment" => Some(BETWEEN_KEYWORD_SEGMENT.clone()),
            "BigintKeywordSegment" => Some(BIGINT_KEYWORD_SEGMENT.clone()),
            "BinaryKeywordSegment" => Some(BINARY_KEYWORD_SEGMENT.clone()),
            "BinaryOperatorGrammar" => Some(BINARY_OPERATOR_GRAMMAR.clone()),
            "BinaryOperatorSegment" => Some(BINARY_OPERATOR_SEGMENT.clone()),
            "BitKeywordSegment" => Some(BIT_KEYWORD_SEGMENT.clone()),
            "Bit_andKeywordSegment" => Some(BIT_AND_KEYWORD_SEGMENT.clone()),
            "Bit_checkKeywordSegment" => Some(BIT_CHECK_KEYWORD_SEGMENT.clone()),
            "Bit_lengthKeywordSegment" => Some(BIT_LENGTH_KEYWORD_SEGMENT.clone()),
            "Bit_lrotateKeywordSegment" => Some(BIT_LROTATE_KEYWORD_SEGMENT.clone()),
            "Bit_lshiftKeywordSegment" => Some(BIT_LSHIFT_KEYWORD_SEGMENT.clone()),
            "Bit_notKeywordSegment" => Some(BIT_NOT_KEYWORD_SEGMENT.clone()),
            "Bit_orKeywordSegment" => Some(BIT_OR_KEYWORD_SEGMENT.clone()),
            "Bit_rrotateKeywordSegment" => Some(BIT_RROTATE_KEYWORD_SEGMENT.clone()),
            "Bit_rshiftKeywordSegment" => Some(BIT_RSHIFT_KEYWORD_SEGMENT.clone()),
            "Bit_setKeywordSegment" => Some(BIT_SET_KEYWORD_SEGMENT.clone()),
            "Bit_to_numKeywordSegment" => Some(BIT_TO_NUM_KEYWORD_SEGMENT.clone()),
            "Bit_xorKeywordSegment" => Some(BIT_XOR_KEYWORD_SEGMENT.clone()),
            "BitwiseAndSegment" => Some(BITWISE_AND_SEGMENT.clone()),
            "BitwiseLShiftSegment" => Some(BITWISE_L_SHIFT_SEGMENT.clone()),
            "BitwiseOrSegment" => Some(BITWISE_OR_SEGMENT.clone()),
            "BitwiseRShiftSegment" => Some(BITWISE_R_SHIFT_SEGMENT.clone()),
            "BitwiseXorSegment" => Some(BITWISE_XOR_SEGMENT.clone()),
            "BlobKeywordSegment" => Some(BLOB_KEYWORD_SEGMENT.clone()),
            "BlockedKeywordSegment" => Some(BLOCKED_KEYWORD_SEGMENT.clone()),
            "BoolKeywordSegment" => Some(BOOL_KEYWORD_SEGMENT.clone()),
            "BooleanBinaryOperatorGrammar" => Some(BOOLEAN_BINARY_OPERATOR_GRAMMAR.clone()),
            "BooleanKeywordSegment" => Some(BOOLEAN_KEYWORD_SEGMENT.clone()),
            "BooleanLiteralGrammar" => Some(BOOLEAN_LITERAL_GRAMMAR.clone()),
            "BothKeywordSegment" => Some(BOTH_KEYWORD_SEGMENT.clone()),
            "BracketedArguments" => Some(BRACKETED_ARGUMENTS.clone()),
            "BracketedColumnReferenceListGrammar" => Some(BRACKETED_COLUMN_REFERENCE_LIST_GRAMMAR.clone()),
            "BracketedSegment" => Some(BRACKETED_SEGMENT.clone()),
            "BracketedSetExpressionGrammar" => Some(BRACKETED_SET_EXPRESSION_GRAMMAR.clone()),
            "BreadthKeywordSegment" => Some(BREADTH_KEYWORD_SEGMENT.clone()),
            "ByKeywordSegment" => Some(BY_KEYWORD_SEGMENT.clone()),
            "ByteKeywordSegment" => Some(BYTE_KEYWORD_SEGMENT.clone()),
            "CSVColumnDefinitionSegment" => Some(C_S_V_COLUMN_DEFINITION_SEGMENT.clone()),
            "CTEColumnList" => Some(C_T_E_COLUMN_LIST.clone()),
            "CTEDefinitionSegment" => Some(C_T_E_DEFINITION_SEGMENT.clone()),
            "CallKeywordSegment" => Some(CALL_KEYWORD_SEGMENT.clone()),
            "CalledKeywordSegment" => Some(CALLED_KEYWORD_SEGMENT.clone()),
            "CardinalityKeywordSegment" => Some(CARDINALITY_KEYWORD_SEGMENT.clone()),
            "CascadeKeywordSegment" => Some(CASCADE_KEYWORD_SEGMENT.clone()),
            "CascadedKeywordSegment" => Some(CASCADED_KEYWORD_SEGMENT.clone()),
            "CaseExpressionSegment" => Some(CASE_EXPRESSION_SEGMENT.clone()),
            "CaseKeywordSegment" => Some(CASE_KEYWORD_SEGMENT.clone()),
            "CasespecificKeywordSegment" => Some(CASESPECIFIC_KEYWORD_SEGMENT.clone()),
            "CastKeywordSegment" => Some(CAST_KEYWORD_SEGMENT.clone()),
            "CastOperatorSegment" => Some(CAST_OPERATOR_SEGMENT.clone()),
            "CatalogKeywordSegment" => Some(CATALOG_KEYWORD_SEGMENT.clone()),
            "CeilKeywordSegment" => Some(CEIL_KEYWORD_SEGMENT.clone()),
            "CeilingKeywordSegment" => Some(CEILING_KEYWORD_SEGMENT.clone()),
            "ChainKeywordSegment" => Some(CHAIN_KEYWORD_SEGMENT.clone()),
            "ChangeKeywordSegment" => Some(CHANGE_KEYWORD_SEGMENT.clone()),
            "CharCharacterSetGrammar" => Some(CHAR_CHARACTER_SET_GRAMMAR.clone()),
            "CharKeywordSegment" => Some(CHAR_KEYWORD_SEGMENT.clone()),
            "CharacterKeywordSegment" => Some(CHARACTER_KEYWORD_SEGMENT.clone()),
            "Character_lengthKeywordSegment" => Some(CHARACTER_LENGTH_KEYWORD_SEGMENT.clone()),
            "Character_set_catalogKeywordSegment" => Some(CHARACTER_SET_CATALOG_KEYWORD_SEGMENT.clone()),
            "Character_set_nameKeywordSegment" => Some(CHARACTER_SET_NAME_KEYWORD_SEGMENT.clone()),
            "Character_set_schemaKeywordSegment" => Some(CHARACTER_SET_SCHEMA_KEYWORD_SEGMENT.clone()),
            "CharacteristicsKeywordSegment" => Some(CHARACTERISTICS_KEYWORD_SEGMENT.clone()),
            "CharactersKeywordSegment" => Some(CHARACTERS_KEYWORD_SEGMENT.clone()),
            "CheckKeywordSegment" => Some(CHECK_KEYWORD_SEGMENT.clone()),
            "CheckedKeywordSegment" => Some(CHECKED_KEYWORD_SEGMENT.clone()),
            "ChrKeywordSegment" => Some(CHR_KEYWORD_SEGMENT.clone()),
            "ClearKeywordSegment" => Some(CLEAR_KEYWORD_SEGMENT.clone()),
            "ClobKeywordSegment" => Some(CLOB_KEYWORD_SEGMENT.clone()),
            "CloseKeywordSegment" => Some(CLOSE_KEYWORD_SEGMENT.clone()),
            "CloseSchemaSegment" => Some(CLOSE_SCHEMA_SEGMENT.clone()),
            "CoalesceKeywordSegment" => Some(COALESCE_KEYWORD_SEGMENT.clone()),
            "CobolKeywordSegment" => Some(COBOL_KEYWORD_SEGMENT.clone()),
            "CodeSegment" => Some(CODE_SEGMENT.clone()),
            "CollateGrammar" => Some(COLLATE_GRAMMAR.clone()),
            "CollateKeywordSegment" => Some(COLLATE_KEYWORD_SEGMENT.clone()),
            "CollationKeywordSegment" => Some(COLLATION_KEYWORD_SEGMENT.clone()),
            "CollationReferenceSegment" => Some(COLLATION_REFERENCE_SEGMENT.clone()),
            "Collation_catalogKeywordSegment" => Some(COLLATION_CATALOG_KEYWORD_SEGMENT.clone()),
            "Collation_nameKeywordSegment" => Some(COLLATION_NAME_KEYWORD_SEGMENT.clone()),
            "Collation_schemaKeywordSegment" => Some(COLLATION_SCHEMA_KEYWORD_SEGMENT.clone()),
            "Cologne_phoneticKeywordSegment" => Some(COLOGNE_PHONETIC_KEYWORD_SEGMENT.clone()),
            "ColonDelimiterSegment" => Some(COLON_DELIMITER_SEGMENT.clone()),
            "ColonPrefixSegment" => Some(COLON_PREFIX_SEGMENT.clone()),
            "ColonSegment" => Some(COLON_SEGMENT.clone()),
            "ColumnConstraintDefaultGrammar" => Some(COLUMN_CONSTRAINT_DEFAULT_GRAMMAR.clone()),
            "ColumnConstraintSegment" => Some(COLUMN_CONSTRAINT_SEGMENT.clone()),
            "ColumnDatatypeSegment" => Some(COLUMN_DATATYPE_SEGMENT.clone()),
            "ColumnDefinitionSegment" => Some(COLUMN_DEFINITION_SEGMENT.clone()),
            "ColumnGeneratedGrammar" => Some(COLUMN_GENERATED_GRAMMAR.clone()),
            "ColumnKeywordSegment" => Some(COLUMN_KEYWORD_SEGMENT.clone()),
            "ColumnReferenceListGrammar" => Some(COLUMN_REFERENCE_LIST_GRAMMAR.clone()),
            "ColumnReferenceSegment" => Some(COLUMN_REFERENCE_SEGMENT.clone()),
            "ColumnsExpressionFunctionContentsSegment" => Some(COLUMNS_EXPRESSION_FUNCTION_CONTENTS_SEGMENT.clone()),
            "ColumnsExpressionFunctionNameSegment" => Some(COLUMNS_EXPRESSION_FUNCTION_NAME_SEGMENT.clone()),
            "ColumnsExpressionGrammar" => Some(COLUMNS_EXPRESSION_GRAMMAR.clone()),
            "ColumnsExpressionNameGrammar" => Some(COLUMNS_EXPRESSION_NAME_GRAMMAR.clone()),
            "CommaSegment" => Some(COMMA_SEGMENT.clone()),
            "CommentClauseSegment" => Some(COMMENT_CLAUSE_SEGMENT.clone()),
            "CommentKeywordSegment" => Some(COMMENT_KEYWORD_SEGMENT.clone()),
            "CommentSegment" => Some(COMMENT_SEGMENT.clone()),
            "CommentStatementSegment" => Some(COMMENT_STATEMENT_SEGMENT.clone()),
            "CommentsKeywordSegment" => Some(COMMENTS_KEYWORD_SEGMENT.clone()),
            "CommitKeywordSegment" => Some(COMMIT_KEYWORD_SEGMENT.clone()),
            "CommittedKeywordSegment" => Some(COMMITTED_KEYWORD_SEGMENT.clone()),
            "ComparisonOperatorGrammar" => Some(COMPARISON_OPERATOR_GRAMMAR.clone()),
            "ComparisonOperatorSegment" => Some(COMPARISON_OPERATOR_SEGMENT.clone()),
            "CompositeBinaryOperatorSegment" => Some(COMPOSITE_BINARY_OPERATOR_SEGMENT.clone()),
            "CompositeComparisonOperatorSegment" => Some(COMPOSITE_COMPARISON_OPERATOR_SEGMENT.clone()),
            "ConcatKeywordSegment" => Some(CONCAT_KEYWORD_SEGMENT.clone()),
            "ConcatSegment" => Some(CONCAT_SEGMENT.clone()),
            "ConditionKeywordSegment" => Some(CONDITION_KEYWORD_SEGMENT.clone()),
            "ConditionalCrossJoinKeywordsGrammar" => Some(CONDITIONAL_CROSS_JOIN_KEYWORDS_GRAMMAR.clone()),
            "ConditionalJoinKeywordsGrammar" => Some(CONDITIONAL_JOIN_KEYWORDS_GRAMMAR.clone()),
            "ConnectByClauseSegment" => Some(CONNECT_BY_CLAUSE_SEGMENT.clone()),
            "ConnectKeywordSegment" => Some(CONNECT_KEYWORD_SEGMENT.clone()),
            "Connect_by_iscycleKeywordSegment" => Some(CONNECT_BY_ISCYCLE_KEYWORD_SEGMENT.clone()),
            "Connect_by_isleafKeywordSegment" => Some(CONNECT_BY_ISLEAF_KEYWORD_SEGMENT.clone()),
            "Connect_by_rootKeywordSegment" => Some(CONNECT_BY_ROOT_KEYWORD_SEGMENT.clone()),
            "ConnectionDefinition" => Some(CONNECTION_DEFINITION.clone()),
            "ConnectionKeywordSegment" => Some(CONNECTION_KEYWORD_SEGMENT.clone()),
            "ConstantKeywordSegment" => Some(CONSTANT_KEYWORD_SEGMENT.clone()),
            "ConstraintKeywordSegment" => Some(CONSTRAINT_KEYWORD_SEGMENT.clone()),
            "Constraint_state_defaultKeywordSegment" => Some(CONSTRAINT_STATE_DEFAULT_KEYWORD_SEGMENT.clone()),
            "ConstraintsKeywordSegment" => Some(CONSTRAINTS_KEYWORD_SEGMENT.clone()),
            "ConstructorKeywordSegment" => Some(CONSTRUCTOR_KEYWORD_SEGMENT.clone()),
            "ConsumerGroupParameterSegment" => Some(CONSUMER_GROUP_PARAMETER_SEGMENT.clone()),
            "ConsumerKeywordSegment" => Some(CONSUMER_KEYWORD_SEGMENT.clone()),
            "Consumer_groupKeywordSegment" => Some(CONSUMER_GROUP_KEYWORD_SEGMENT.clone()),
            "ContainsKeywordSegment" => Some(CONTAINS_KEYWORD_SEGMENT.clone()),
            "ContinueKeywordSegment" => Some(CONTINUE_KEYWORD_SEGMENT.clone()),
            "ControlKeywordSegment" => Some(CONTROL_KEYWORD_SEGMENT.clone()),
            "ConvertKeywordSegment" => Some(CONVERT_KEYWORD_SEGMENT.clone()),
            "Convert_tzKeywordSegment" => Some(CONVERT_TZ_KEYWORD_SEGMENT.clone()),
            "CorrKeywordSegment" => Some(CORR_KEYWORD_SEGMENT.clone()),
            "CorrespondingKeywordSegment" => Some(CORRESPONDING_KEYWORD_SEGMENT.clone()),
            "CosKeywordSegment" => Some(COS_KEYWORD_SEGMENT.clone()),
            "CoshKeywordSegment" => Some(COSH_KEYWORD_SEGMENT.clone()),
            "CotKeywordSegment" => Some(COT_KEYWORD_SEGMENT.clone()),
            "CountKeywordSegment" => Some(COUNT_KEYWORD_SEGMENT.clone()),
            "Covar_popKeywordSegment" => Some(COVAR_POP_KEYWORD_SEGMENT.clone()),
            "Covar_sampKeywordSegment" => Some(COVAR_SAMP_KEYWORD_SEGMENT.clone()),
            "Cpu_weightKeywordSegment" => Some(CPU_WEIGHT_KEYWORD_SEGMENT.clone()),
            "CreateAdapterScriptStatementSegment" => Some(CREATE_ADAPTER_SCRIPT_STATEMENT_SEGMENT.clone()),
            "CreateCastStatementSegment" => Some(CREATE_CAST_STATEMENT_SEGMENT.clone()),
            "CreateConnectionSegment" => Some(CREATE_CONNECTION_SEGMENT.clone()),
            "CreateConsumerGroupSegment" => Some(CREATE_CONSUMER_GROUP_SEGMENT.clone()),
            "CreateDatabaseStatementSegment" => Some(CREATE_DATABASE_STATEMENT_SEGMENT.clone()),
            "CreateFunctionStatementSegment" => Some(CREATE_FUNCTION_STATEMENT_SEGMENT.clone()),
            "CreateIndexStatementSegment" => Some(CREATE_INDEX_STATEMENT_SEGMENT.clone()),
            "CreateKeywordSegment" => Some(CREATE_KEYWORD_SEGMENT.clone()),
            "CreateModelStatementSegment" => Some(CREATE_MODEL_STATEMENT_SEGMENT.clone()),
            "CreateRoleStatementSegment" => Some(CREATE_ROLE_STATEMENT_SEGMENT.clone()),
            "CreateSchemaStatementSegment" => Some(CREATE_SCHEMA_STATEMENT_SEGMENT.clone()),
            "CreateScriptingLuaScriptStatementSegment" => Some(CREATE_SCRIPTING_LUA_SCRIPT_STATEMENT_SEGMENT.clone()),
            "CreateSequenceOptionsSegment" => Some(CREATE_SEQUENCE_OPTIONS_SEGMENT.clone()),
            "CreateSequenceStatementSegment" => Some(CREATE_SEQUENCE_STATEMENT_SEGMENT.clone()),
            "CreateTableLikeClauseSegment" => Some(CREATE_TABLE_LIKE_CLAUSE_SEGMENT.clone()),
            "CreateTableStatementSegment" => Some(CREATE_TABLE_STATEMENT_SEGMENT.clone()),
            "CreateTriggerStatementSegment" => Some(CREATE_TRIGGER_STATEMENT_SEGMENT.clone()),
            "CreateUDFScriptStatementSegment" => Some(CREATE_U_D_F_SCRIPT_STATEMENT_SEGMENT.clone()),
            "CreateUserStatementSegment" => Some(CREATE_USER_STATEMENT_SEGMENT.clone()),
            "CreateViewStatementSegment" => Some(CREATE_VIEW_STATEMENT_SEGMENT.clone()),
            "CreateVirtualSchemaStatementSegment" => Some(CREATE_VIRTUAL_SCHEMA_STATEMENT_SEGMENT.clone()),
            "CreatedKeywordSegment" => Some(CREATED_KEYWORD_SEGMENT.clone()),
            "CrossKeywordSegment" => Some(CROSS_KEYWORD_SEGMENT.clone()),
            "CsKeywordSegment" => Some(CS_KEYWORD_SEGMENT.clone()),
            "CsvKeywordSegment" => Some(CSV_KEYWORD_SEGMENT.clone()),
            "CubeFunctionNameSegment" => Some(CUBE_FUNCTION_NAME_SEGMENT.clone()),
            "CubeKeywordSegment" => Some(CUBE_KEYWORD_SEGMENT.clone()),
            "CubeRollupClauseSegment" => Some(CUBE_ROLLUP_CLAUSE_SEGMENT.clone()),
            "CurdateKeywordSegment" => Some(CURDATE_KEYWORD_SEGMENT.clone()),
            "CurrentKeywordSegment" => Some(CURRENT_KEYWORD_SEGMENT.clone()),
            "Current_dateKeywordSegment" => Some(CURRENT_DATE_KEYWORD_SEGMENT.clone()),
            "Current_pathKeywordSegment" => Some(CURRENT_PATH_KEYWORD_SEGMENT.clone()),
            "Current_roleKeywordSegment" => Some(CURRENT_ROLE_KEYWORD_SEGMENT.clone()),
            "Current_schemaKeywordSegment" => Some(CURRENT_SCHEMA_KEYWORD_SEGMENT.clone()),
            "Current_sessionKeywordSegment" => Some(CURRENT_SESSION_KEYWORD_SEGMENT.clone()),
            "Current_statementKeywordSegment" => Some(CURRENT_STATEMENT_KEYWORD_SEGMENT.clone()),
            "Current_timeKeywordSegment" => Some(CURRENT_TIME_KEYWORD_SEGMENT.clone()),
            "Current_timestampKeywordSegment" => Some(CURRENT_TIMESTAMP_KEYWORD_SEGMENT.clone()),
            "Current_userKeywordSegment" => Some(CURRENT_USER_KEYWORD_SEGMENT.clone()),
            "CursorKeywordSegment" => Some(CURSOR_KEYWORD_SEGMENT.clone()),
            "CycleKeywordSegment" => Some(CYCLE_KEYWORD_SEGMENT.clone()),
            "DataKeywordSegment" => Some(DATA_KEYWORD_SEGMENT.clone()),
            "DatabaseKeywordSegment" => Some(DATABASE_KEYWORD_SEGMENT.clone()),
            "DatabaseReferenceSegment" => Some(DATABASE_REFERENCE_SEGMENT.clone()),
            "DatalinkKeywordSegment" => Some(DATALINK_KEYWORD_SEGMENT.clone()),
            "DatatypeIdentifierSegment" => Some(DATATYPE_IDENTIFIER_SEGMENT.clone()),
            "DatatypeSegment" => Some(DATATYPE_SEGMENT.clone()),
            "DateKeywordSegment" => Some(DATE_KEYWORD_SEGMENT.clone()),
            "DatePartFunctionName" => Some(DATE_PART_FUNCTION_NAME.clone()),
            "DatePartFunctionNameSegment" => Some(DATE_PART_FUNCTION_NAME_SEGMENT.clone()),
            "DateTimeFunctionContentsSegment" => Some(DATE_TIME_FUNCTION_CONTENTS_SEGMENT.clone()),
            "DateTimeLiteralGrammar" => Some(DATE_TIME_LITERAL_GRAMMAR.clone()),
            "Date_truncKeywordSegment" => Some(DATE_TRUNC_KEYWORD_SEGMENT.clone()),
            "DatetimeUnitSegment" => Some(DATETIME_UNIT_SEGMENT.clone()),
            "Datetime_interval_codeKeywordSegment" => Some(DATETIME_INTERVAL_CODE_KEYWORD_SEGMENT.clone()),
            "Datetime_interval_precisionKeywordSegment" => Some(DATETIME_INTERVAL_PRECISION_KEYWORD_SEGMENT.clone()),
            "DayKeywordSegment" => Some(DAY_KEYWORD_SEGMENT.clone()),
            "Days_betweenKeywordSegment" => Some(DAYS_BETWEEN_KEYWORD_SEGMENT.clone()),
            "DbtimezoneKeywordSegment" => Some(DBTIMEZONE_KEYWORD_SEGMENT.clone()),
            "DeallocateKeywordSegment" => Some(DEALLOCATE_KEYWORD_SEGMENT.clone()),
            "DebugKeywordSegment" => Some(DEBUG_KEYWORD_SEGMENT.clone()),
            "DecKeywordSegment" => Some(DEC_KEYWORD_SEGMENT.clone()),
            "DecimalKeywordSegment" => Some(DECIMAL_KEYWORD_SEGMENT.clone()),
            "DeclareKeywordSegment" => Some(DECLARE_KEYWORD_SEGMENT.clone()),
            "DecodeKeywordSegment" => Some(DECODE_KEYWORD_SEGMENT.clone()),
            "Dedent" => Some(DEDENT.clone()),
            "DefaultKeywordSegment" => Some(DEFAULT_KEYWORD_SEGMENT.clone()),
            "DefaultValuesGrammar" => Some(DEFAULT_VALUES_GRAMMAR.clone()),
            "Default_consumer_groupKeywordSegment" => Some(DEFAULT_CONSUMER_GROUP_KEYWORD_SEGMENT.clone()),
            "Default_like_escape_characterKeywordSegment" => Some(DEFAULT_LIKE_ESCAPE_CHARACTER_KEYWORD_SEGMENT.clone()),
            "DefaultsKeywordSegment" => Some(DEFAULTS_KEYWORD_SEGMENT.clone()),
            "DeferrableKeywordSegment" => Some(DEFERRABLE_KEYWORD_SEGMENT.clone()),
            "DeferredKeywordSegment" => Some(DEFERRED_KEYWORD_SEGMENT.clone()),
            "DefinedKeywordSegment" => Some(DEFINED_KEYWORD_SEGMENT.clone()),
            "DefinerKeywordSegment" => Some(DEFINER_KEYWORD_SEGMENT.clone()),
            "DegreesKeywordSegment" => Some(DEGREES_KEYWORD_SEGMENT.clone()),
            "DeleteKeywordSegment" => Some(DELETE_KEYWORD_SEGMENT.clone()),
            "DeleteStatementSegment" => Some(DELETE_STATEMENT_SEGMENT.clone()),
            "DelimitKeywordSegment" => Some(DELIMIT_KEYWORD_SEGMENT.clone()),
            "DelimiterGrammar" => Some(DELIMITER_GRAMMAR.clone()),
            "DelimiterKeywordSegment" => Some(DELIMITER_KEYWORD_SEGMENT.clone()),
            "Dense_rankKeywordSegment" => Some(DENSE_RANK_KEYWORD_SEGMENT.clone()),
            "DepthKeywordSegment" => Some(DEPTH_KEYWORD_SEGMENT.clone()),
            "DerefKeywordSegment" => Some(DEREF_KEYWORD_SEGMENT.clone()),
            "DerivedKeywordSegment" => Some(DERIVED_KEYWORD_SEGMENT.clone()),
            "DescKeywordSegment" => Some(DESC_KEYWORD_SEGMENT.clone()),
            "DescribeKeywordSegment" => Some(DESCRIBE_KEYWORD_SEGMENT.clone()),
            "DescribeStatementSegment" => Some(DESCRIBE_STATEMENT_SEGMENT.clone()),
            "DescriptorKeywordSegment" => Some(DESCRIPTOR_KEYWORD_SEGMENT.clone()),
            "DeterministicKeywordSegment" => Some(DETERMINISTIC_KEYWORD_SEGMENT.clone()),
            "DiagnosticsKeywordSegment" => Some(DIAGNOSTICS_KEYWORD_SEGMENT.clone()),
            "DictionaryKeywordSegment" => Some(DICTIONARY_KEYWORD_SEGMENT.clone()),
            "DisableKeywordSegment" => Some(DISABLE_KEYWORD_SEGMENT.clone()),
            "DisabledKeywordSegment" => Some(DISABLED_KEYWORD_SEGMENT.clone()),
            "DisconnectKeywordSegment" => Some(DISCONNECT_KEYWORD_SEGMENT.clone()),
            "DispatchKeywordSegment" => Some(DISPATCH_KEYWORD_SEGMENT.clone()),
            "DistinctKeywordSegment" => Some(DISTINCT_KEYWORD_SEGMENT.clone()),
            "DistributeKeywordSegment" => Some(DISTRIBUTE_KEYWORD_SEGMENT.clone()),
            "DistributionKeywordSegment" => Some(DISTRIBUTION_KEYWORD_SEGMENT.clone()),
            "DivKeywordSegment" => Some(DIV_KEYWORD_SEGMENT.clone()),
            "DivideSegment" => Some(DIVIDE_SEGMENT.clone()),
            "DlurlcompleteKeywordSegment" => Some(DLURLCOMPLETE_KEYWORD_SEGMENT.clone()),
            "DlurlpathKeywordSegment" => Some(DLURLPATH_KEYWORD_SEGMENT.clone()),
            "DlurlpathonlyKeywordSegment" => Some(DLURLPATHONLY_KEYWORD_SEGMENT.clone()),
            "DlurlschemeKeywordSegment" => Some(DLURLSCHEME_KEYWORD_SEGMENT.clone()),
            "DlurlserverKeywordSegment" => Some(DLURLSERVER_KEYWORD_SEGMENT.clone()),
            "DlvalueKeywordSegment" => Some(DLVALUE_KEYWORD_SEGMENT.clone()),
            "DoKeywordSegment" => Some(DO_KEYWORD_SEGMENT.clone()),
            "DomainKeywordSegment" => Some(DOMAIN_KEYWORD_SEGMENT.clone()),
            "DotSegment" => Some(DOT_SEGMENT.clone()),
            "DoubleKeywordSegment" => Some(DOUBLE_KEYWORD_SEGMENT.clone()),
            "DownKeywordSegment" => Some(DOWN_KEYWORD_SEGMENT.clone()),
            "DriverKeywordSegment" => Some(DRIVER_KEYWORD_SEGMENT.clone()),
            "DropBehaviorGrammar" => Some(DROP_BEHAVIOR_GRAMMAR.clone()),
            "DropCastStatementSegment" => Some(DROP_CAST_STATEMENT_SEGMENT.clone()),
            "DropConnectionStatementSegment" => Some(DROP_CONNECTION_STATEMENT_SEGMENT.clone()),
            "DropConsumerGroupSegment" => Some(DROP_CONSUMER_GROUP_SEGMENT.clone()),
            "DropDatabaseStatementSegment" => Some(DROP_DATABASE_STATEMENT_SEGMENT.clone()),
            "DropFunctionStatementSegment" => Some(DROP_FUNCTION_STATEMENT_SEGMENT.clone()),
            "DropIndexStatementSegment" => Some(DROP_INDEX_STATEMENT_SEGMENT.clone()),
            "DropKeywordSegment" => Some(DROP_KEYWORD_SEGMENT.clone()),
            "DropModelStatementSegment" => Some(DROP_MODEL_STATEMENT_SEGMENT.clone()),
            "DropRoleStatementSegment" => Some(DROP_ROLE_STATEMENT_SEGMENT.clone()),
            "DropSchemaStatementSegment" => Some(DROP_SCHEMA_STATEMENT_SEGMENT.clone()),
            "DropScriptStatementSegment" => Some(DROP_SCRIPT_STATEMENT_SEGMENT.clone()),
            "DropSequenceStatementSegment" => Some(DROP_SEQUENCE_STATEMENT_SEGMENT.clone()),
            "DropTableStatementSegment" => Some(DROP_TABLE_STATEMENT_SEGMENT.clone()),
            "DropTriggerStatementSegment" => Some(DROP_TRIGGER_STATEMENT_SEGMENT.clone()),
            "DropTypeStatementSegment" => Some(DROP_TYPE_STATEMENT_SEGMENT.clone()),
            "DropUserStatementSegment" => Some(DROP_USER_STATEMENT_SEGMENT.clone()),
            "DropViewStatementSegment" => Some(DROP_VIEW_STATEMENT_SEGMENT.clone()),
            "DumpKeywordSegment" => Some(DUMP_KEYWORD_SEGMENT.clone()),
            "DynamicKeywordSegment" => Some(DYNAMIC_KEYWORD_SEGMENT.clone()),
            "Dynamic_functionKeywordSegment" => Some(DYNAMIC_FUNCTION_KEYWORD_SEGMENT.clone()),
            "Dynamic_function_codeKeywordSegment" => Some(DYNAMIC_FUNCTION_CODE_KEYWORD_SEGMENT.clone()),
            "EachKeywordSegment" => Some(EACH_KEYWORD_SEGMENT.clone()),
            "Edit_distanceKeywordSegment" => Some(EDIT_DISTANCE_KEYWORD_SEGMENT.clone()),
            "ElseClauseSegment" => Some(ELSE_CLAUSE_SEGMENT.clone()),
            "ElseKeywordSegment" => Some(ELSE_KEYWORD_SEGMENT.clone()),
            "ElseifKeywordSegment" => Some(ELSEIF_KEYWORD_SEGMENT.clone()),
            "ElsifKeywordSegment" => Some(ELSIF_KEYWORD_SEGMENT.clone()),
            "EmitsKeywordSegment" => Some(EMITS_KEYWORD_SEGMENT.clone()),
            "EmitsSegment" => Some(EMITS_SEGMENT.clone()),
            "EmptyKeywordSegment" => Some(EMPTY_KEYWORD_SEGMENT.clone()),
            "EmptyStructLiteralBracketsSegment" => Some(EMPTY_STRUCT_LITERAL_BRACKETS_SEGMENT.clone()),
            "EmptyStructLiteralSegment" => Some(EMPTY_STRUCT_LITERAL_SEGMENT.clone()),
            "EnableKeywordSegment" => Some(ENABLE_KEYWORD_SEGMENT.clone()),
            "EnabledKeywordSegment" => Some(ENABLED_KEYWORD_SEGMENT.clone()),
            "EncodingKeywordSegment" => Some(ENCODING_KEYWORD_SEGMENT.clone()),
            "End-execKeywordSegment" => Some(END_EXEC_KEYWORD_SEGMENT.clone()),
            "EndBracketSegment" => Some(END_BRACKET_SEGMENT.clone()),
            "EndCurlyBracketSegment" => Some(END_CURLY_BRACKET_SEGMENT.clone()),
            "EndKeywordSegment" => Some(END_KEYWORD_SEGMENT.clone()),
            "EndSquareBracketSegment" => Some(END_SQUARE_BRACKET_SEGMENT.clone()),
            "EndifKeywordSegment" => Some(ENDIF_KEYWORD_SEGMENT.clone()),
            "EnforceKeywordSegment" => Some(ENFORCE_KEYWORD_SEGMENT.clone()),
            "EqualsKeywordSegment" => Some(EQUALS_KEYWORD_SEGMENT.clone()),
            "EqualsSegment" => Some(EQUALS_SEGMENT.clone()),
            "ErrorKeywordSegment" => Some(ERROR_KEYWORD_SEGMENT.clone()),
            "ErrorsKeywordSegment" => Some(ERRORS_KEYWORD_SEGMENT.clone()),
            "EscapeKeywordSegment" => Some(ESCAPE_KEYWORD_SEGMENT.clone()),
            "EscapedIdentifierSegment" => Some(ESCAPED_IDENTIFIER_SEGMENT.clone()),
            "EstimateKeywordSegment" => Some(ESTIMATE_KEYWORD_SEGMENT.clone()),
            "EvaluateKeywordSegment" => Some(EVALUATE_KEYWORD_SEGMENT.clone()),
            "EveryKeywordSegment" => Some(EVERY_KEYWORD_SEGMENT.clone()),
            "ExaKeywordSegment" => Some(EXA_KEYWORD_SEGMENT.clone()),
            "ExceptKeywordSegment" => Some(EXCEPT_KEYWORD_SEGMENT.clone()),
            "ExceptionKeywordSegment" => Some(EXCEPTION_KEYWORD_SEGMENT.clone()),
            "ExcludeKeywordSegment" => Some(EXCLUDE_KEYWORD_SEGMENT.clone()),
            "ExcludingKeywordSegment" => Some(EXCLUDING_KEYWORD_SEGMENT.clone()),
            "ExecKeywordSegment" => Some(EXEC_KEYWORD_SEGMENT.clone()),
            "ExecuteKeywordSegment" => Some(EXECUTE_KEYWORD_SEGMENT.clone()),
            "ExecuteScriptSegment" => Some(EXECUTE_SCRIPT_SEGMENT.clone()),
            "ExistsKeywordSegment" => Some(EXISTS_KEYWORD_SEGMENT.clone()),
            "ExitKeywordSegment" => Some(EXIT_KEYWORD_SEGMENT.clone()),
            "ExpKeywordSegment" => Some(EXP_KEYWORD_SEGMENT.clone()),
            "ExperimentalKeywordSegment" => Some(EXPERIMENTAL_KEYWORD_SEGMENT.clone()),
            "ExpireKeywordSegment" => Some(EXPIRE_KEYWORD_SEGMENT.clone()),
            "ExplainKeywordSegment" => Some(EXPLAIN_KEYWORD_SEGMENT.clone()),
            "ExplainStatementSegment" => Some(EXPLAIN_STATEMENT_SEGMENT.clone()),
            "ExplainVirtualSegment" => Some(EXPLAIN_VIRTUAL_SEGMENT.clone()),
            "ExportIntoClauseSegment" => Some(EXPORT_INTO_CLAUSE_SEGMENT.clone()),
            "ExportKeywordSegment" => Some(EXPORT_KEYWORD_SEGMENT.clone()),
            "ExportStatementSegment" => Some(EXPORT_STATEMENT_SEGMENT.clone()),
            "ExpressionKeywordSegment" => Some(EXPRESSION_KEYWORD_SEGMENT.clone()),
            "ExpressionSegment" => Some(EXPRESSION_SEGMENT.clone()),
            "Expression_A_Grammar" => Some(EXPRESSION_A_GRAMMAR.clone()),
            "Expression_A_Unary_Operator_Grammar" => Some(EXPRESSION_A_UNARY_OPERATOR_GRAMMAR.clone()),
            "Expression_B_Grammar" => Some(EXPRESSION_B_GRAMMAR.clone()),
            "Expression_B_Unary_Operator_Grammar" => Some(EXPRESSION_B_UNARY_OPERATOR_GRAMMAR.clone()),
            "Expression_C_Grammar" => Some(EXPRESSION_C_GRAMMAR.clone()),
            "Expression_D_Grammar" => Some(EXPRESSION_D_GRAMMAR.clone()),
            "Expression_D_Potential_Select_Statement_Without_Brackets" => Some(EXPRESSION_D_POTENTIAL_SELECT_STATEMENT_WITHOUT_BRACKETS.clone()),
            "ExtendedNaturalJoinKeywordsGrammar" => Some(EXTENDED_NATURAL_JOIN_KEYWORDS_GRAMMAR.clone()),
            "ExtensionReferenceSegment" => Some(EXTENSION_REFERENCE_SEGMENT.clone()),
            "ExternalKeywordSegment" => Some(EXTERNAL_KEYWORD_SEGMENT.clone()),
            "ExtractKeywordSegment" => Some(EXTRACT_KEYWORD_SEGMENT.clone()),
            "FBVColumnDefinitionSegment" => Some(F_B_V_COLUMN_DEFINITION_SEGMENT.clone()),
            "FailedKeywordSegment" => Some(FAILED_KEYWORD_SEGMENT.clone()),
            "FalseKeywordSegment" => Some(FALSE_KEYWORD_SEGMENT.clone()),
            "FalseSegment" => Some(FALSE_SEGMENT.clone()),
            "FbvKeywordSegment" => Some(FBV_KEYWORD_SEGMENT.clone()),
            "FetchClauseSegment" => Some(FETCH_CLAUSE_SEGMENT.clone()),
            "FetchKeywordSegment" => Some(FETCH_KEYWORD_SEGMENT.clone()),
            "FileKeywordSegment" => Some(FILE_KEYWORD_SEGMENT.clone()),
            "FileOptionSegment" => Some(FILE_OPTION_SEGMENT.clone()),
            "FileSegment" => Some(FILE_SEGMENT.clone()),
            "FilesKeywordSegment" => Some(FILES_KEYWORD_SEGMENT.clone()),
            "FilterClauseGrammar" => Some(FILTER_CLAUSE_GRAMMAR.clone()),
            "FinalKeywordSegment" => Some(FINAL_KEYWORD_SEGMENT.clone()),
            "FirstKeywordSegment" => Some(FIRST_KEYWORD_SEGMENT.clone()),
            "First_valueKeywordSegment" => Some(FIRST_VALUE_KEYWORD_SEGMENT.clone()),
            "FloatKeywordSegment" => Some(FLOAT_KEYWORD_SEGMENT.clone()),
            "FloorKeywordSegment" => Some(FLOOR_KEYWORD_SEGMENT.clone()),
            "FlushKeywordSegment" => Some(FLUSH_KEYWORD_SEGMENT.clone()),
            "FlushStatisticsSegment" => Some(FLUSH_STATISTICS_SEGMENT.clone()),
            "FollowingKeywordSegment" => Some(FOLLOWING_KEYWORD_SEGMENT.clone()),
            "ForKeywordSegment" => Some(FOR_KEYWORD_SEGMENT.clone()),
            "ForallKeywordSegment" => Some(FORALL_KEYWORD_SEGMENT.clone()),
            "ForceKeywordSegment" => Some(FORCE_KEYWORD_SEGMENT.clone()),
            "ForeignKeyGrammar" => Some(FOREIGN_KEY_GRAMMAR.clone()),
            "ForeignKeyReferencesClauseGrammar" => Some(FOREIGN_KEY_REFERENCES_CLAUSE_GRAMMAR.clone()),
            "ForeignKeywordSegment" => Some(FOREIGN_KEYWORD_SEGMENT.clone()),
            "FormatKeywordSegment" => Some(FORMAT_KEYWORD_SEGMENT.clone()),
            "FortranKeywordSegment" => Some(FORTRAN_KEYWORD_SEGMENT.clone()),
            "FoundKeywordSegment" => Some(FOUND_KEYWORD_SEGMENT.clone()),
            "FrameClauseSegment" => Some(FRAME_CLAUSE_SEGMENT.clone()),
            "FrameClauseUnitGrammar" => Some(FRAME_CLAUSE_UNIT_GRAMMAR.clone()),
            "FreeKeywordSegment" => Some(FREE_KEYWORD_SEGMENT.clone()),
            "FromClauseSegment" => Some(FROM_CLAUSE_SEGMENT.clone()),
            "FromClauseTerminatorGrammar" => Some(FROM_CLAUSE_TERMINATOR_GRAMMAR.clone()),
            "FromExpressionElementSegment" => Some(FROM_EXPRESSION_ELEMENT_SEGMENT.clone()),
            "FromExpressionSegment" => Some(FROM_EXPRESSION_SEGMENT.clone()),
            "FromKeywordSegment" => Some(FROM_KEYWORD_SEGMENT.clone()),
            "From_posix_timeKeywordSegment" => Some(FROM_POSIX_TIME_KEYWORD_SEGMENT.clone()),
            "FsKeywordSegment" => Some(FS_KEYWORD_SEGMENT.clone()),
            "FullKeywordSegment" => Some(FULL_KEYWORD_SEGMENT.clone()),
            "FunctionAssignmentSegment" => Some(FUNCTION_ASSIGNMENT_SEGMENT.clone()),
            "FunctionBodySegment" => Some(FUNCTION_BODY_SEGMENT.clone()),
            "FunctionContentsExpressionGrammar" => Some(FUNCTION_CONTENTS_EXPRESSION_GRAMMAR.clone()),
            "FunctionContentsGrammar" => Some(FUNCTION_CONTENTS_GRAMMAR.clone()),
            "FunctionContentsSegment" => Some(FUNCTION_CONTENTS_SEGMENT.clone()),
            "FunctionDefinitionGrammar" => Some(FUNCTION_DEFINITION_GRAMMAR.clone()),
            "FunctionForLoopSegment" => Some(FUNCTION_FOR_LOOP_SEGMENT.clone()),
            "FunctionIfBranchSegment" => Some(FUNCTION_IF_BRANCH_SEGMENT.clone()),
            "FunctionKeywordSegment" => Some(FUNCTION_KEYWORD_SEGMENT.clone()),
            "FunctionNameIdentifierSegment" => Some(FUNCTION_NAME_IDENTIFIER_SEGMENT.clone()),
            "FunctionNameSegment" => Some(FUNCTION_NAME_SEGMENT.clone()),
            "FunctionParameterGrammar" => Some(FUNCTION_PARAMETER_GRAMMAR.clone()),
            "FunctionParameterListGrammar" => Some(FUNCTION_PARAMETER_LIST_GRAMMAR.clone()),
            "FunctionReferenceSegment" => Some(FUNCTION_REFERENCE_SEGMENT.clone()),
            "FunctionScriptStatementSegment" => Some(FUNCTION_SCRIPT_STATEMENT_SEGMENT.clone()),
            "FunctionScriptTerminatorSegment" => Some(FUNCTION_SCRIPT_TERMINATOR_SEGMENT.clone()),
            "FunctionSegment" => Some(FUNCTION_SEGMENT.clone()),
            "FunctionWhileLoopSegment" => Some(FUNCTION_WHILE_LOOP_SEGMENT.clone()),
            "GeneralKeywordSegment" => Some(GENERAL_KEYWORD_SEGMENT.clone()),
            "GeneratedKeywordSegment" => Some(GENERATED_KEYWORD_SEGMENT.clone()),
            "GeometryKeywordSegment" => Some(GEOMETRY_KEYWORD_SEGMENT.clone()),
            "GetKeywordSegment" => Some(GET_KEYWORD_SEGMENT.clone()),
            "GlobOperatorSegment" => Some(GLOB_OPERATOR_SEGMENT.clone()),
            "GlobalKeywordSegment" => Some(GLOBAL_KEYWORD_SEGMENT.clone()),
            "GoKeywordSegment" => Some(GO_KEYWORD_SEGMENT.clone()),
            "GotoKeywordSegment" => Some(GOTO_KEYWORD_SEGMENT.clone()),
            "GrantKeywordSegment" => Some(GRANT_KEYWORD_SEGMENT.clone()),
            "GrantRevokeConnectionRestrictedSegment" => Some(GRANT_REVOKE_CONNECTION_RESTRICTED_SEGMENT.clone()),
            "GrantRevokeConnectionSegment" => Some(GRANT_REVOKE_CONNECTION_SEGMENT.clone()),
            "GrantRevokeImpersonationSegment" => Some(GRANT_REVOKE_IMPERSONATION_SEGMENT.clone()),
            "GrantRevokeObjectPrivilegesSegment" => Some(GRANT_REVOKE_OBJECT_PRIVILEGES_SEGMENT.clone()),
            "GrantRevokeRolesSegment" => Some(GRANT_REVOKE_ROLES_SEGMENT.clone()),
            "GrantRevokeSystemPrivilegesSegment" => Some(GRANT_REVOKE_SYSTEM_PRIVILEGES_SEGMENT.clone()),
            "GrantedKeywordSegment" => Some(GRANTED_KEYWORD_SEGMENT.clone()),
            "GraphKeywordSegment" => Some(GRAPH_KEYWORD_SEGMENT.clone()),
            "GreaterThanOrEqualToSegment" => Some(GREATER_THAN_OR_EQUAL_TO_SEGMENT.clone()),
            "GreaterThanSegment" => Some(GREATER_THAN_SEGMENT.clone()),
            "GreatestKeywordSegment" => Some(GREATEST_KEYWORD_SEGMENT.clone()),
            "GroupByClauseSegment" => Some(GROUP_BY_CLAUSE_SEGMENT.clone()),
            "GroupByClauseTerminatorGrammar" => Some(GROUP_BY_CLAUSE_TERMINATOR_GRAMMAR.clone()),
            "GroupKeywordSegment" => Some(GROUP_KEYWORD_SEGMENT.clone()),
            "Group_concatKeywordSegment" => Some(GROUP_CONCAT_KEYWORD_SEGMENT.clone()),
            "Group_temp_db_ram_limitKeywordSegment" => Some(GROUP_TEMP_DB_RAM_LIMIT_KEYWORD_SEGMENT.clone()),
            "GroupingExpressionList" => Some(GROUPING_EXPRESSION_LIST.clone()),
            "GroupingKeywordSegment" => Some(GROUPING_KEYWORD_SEGMENT.clone()),
            "GroupingSetsClauseSegment" => Some(GROUPING_SETS_CLAUSE_SEGMENT.clone()),
            "Grouping_idKeywordSegment" => Some(GROUPING_ID_KEYWORD_SEGMENT.clone()),
            "GroupsKeywordSegment" => Some(GROUPS_KEYWORD_SEGMENT.clone()),
            "HandlerKeywordSegment" => Some(HANDLER_KEYWORD_SEGMENT.clone()),
            "HasKeywordSegment" => Some(HAS_KEYWORD_SEGMENT.clone()),
            "HashKeywordSegment" => Some(HASH_KEYWORD_SEGMENT.clone()),
            "Hash_md5KeywordSegment" => Some(HASH_MD5_KEYWORD_SEGMENT.clone()),
            "Hash_sha1KeywordSegment" => Some(HASH_SHA1_KEYWORD_SEGMENT.clone()),
            "Hash_sha256KeywordSegment" => Some(HASH_SHA256_KEYWORD_SEGMENT.clone()),
            "Hash_sha512KeywordSegment" => Some(HASH_SHA512_KEYWORD_SEGMENT.clone()),
            "Hash_shaKeywordSegment" => Some(HASH_SHA_KEYWORD_SEGMENT.clone()),
            "Hash_tigerKeywordSegment" => Some(HASH_TIGER_KEYWORD_SEGMENT.clone()),
            "HashtypeKeywordSegment" => Some(HASHTYPE_KEYWORD_SEGMENT.clone()),
            "Hashtype_formatKeywordSegment" => Some(HASHTYPE_FORMAT_KEYWORD_SEGMENT.clone()),
            "Hashtype_md5KeywordSegment" => Some(HASHTYPE_MD5_KEYWORD_SEGMENT.clone()),
            "Hashtype_sha1KeywordSegment" => Some(HASHTYPE_SHA1_KEYWORD_SEGMENT.clone()),
            "Hashtype_sha256KeywordSegment" => Some(HASHTYPE_SHA256_KEYWORD_SEGMENT.clone()),
            "Hashtype_sha512KeywordSegment" => Some(HASHTYPE_SHA512_KEYWORD_SEGMENT.clone()),
            "Hashtype_shaKeywordSegment" => Some(HASHTYPE_SHA_KEYWORD_SEGMENT.clone()),
            "Hashtype_tigerKeywordSegment" => Some(HASHTYPE_TIGER_KEYWORD_SEGMENT.clone()),
            "HavingClauseSegment" => Some(HAVING_CLAUSE_SEGMENT.clone()),
            "HavingClauseTerminatorGrammar" => Some(HAVING_CLAUSE_TERMINATOR_GRAMMAR.clone()),
            "HavingKeywordSegment" => Some(HAVING_KEYWORD_SEGMENT.clone()),
            "HierarchyKeywordSegment" => Some(HIERARCHY_KEYWORD_SEGMENT.clone()),
            "HighKeywordSegment" => Some(HIGH_KEYWORD_SEGMENT.clone()),
            "HoldKeywordSegment" => Some(HOLD_KEYWORD_SEGMENT.clone()),
            "HorizontalJoinKeywordsGrammar" => Some(HORIZONTAL_JOIN_KEYWORDS_GRAMMAR.clone()),
            "HourKeywordSegment" => Some(HOUR_KEYWORD_SEGMENT.clone()),
            "Hours_betweenKeywordSegment" => Some(HOURS_BETWEEN_KEYWORD_SEGMENT.clone()),
            "IdentifiedKeywordSegment" => Some(IDENTIFIED_KEYWORD_SEGMENT.clone()),
            "IdentifierSegment" => Some(IDENTIFIER_SEGMENT.clone()),
            "IdentityKeywordSegment" => Some(IDENTITY_KEYWORD_SEGMENT.clone()),
            "Idle_timeoutKeywordSegment" => Some(IDLE_TIMEOUT_KEYWORD_SEGMENT.clone()),
            "IfExistsGrammar" => Some(IF_EXISTS_GRAMMAR.clone()),
            "IfKeywordSegment" => Some(IF_KEYWORD_SEGMENT.clone()),
            "IfNotExistsGrammar" => Some(IF_NOT_EXISTS_GRAMMAR.clone()),
            "IfnullKeywordSegment" => Some(IFNULL_KEYWORD_SEGMENT.clone()),
            "IgnoreKeywordSegment" => Some(IGNORE_KEYWORD_SEGMENT.clone()),
            "IgnoreRespectNullsGrammar" => Some(IGNORE_RESPECT_NULLS_GRAMMAR.clone()),
            "ImmediateKeywordSegment" => Some(IMMEDIATE_KEYWORD_SEGMENT.clone()),
            "ImpersonateKeywordSegment" => Some(IMPERSONATE_KEYWORD_SEGMENT.clone()),
            "ImpersonateSegment" => Some(IMPERSONATE_SEGMENT.clone()),
            "ImpersonationKeywordSegment" => Some(IMPERSONATION_KEYWORD_SEGMENT.clone()),
            "ImplementationKeywordSegment" => Some(IMPLEMENTATION_KEYWORD_SEGMENT.clone()),
            "ImplicitIndent" => Some(IMPLICIT_INDENT.clone()),
            "ImportColumnsSegment" => Some(IMPORT_COLUMNS_SEGMENT.clone()),
            "ImportErrorDestinationSegment" => Some(IMPORT_ERROR_DESTINATION_SEGMENT.clone()),
            "ImportErrorsClauseSegment" => Some(IMPORT_ERRORS_CLAUSE_SEGMENT.clone()),
            "ImportFromClauseSegment" => Some(IMPORT_FROM_CLAUSE_SEGMENT.clone()),
            "ImportFromExportIntoDbSrcSegment" => Some(IMPORT_FROM_EXPORT_INTO_DB_SRC_SEGMENT.clone()),
            "ImportFromExportIntoFileSegment" => Some(IMPORT_FROM_EXPORT_INTO_FILE_SEGMENT.clone()),
            "ImportFromExportIntoScriptSegment" => Some(IMPORT_FROM_EXPORT_INTO_SCRIPT_SEGMENT.clone()),
            "ImportKeywordSegment" => Some(IMPORT_KEYWORD_SEGMENT.clone()),
            "ImportStatementSegment" => Some(IMPORT_STATEMENT_SEGMENT.clone()),
            "InKeywordSegment" => Some(IN_KEYWORD_SEGMENT.clone()),
            "InOperatorGrammar" => Some(IN_OPERATOR_GRAMMAR.clone()),
            "IncludingKeywordSegment" => Some(INCLUDING_KEYWORD_SEGMENT.clone()),
            "Indent" => Some(INDENT.clone()),
            "IndexColumnDefinitionSegment" => Some(INDEX_COLUMN_DEFINITION_SEGMENT.clone()),
            "IndexKeywordSegment" => Some(INDEX_KEYWORD_SEGMENT.clone()),
            "IndexReferenceSegment" => Some(INDEX_REFERENCE_SEGMENT.clone()),
            "IndicatorKeywordSegment" => Some(INDICATOR_KEYWORD_SEGMENT.clone()),
            "InitcapKeywordSegment" => Some(INITCAP_KEYWORD_SEGMENT.clone()),
            "InitiallyKeywordSegment" => Some(INITIALLY_KEYWORD_SEGMENT.clone()),
            "InnerKeywordSegment" => Some(INNER_KEYWORD_SEGMENT.clone()),
            "InoutKeywordSegment" => Some(INOUT_KEYWORD_SEGMENT.clone()),
            "InputKeywordSegment" => Some(INPUT_KEYWORD_SEGMENT.clone()),
            "InsensitiveKeywordSegment" => Some(INSENSITIVE_KEYWORD_SEGMENT.clone()),
            "InsertKeywordSegment" => Some(INSERT_KEYWORD_SEGMENT.clone()),
            "InsertStatementSegment" => Some(INSERT_STATEMENT_SEGMENT.clone()),
            "InstanceKeywordSegment" => Some(INSTANCE_KEYWORD_SEGMENT.clone()),
            "InstantiableKeywordSegment" => Some(INSTANTIABLE_KEYWORD_SEGMENT.clone()),
            "InstrKeywordSegment" => Some(INSTR_KEYWORD_SEGMENT.clone()),
            "IntKeywordSegment" => Some(INT_KEYWORD_SEGMENT.clone()),
            "IntegerKeywordSegment" => Some(INTEGER_KEYWORD_SEGMENT.clone()),
            "IntegrityKeywordSegment" => Some(INTEGRITY_KEYWORD_SEGMENT.clone()),
            "IntersectKeywordSegment" => Some(INTERSECT_KEYWORD_SEGMENT.clone()),
            "IntervalExpressionSegment" => Some(INTERVAL_EXPRESSION_SEGMENT.clone()),
            "IntervalKeywordSegment" => Some(INTERVAL_KEYWORD_SEGMENT.clone()),
            "IntoKeywordSegment" => Some(INTO_KEYWORD_SEGMENT.clone()),
            "IntoTableSegment" => Some(INTO_TABLE_SEGMENT.clone()),
            "InvalidKeywordSegment" => Some(INVALID_KEYWORD_SEGMENT.clone()),
            "InverseKeywordSegment" => Some(INVERSE_KEYWORD_SEGMENT.clone()),
            "InvokerKeywordSegment" => Some(INVOKER_KEYWORD_SEGMENT.clone()),
            "IprocKeywordSegment" => Some(IPROC_KEYWORD_SEGMENT.clone()),
            "IsClauseGrammar" => Some(IS_CLAUSE_GRAMMAR.clone()),
            "IsDistinctFromGrammar" => Some(IS_DISTINCT_FROM_GRAMMAR.clone()),
            "IsKeywordSegment" => Some(IS_KEYWORD_SEGMENT.clone()),
            "IsNullGrammar" => Some(IS_NULL_GRAMMAR.clone()),
            "Is_booleanKeywordSegment" => Some(IS_BOOLEAN_KEYWORD_SEGMENT.clone()),
            "Is_dateKeywordSegment" => Some(IS_DATE_KEYWORD_SEGMENT.clone()),
            "Is_dsintervalKeywordSegment" => Some(IS_DSINTERVAL_KEYWORD_SEGMENT.clone()),
            "Is_numberKeywordSegment" => Some(IS_NUMBER_KEYWORD_SEGMENT.clone()),
            "Is_timestampKeywordSegment" => Some(IS_TIMESTAMP_KEYWORD_SEGMENT.clone()),
            "Is_ymintervalKeywordSegment" => Some(IS_YMINTERVAL_KEYWORD_SEGMENT.clone()),
            "IsolationKeywordSegment" => Some(ISOLATION_KEYWORD_SEGMENT.clone()),
            "IterateKeywordSegment" => Some(ITERATE_KEYWORD_SEGMENT.clone()),
            "JavaKeywordSegment" => Some(JAVA_KEYWORD_SEGMENT.clone()),
            "JavascriptKeywordSegment" => Some(JAVASCRIPT_KEYWORD_SEGMENT.clone()),
            "JdbcKeywordSegment" => Some(JDBC_KEYWORD_SEGMENT.clone()),
            "JoinClauseSegment" => Some(JOIN_CLAUSE_SEGMENT.clone()),
            "JoinKeywordSegment" => Some(JOIN_KEYWORD_SEGMENT.clone()),
            "JoinKeywordsGrammar" => Some(JOIN_KEYWORDS_GRAMMAR.clone()),
            "JoinLikeClauseGrammar" => Some(JOIN_LIKE_CLAUSE_GRAMMAR.clone()),
            "JoinOnConditionSegment" => Some(JOIN_ON_CONDITION_SEGMENT.clone()),
            "JoinTypeKeywordsGrammar" => Some(JOIN_TYPE_KEYWORDS_GRAMMAR.clone()),
            "JoinUsingConditionGrammar" => Some(JOIN_USING_CONDITION_GRAMMAR.clone()),
            "JsonKeywordSegment" => Some(JSON_KEYWORD_SEGMENT.clone()),
            "Json_extractKeywordSegment" => Some(JSON_EXTRACT_KEYWORD_SEGMENT.clone()),
            "Json_valueKeywordSegment" => Some(JSON_VALUE_KEYWORD_SEGMENT.clone()),
            "KeepKeywordSegment" => Some(KEEP_KEYWORD_SEGMENT.clone()),
            "KerberosKeywordSegment" => Some(KERBEROS_KEYWORD_SEGMENT.clone()),
            "KeyKeywordSegment" => Some(KEY_KEYWORD_SEGMENT.clone()),
            "Key_memberKeywordSegment" => Some(KEY_MEMBER_KEYWORD_SEGMENT.clone()),
            "Key_typeKeywordSegment" => Some(KEY_TYPE_KEYWORD_SEGMENT.clone()),
            "KeysKeywordSegment" => Some(KEYS_KEYWORD_SEGMENT.clone()),
            "KeywordSegment" => Some(KEYWORD_SEGMENT.clone()),
            "KillKeywordSegment" => Some(KILL_KEYWORD_SEGMENT.clone()),
            "KillSegment" => Some(KILL_SEGMENT.clone()),
            "LagKeywordSegment" => Some(LAG_KEYWORD_SEGMENT.clone()),
            "LanguageKeywordSegment" => Some(LANGUAGE_KEYWORD_SEGMENT.clone()),
            "LargeKeywordSegment" => Some(LARGE_KEYWORD_SEGMENT.clone()),
            "LastKeywordSegment" => Some(LAST_KEYWORD_SEGMENT.clone()),
            "Last_valueKeywordSegment" => Some(LAST_VALUE_KEYWORD_SEGMENT.clone()),
            "LateralKeywordSegment" => Some(LATERAL_KEYWORD_SEGMENT.clone()),
            "LcaseKeywordSegment" => Some(LCASE_KEYWORD_SEGMENT.clone()),
            "LdapKeywordSegment" => Some(LDAP_KEYWORD_SEGMENT.clone()),
            "LeadKeywordSegment" => Some(LEAD_KEYWORD_SEGMENT.clone()),
            "LeadingKeywordSegment" => Some(LEADING_KEYWORD_SEGMENT.clone()),
            "LeastKeywordSegment" => Some(LEAST_KEYWORD_SEGMENT.clone()),
            "LeaveKeywordSegment" => Some(LEAVE_KEYWORD_SEGMENT.clone()),
            "LeftKeywordSegment" => Some(LEFT_KEYWORD_SEGMENT.clone()),
            "LengthKeywordSegment" => Some(LENGTH_KEYWORD_SEGMENT.clone()),
            "LessThanOrEqualToSegment" => Some(LESS_THAN_OR_EQUAL_TO_SEGMENT.clone()),
            "LessThanSegment" => Some(LESS_THAN_SEGMENT.clone()),
            "LevelKeywordSegment" => Some(LEVEL_KEYWORD_SEGMENT.clone()),
            "LikeExpressionGrammar" => Some(LIKE_EXPRESSION_GRAMMAR.clone()),
            "LikeGrammar" => Some(LIKE_GRAMMAR.clone()),
            "LikeKeywordSegment" => Some(LIKE_KEYWORD_SEGMENT.clone()),
            "LikeOperatorSegment" => Some(LIKE_OPERATOR_SEGMENT.clone()),
            "LimitClauseSegment" => Some(LIMIT_CLAUSE_SEGMENT.clone()),
            "LimitKeywordSegment" => Some(LIMIT_KEYWORD_SEGMENT.clone()),
            "LinkKeywordSegment" => Some(LINK_KEYWORD_SEGMENT.clone()),
            "ListComprehensionGrammar" => Some(LIST_COMPREHENSION_GRAMMAR.clone()),
            "ListaggKeywordSegment" => Some(LISTAGG_KEYWORD_SEGMENT.clone()),
            "LiteralGrammar" => Some(LITERAL_GRAMMAR.clone()),
            "LiteralKeywordSegment" => Some(LITERAL_KEYWORD_SEGMENT.clone()),
            "LiteralSegment" => Some(LITERAL_SEGMENT.clone()),
            "LnKeywordSegment" => Some(LN_KEYWORD_SEGMENT.clone()),
            "LocalAliasSegment" => Some(LOCAL_ALIAS_SEGMENT.clone()),
            "LocalKeywordSegment" => Some(LOCAL_KEYWORD_SEGMENT.clone()),
            "LocaltimeKeywordSegment" => Some(LOCALTIME_KEYWORD_SEGMENT.clone()),
            "LocaltimestampKeywordSegment" => Some(LOCALTIMESTAMP_KEYWORD_SEGMENT.clone()),
            "LocateKeywordSegment" => Some(LOCATE_KEYWORD_SEGMENT.clone()),
            "LocatorKeywordSegment" => Some(LOCATOR_KEYWORD_SEGMENT.clone()),
            "LockKeywordSegment" => Some(LOCK_KEYWORD_SEGMENT.clone()),
            "Log10KeywordSegment" => Some(LOG10_KEYWORD_SEGMENT.clone()),
            "Log2KeywordSegment" => Some(LOG2_KEYWORD_SEGMENT.clone()),
            "LogKeywordSegment" => Some(LOG_KEYWORD_SEGMENT.clone()),
            "LoginKeywordSegment" => Some(LOGIN_KEYWORD_SEGMENT.clone()),
            "LogsKeywordSegment" => Some(LOGS_KEYWORD_SEGMENT.clone()),
            "LongKeywordSegment" => Some(LONG_KEYWORD_SEGMENT.clone()),
            "LongvarcharKeywordSegment" => Some(LONGVARCHAR_KEYWORD_SEGMENT.clone()),
            "LoopKeywordSegment" => Some(LOOP_KEYWORD_SEGMENT.clone()),
            "LowKeywordSegment" => Some(LOW_KEYWORD_SEGMENT.clone()),
            "LowerKeywordSegment" => Some(LOWER_KEYWORD_SEGMENT.clone()),
            "LpadKeywordSegment" => Some(LPAD_KEYWORD_SEGMENT.clone()),
            "LtrimKeywordSegment" => Some(LTRIM_KEYWORD_SEGMENT.clone()),
            "LuaKeywordSegment" => Some(LUA_KEYWORD_SEGMENT.clone()),
            "MLTableExpressionSegment" => Some(M_L_TABLE_EXPRESSION_SEGMENT.clone()),
            "ManageKeywordSegment" => Some(MANAGE_KEYWORD_SEGMENT.clone()),
            "MapKeywordSegment" => Some(MAP_KEYWORD_SEGMENT.clone()),
            "MapTypeSegment" => Some(MAP_TYPE_SEGMENT.clone()),
            "MatchConditionSegment" => Some(MATCH_CONDITION_SEGMENT.clone()),
            "MatchKeywordSegment" => Some(MATCH_KEYWORD_SEGMENT.clone()),
            "MatchedKeywordSegment" => Some(MATCHED_KEYWORD_SEGMENT.clone()),
            "MaxKeywordSegment" => Some(MAX_KEYWORD_SEGMENT.clone()),
            "MaximalKeywordSegment" => Some(MAXIMAL_KEYWORD_SEGMENT.clone()),
            "MedianKeywordSegment" => Some(MEDIAN_KEYWORD_SEGMENT.clone()),
            "MergeDeleteClauseSegment" => Some(MERGE_DELETE_CLAUSE_SEGMENT.clone()),
            "MergeInsertClauseSegment" => Some(MERGE_INSERT_CLAUSE_SEGMENT.clone()),
            "MergeIntoLiteralGrammar" => Some(MERGE_INTO_LITERAL_GRAMMAR.clone()),
            "MergeKeywordSegment" => Some(MERGE_KEYWORD_SEGMENT.clone()),
            "MergeMatchSegment" => Some(MERGE_MATCH_SEGMENT.clone()),
            "MergeMatchedClauseSegment" => Some(MERGE_MATCHED_CLAUSE_SEGMENT.clone()),
            "MergeNotMatchedClauseSegment" => Some(MERGE_NOT_MATCHED_CLAUSE_SEGMENT.clone()),
            "MergeStatementSegment" => Some(MERGE_STATEMENT_SEGMENT.clone()),
            "MergeUpdateClauseSegment" => Some(MERGE_UPDATE_CLAUSE_SEGMENT.clone()),
            "MessageKeywordSegment" => Some(MESSAGE_KEYWORD_SEGMENT.clone()),
            "MethodKeywordSegment" => Some(METHOD_KEYWORD_SEGMENT.clone()),
            "MidKeywordSegment" => Some(MID_KEYWORD_SEGMENT.clone()),
            "MinKeywordSegment" => Some(MIN_KEYWORD_SEGMENT.clone()),
            "Min_scaleKeywordSegment" => Some(MIN_SCALE_KEYWORD_SEGMENT.clone()),
            "MinusKeywordSegment" => Some(MINUS_KEYWORD_SEGMENT.clone()),
            "MinusSegment" => Some(MINUS_SEGMENT.clone()),
            "MinuteKeywordSegment" => Some(MINUTE_KEYWORD_SEGMENT.clone()),
            "Minutes_betweenKeywordSegment" => Some(MINUTES_BETWEEN_KEYWORD_SEGMENT.clone()),
            "ModKeywordSegment" => Some(MOD_KEYWORD_SEGMENT.clone()),
            "ModifiesKeywordSegment" => Some(MODIFIES_KEYWORD_SEGMENT.clone()),
            "ModifyKeywordSegment" => Some(MODIFY_KEYWORD_SEGMENT.clone()),
            "ModuleKeywordSegment" => Some(MODULE_KEYWORD_SEGMENT.clone()),
            "ModuloSegment" => Some(MODULO_SEGMENT.clone()),
            "MonthKeywordSegment" => Some(MONTH_KEYWORD_SEGMENT.clone()),
            "Months_betweenKeywordSegment" => Some(MONTHS_BETWEEN_KEYWORD_SEGMENT.clone()),
            "MulKeywordSegment" => Some(MUL_KEYWORD_SEGMENT.clone()),
            "MultipleKeywordSegment" => Some(MULTIPLE_KEYWORD_SEGMENT.clone()),
            "MultiplySegment" => Some(MULTIPLY_SEGMENT.clone()),
            "MumpsKeywordSegment" => Some(MUMPS_KEYWORD_SEGMENT.clone()),
            "NakedIdentifierSegment" => Some(NAKED_IDENTIFIER_SEGMENT.clone()),
            "NamedWindowExpressionSegment" => Some(NAMED_WINDOW_EXPRESSION_SEGMENT.clone()),
            "NamedWindowSegment" => Some(NAMED_WINDOW_SEGMENT.clone()),
            "NamesKeywordSegment" => Some(NAMES_KEYWORD_SEGMENT.clone()),
            "NanLiteralSegment" => Some(NAN_LITERAL_SEGMENT.clone()),
            "NationalKeywordSegment" => Some(NATIONAL_KEYWORD_SEGMENT.clone()),
            "NaturalJoinKeywordsGrammar" => Some(NATURAL_JOIN_KEYWORDS_GRAMMAR.clone()),
            "NaturalKeywordSegment" => Some(NATURAL_KEYWORD_SEGMENT.clone()),
            "NcharKeywordSegment" => Some(NCHAR_KEYWORD_SEGMENT.clone()),
            "NclobKeywordSegment" => Some(NCLOB_KEYWORD_SEGMENT.clone()),
            "NegativeSegment" => Some(NEGATIVE_SEGMENT.clone()),
            "NestedJoinGrammar" => Some(NESTED_JOIN_GRAMMAR.clone()),
            "NeverKeywordSegment" => Some(NEVER_KEYWORD_SEGMENT.clone()),
            "NewKeywordSegment" => Some(NEW_KEYWORD_SEGMENT.clone()),
            "NewlineSegment" => Some(NEWLINE_SEGMENT.clone()),
            "NextKeywordSegment" => Some(NEXT_KEYWORD_SEGMENT.clone()),
            "NiceKeywordSegment" => Some(NICE_KEYWORD_SEGMENT.clone()),
            "Nls_date_formatKeywordSegment" => Some(NLS_DATE_FORMAT_KEYWORD_SEGMENT.clone()),
            "Nls_date_languageKeywordSegment" => Some(NLS_DATE_LANGUAGE_KEYWORD_SEGMENT.clone()),
            "Nls_first_day_of_weekKeywordSegment" => Some(NLS_FIRST_DAY_OF_WEEK_KEYWORD_SEGMENT.clone()),
            "Nls_numeric_charactersKeywordSegment" => Some(NLS_NUMERIC_CHARACTERS_KEYWORD_SEGMENT.clone()),
            "Nls_timestamp_formatKeywordSegment" => Some(NLS_TIMESTAMP_FORMAT_KEYWORD_SEGMENT.clone()),
            "NoKeywordSegment" => Some(NO_KEYWORD_SEGMENT.clone()),
            "NocycleKeywordSegment" => Some(NOCYCLE_KEYWORD_SEGMENT.clone()),
            "NologgingKeywordSegment" => Some(NOLOGGING_KEYWORD_SEGMENT.clone()),
            "NonSetSelectableGrammar" => Some(NON_SET_SELECTABLE_GRAMMAR.clone()),
            "NonStandardJoinTypeKeywordsGrammar" => Some(NON_STANDARD_JOIN_TYPE_KEYWORDS_GRAMMAR.clone()),
            "NonWithNonSelectableGrammar" => Some(NON_WITH_NON_SELECTABLE_GRAMMAR.clone()),
            "NonWithSelectableGrammar" => Some(NON_WITH_SELECTABLE_GRAMMAR.clone()),
            "NoneKeywordSegment" => Some(NONE_KEYWORD_SEGMENT.clone()),
            "NormalizedGrammar" => Some(NORMALIZED_GRAMMAR.clone()),
            "NormalizedKeywordSegment" => Some(NORMALIZED_KEYWORD_SEGMENT.clone()),
            "NotEnforcedGrammar" => Some(NOT_ENFORCED_GRAMMAR.clone()),
            "NotEqualToSegment" => Some(NOT_EQUAL_TO_SEGMENT.clone()),
            "NotKeywordSegment" => Some(NOT_KEYWORD_SEGMENT.clone()),
            "NotNullGrammar" => Some(NOT_NULL_GRAMMAR.clone()),
            "NotOperatorGrammar" => Some(NOT_OPERATOR_GRAMMAR.clone()),
            "NoticeKeywordSegment" => Some(NOTICE_KEYWORD_SEGMENT.clone()),
            "NowKeywordSegment" => Some(NOW_KEYWORD_SEGMENT.clone()),
            "NprocKeywordSegment" => Some(NPROC_KEYWORD_SEGMENT.clone()),
            "NullKeywordSegment" => Some(NULL_KEYWORD_SEGMENT.clone()),
            "NullLiteralSegment" => Some(NULL_LITERAL_SEGMENT.clone()),
            "NullifKeywordSegment" => Some(NULLIF_KEYWORD_SEGMENT.clone()),
            "NullifzeroKeywordSegment" => Some(NULLIFZERO_KEYWORD_SEGMENT.clone()),
            "NullsKeywordSegment" => Some(NULLS_KEYWORD_SEGMENT.clone()),
            "NumberKeywordSegment" => Some(NUMBER_KEYWORD_SEGMENT.clone()),
            "NumericKeywordSegment" => Some(NUMERIC_KEYWORD_SEGMENT.clone()),
            "NumericLiteralSegment" => Some(NUMERIC_LITERAL_SEGMENT.clone()),
            "NumtodsintervalKeywordSegment" => Some(NUMTODSINTERVAL_KEYWORD_SEGMENT.clone()),
            "NumtoymintervalKeywordSegment" => Some(NUMTOYMINTERVAL_KEYWORD_SEGMENT.clone()),
            "Nvarchar2KeywordSegment" => Some(NVARCHAR2_KEYWORD_SEGMENT.clone()),
            "NvarcharKeywordSegment" => Some(NVARCHAR_KEYWORD_SEGMENT.clone()),
            "Nvl2KeywordSegment" => Some(NVL2_KEYWORD_SEGMENT.clone()),
            "NvlKeywordSegment" => Some(NVL_KEYWORD_SEGMENT.clone()),
            "ObjectKeywordSegment" => Some(OBJECT_KEYWORD_SEGMENT.clone()),
            "ObjectLiteralElementSegment" => Some(OBJECT_LITERAL_ELEMENT_SEGMENT.clone()),
            "ObjectLiteralSegment" => Some(OBJECT_LITERAL_SEGMENT.clone()),
            "ObjectPrivilegesSegment" => Some(OBJECT_PRIVILEGES_SEGMENT.clone()),
            "ObjectReferenceDelimiterGrammar" => Some(OBJECT_REFERENCE_DELIMITER_GRAMMAR.clone()),
            "ObjectReferenceSegment" => Some(OBJECT_REFERENCE_SEGMENT.clone()),
            "ObjectReferenceTerminatorGrammar" => Some(OBJECT_REFERENCE_TERMINATOR_GRAMMAR.clone()),
            "ObjectsKeywordSegment" => Some(OBJECTS_KEYWORD_SEGMENT.clone()),
            "Octet_lengthKeywordSegment" => Some(OCTET_LENGTH_KEYWORD_SEGMENT.clone()),
            "OctetsKeywordSegment" => Some(OCTETS_KEYWORD_SEGMENT.clone()),
            "OfKeywordSegment" => Some(OF_KEYWORD_SEGMENT.clone()),
            "OffKeywordSegment" => Some(OFF_KEYWORD_SEGMENT.clone()),
            "OffsetClauseSegment" => Some(OFFSET_CLAUSE_SEGMENT.clone()),
            "OffsetKeywordSegment" => Some(OFFSET_KEYWORD_SEGMENT.clone()),
            "OldKeywordSegment" => Some(OLD_KEYWORD_SEGMENT.clone()),
            "OnKeywordSegment" => Some(ON_KEYWORD_SEGMENT.clone()),
            "OnlyKeywordSegment" => Some(ONLY_KEYWORD_SEGMENT.clone()),
            "OpenKeywordSegment" => Some(OPEN_KEYWORD_SEGMENT.clone()),
            "OpenSchemaSegment" => Some(OPEN_SCHEMA_SEGMENT.clone()),
            "OpenidKeywordSegment" => Some(OPENID_KEYWORD_SEGMENT.clone()),
            "OptimizeKeywordSegment" => Some(OPTIMIZE_KEYWORD_SEGMENT.clone()),
            "OptimizerKeywordSegment" => Some(OPTIMIZER_KEYWORD_SEGMENT.clone()),
            "OptionKeywordSegment" => Some(OPTION_KEYWORD_SEGMENT.clone()),
            "OptionsKeywordSegment" => Some(OPTIONS_KEYWORD_SEGMENT.clone()),
            "OrKeywordSegment" => Some(OR_KEYWORD_SEGMENT.clone()),
            "OrOperatorGrammar" => Some(OR_OPERATOR_GRAMMAR.clone()),
            "OrReplaceGrammar" => Some(OR_REPLACE_GRAMMAR.clone()),
            "OraKeywordSegment" => Some(ORA_KEYWORD_SEGMENT.clone()),
            "OrderByClauseSegment" => Some(ORDER_BY_CLAUSE_SEGMENT.clone()),
            "OrderByClauseTerminators" => Some(ORDER_BY_CLAUSE_TERMINATORS.clone()),
            "OrderKeywordSegment" => Some(ORDER_KEYWORD_SEGMENT.clone()),
            "OrderNoOrderGrammar" => Some(ORDER_NO_ORDER_GRAMMAR.clone()),
            "OrderingKeywordSegment" => Some(ORDERING_KEYWORD_SEGMENT.clone()),
            "OrdinalityKeywordSegment" => Some(ORDINALITY_KEYWORD_SEGMENT.clone()),
            "OthersKeywordSegment" => Some(OTHERS_KEYWORD_SEGMENT.clone()),
            "OutKeywordSegment" => Some(OUT_KEYWORD_SEGMENT.clone()),
            "OuterKeywordSegment" => Some(OUTER_KEYWORD_SEGMENT.clone()),
            "OutputKeywordSegment" => Some(OUTPUT_KEYWORD_SEGMENT.clone()),
            "OverClauseSegment" => Some(OVER_CLAUSE_SEGMENT.clone()),
            "OverKeywordSegment" => Some(OVER_KEYWORD_SEGMENT.clone()),
            "OverflowKeywordSegment" => Some(OVERFLOW_KEYWORD_SEGMENT.clone()),
            "OverlapsClauseSegment" => Some(OVERLAPS_CLAUSE_SEGMENT.clone()),
            "OverlapsKeywordSegment" => Some(OVERLAPS_KEYWORD_SEGMENT.clone()),
            "OverlayKeywordSegment" => Some(OVERLAY_KEYWORD_SEGMENT.clone()),
            "OverridingKeywordSegment" => Some(OVERRIDING_KEYWORD_SEGMENT.clone()),
            "OwnerKeywordSegment" => Some(OWNER_KEYWORD_SEGMENT.clone()),
            "PadKeywordSegment" => Some(PAD_KEYWORD_SEGMENT.clone()),
            "PaddingKeywordSegment" => Some(PADDING_KEYWORD_SEGMENT.clone()),
            "Parallel_enableKeywordSegment" => Some(PARALLEL_ENABLE_KEYWORD_SEGMENT.clone()),
            "ParameterKeywordSegment" => Some(PARAMETER_KEYWORD_SEGMENT.clone()),
            "ParameterNameSegment" => Some(PARAMETER_NAME_SEGMENT.clone()),
            "ParameterSegment" => Some(PARAMETER_SEGMENT.clone()),
            "Parameter_specific_catalogKeywordSegment" => Some(PARAMETER_SPECIFIC_CATALOG_KEYWORD_SEGMENT.clone()),
            "Parameter_specific_nameKeywordSegment" => Some(PARAMETER_SPECIFIC_NAME_KEYWORD_SEGMENT.clone()),
            "Parameter_specific_schemaKeywordSegment" => Some(PARAMETER_SPECIFIC_SCHEMA_KEYWORD_SEGMENT.clone()),
            "PartialKeywordSegment" => Some(PARTIAL_KEYWORD_SEGMENT.clone()),
            "PartitionClauseSegment" => Some(PARTITION_CLAUSE_SEGMENT.clone()),
            "PartitionKeywordSegment" => Some(PARTITION_KEYWORD_SEGMENT.clone()),
            "PascalKeywordSegment" => Some(PASCAL_KEYWORD_SEGMENT.clone()),
            "PasswordKeywordSegment" => Some(PASSWORD_KEYWORD_SEGMENT.clone()),
            "PasswordLiteralSegment" => Some(PASSWORD_LITERAL_SEGMENT.clone()),
            "Password_expiry_policyKeywordSegment" => Some(PASSWORD_EXPIRY_POLICY_KEYWORD_SEGMENT.clone()),
            "Password_security_policyKeywordSegment" => Some(PASSWORD_SECURITY_POLICY_KEYWORD_SEGMENT.clone()),
            "PathKeywordSegment" => Some(PATH_KEYWORD_SEGMENT.clone()),
            "PathSegment" => Some(PATH_SEGMENT.clone()),
            "PatternMatchingGrammar" => Some(PATTERN_MATCHING_GRAMMAR.clone()),
            "Percentile_contKeywordSegment" => Some(PERCENTILE_CONT_KEYWORD_SEGMENT.clone()),
            "Percentile_discKeywordSegment" => Some(PERCENTILE_DISC_KEYWORD_SEGMENT.clone()),
            "PermissionKeywordSegment" => Some(PERMISSION_KEYWORD_SEGMENT.clone()),
            "PiKeywordSegment" => Some(PI_KEYWORD_SEGMENT.clone()),
            "PipeSegment" => Some(PIPE_SEGMENT.clone()),
            "PlacingKeywordSegment" => Some(PLACING_KEYWORD_SEGMENT.clone()),
            "PliKeywordSegment" => Some(PLI_KEYWORD_SEGMENT.clone()),
            "PlusKeywordSegment" => Some(PLUS_KEYWORD_SEGMENT.clone()),
            "PlusSegment" => Some(PLUS_SEGMENT.clone()),
            "PositionKeywordSegment" => Some(POSITION_KEYWORD_SEGMENT.clone()),
            "PositiveSegment" => Some(POSITIVE_SEGMENT.clone()),
            "Posix_timeKeywordSegment" => Some(POSIX_TIME_KEYWORD_SEGMENT.clone()),
            "PostFunctionGrammar" => Some(POST_FUNCTION_GRAMMAR.clone()),
            "PostTableExpressionGrammar" => Some(POST_TABLE_EXPRESSION_GRAMMAR.clone()),
            "PowerKeywordSegment" => Some(POWER_KEYWORD_SEGMENT.clone()),
            "PreTableFunctionKeywordsGrammar" => Some(PRE_TABLE_FUNCTION_KEYWORDS_GRAMMAR.clone()),
            "PrecedenceKeywordSegment" => Some(PRECEDENCE_KEYWORD_SEGMENT.clone()),
            "PrecedingKeywordSegment" => Some(PRECEDING_KEYWORD_SEGMENT.clone()),
            "PrecisionKeywordSegment" => Some(PRECISION_KEYWORD_SEGMENT.clone()),
            "PreferringClauseSegment" => Some(PREFERRING_CLAUSE_SEGMENT.clone()),
            "PreferringKeywordSegment" => Some(PREFERRING_KEYWORD_SEGMENT.clone()),
            "PreferringPlusPriorTermSegment" => Some(PREFERRING_PLUS_PRIOR_TERM_SEGMENT.clone()),
            "PreferringPreferenceTermSegment" => Some(PREFERRING_PREFERENCE_TERM_SEGMENT.clone()),
            "PreloadKeywordSegment" => Some(PRELOAD_KEYWORD_SEGMENT.clone()),
            "PreloadSegment" => Some(PRELOAD_SEGMENT.clone()),
            "PrepareKeywordSegment" => Some(PREPARE_KEYWORD_SEGMENT.clone()),
            "PreserveKeywordSegment" => Some(PRESERVE_KEYWORD_SEGMENT.clone()),
            "PrimaryKeyGrammar" => Some(PRIMARY_KEY_GRAMMAR.clone()),
            "PrimaryKeywordSegment" => Some(PRIMARY_KEYWORD_SEGMENT.clone()),
            "PrincipalKeywordSegment" => Some(PRINCIPAL_KEYWORD_SEGMENT.clone()),
            "PriorKeywordSegment" => Some(PRIOR_KEYWORD_SEGMENT.clone()),
            "PrivilegeKeywordSegment" => Some(PRIVILEGE_KEYWORD_SEGMENT.clone()),
            "PrivilegesKeywordSegment" => Some(PRIVILEGES_KEYWORD_SEGMENT.clone()),
            "ProcedureKeywordSegment" => Some(PROCEDURE_KEYWORD_SEGMENT.clone()),
            "ProfileKeywordSegment" => Some(PROFILE_KEYWORD_SEGMENT.clone()),
            "PythonKeywordSegment" => Some(PYTHON_KEYWORD_SEGMENT.clone()),
            "QualifiedNumericLiteralSegment" => Some(QUALIFIED_NUMERIC_LITERAL_SEGMENT.clone()),
            "QualifyClauseSegment" => Some(QUALIFY_CLAUSE_SEGMENT.clone()),
            "QualifyKeywordSegment" => Some(QUALIFY_KEYWORD_SEGMENT.clone()),
            "QueryKeywordSegment" => Some(QUERY_KEYWORD_SEGMENT.clone()),
            "Query_cacheKeywordSegment" => Some(QUERY_CACHE_KEYWORD_SEGMENT.clone()),
            "Query_timeoutKeywordSegment" => Some(QUERY_TIMEOUT_KEYWORD_SEGMENT.clone()),
            "QuietKeywordSegment" => Some(QUIET_KEYWORD_SEGMENT.clone()),
            "QuotedIdentifierSegment" => Some(QUOTED_IDENTIFIER_SEGMENT.clone()),
            "QuotedLiteralSegment" => Some(QUOTED_LITERAL_SEGMENT.clone()),
            "RKeywordSegment" => Some(R_KEYWORD_SEGMENT.clone()),
            "RadiansKeywordSegment" => Some(RADIANS_KEYWORD_SEGMENT.clone()),
            "RandKeywordSegment" => Some(RAND_KEYWORD_SEGMENT.clone()),
            "RandomKeywordSegment" => Some(RANDOM_KEYWORD_SEGMENT.clone()),
            "RangeKeywordSegment" => Some(RANGE_KEYWORD_SEGMENT.clone()),
            "RangeOperator" => Some(RANGE_OPERATOR.clone()),
            "RankKeywordSegment" => Some(RANK_KEYWORD_SEGMENT.clone()),
            "Ratio_to_reportKeywordSegment" => Some(RATIO_TO_REPORT_KEYWORD_SEGMENT.clone()),
            "RawEqualsSegment" => Some(RAW_EQUALS_SEGMENT.clone()),
            "RawGreaterThanSegment" => Some(RAW_GREATER_THAN_SEGMENT.clone()),
            "RawLessThanSegment" => Some(RAW_LESS_THAN_SEGMENT.clone()),
            "RawNotSegment" => Some(RAW_NOT_SEGMENT.clone()),
            "RawSegment" => Some(RAW_SEGMENT.clone()),
            "Raw_size_limitKeywordSegment" => Some(RAW_SIZE_LIMIT_KEYWORD_SEGMENT.clone()),
            "ReadKeywordSegment" => Some(READ_KEYWORD_SEGMENT.clone()),
            "ReadsKeywordSegment" => Some(READS_KEYWORD_SEGMENT.clone()),
            "RealKeywordSegment" => Some(REAL_KEYWORD_SEGMENT.clone()),
            "RecompressKeywordSegment" => Some(RECOMPRESS_KEYWORD_SEGMENT.clone()),
            "RecompressReorganizeSegment" => Some(RECOMPRESS_REORGANIZE_SEGMENT.clone()),
            "RecordKeywordSegment" => Some(RECORD_KEYWORD_SEGMENT.clone()),
            "RecoveryKeywordSegment" => Some(RECOVERY_KEYWORD_SEGMENT.clone()),
            "RecursiveKeywordSegment" => Some(RECURSIVE_KEYWORD_SEGMENT.clone()),
            "RefKeywordSegment" => Some(REF_KEYWORD_SEGMENT.clone()),
            "ReferenceDefinitionGrammar" => Some(REFERENCE_DEFINITION_GRAMMAR.clone()),
            "ReferenceMatchGrammar" => Some(REFERENCE_MATCH_GRAMMAR.clone()),
            "ReferencesKeywordSegment" => Some(REFERENCES_KEYWORD_SEGMENT.clone()),
            "ReferencingClauseSegment" => Some(REFERENCING_CLAUSE_SEGMENT.clone()),
            "ReferencingKeywordSegment" => Some(REFERENCING_KEYWORD_SEGMENT.clone()),
            "ReferentialActionGrammar" => Some(REFERENTIAL_ACTION_GRAMMAR.clone()),
            "RefreshKeywordSegment" => Some(REFRESH_KEYWORD_SEGMENT.clone()),
            "Regexp_instrKeywordSegment" => Some(REGEXP_INSTR_KEYWORD_SEGMENT.clone()),
            "Regexp_likeKeywordSegment" => Some(REGEXP_LIKE_KEYWORD_SEGMENT.clone()),
            "Regexp_replaceKeywordSegment" => Some(REGEXP_REPLACE_KEYWORD_SEGMENT.clone()),
            "Regexp_substrKeywordSegment" => Some(REGEXP_SUBSTR_KEYWORD_SEGMENT.clone()),
            "Regr_avgxKeywordSegment" => Some(REGR_AVGX_KEYWORD_SEGMENT.clone()),
            "Regr_avgyKeywordSegment" => Some(REGR_AVGY_KEYWORD_SEGMENT.clone()),
            "Regr_countKeywordSegment" => Some(REGR_COUNT_KEYWORD_SEGMENT.clone()),
            "Regr_interceptKeywordSegment" => Some(REGR_INTERCEPT_KEYWORD_SEGMENT.clone()),
            "Regr_r2KeywordSegment" => Some(REGR_R2_KEYWORD_SEGMENT.clone()),
            "Regr_slopeKeywordSegment" => Some(REGR_SLOPE_KEYWORD_SEGMENT.clone()),
            "Regr_sxxKeywordSegment" => Some(REGR_SXX_KEYWORD_SEGMENT.clone()),
            "Regr_sxyKeywordSegment" => Some(REGR_SXY_KEYWORD_SEGMENT.clone()),
            "Regr_syyKeywordSegment" => Some(REGR_SYY_KEYWORD_SEGMENT.clone()),
            "RejectClauseSegment" => Some(REJECT_CLAUSE_SEGMENT.clone()),
            "RejectKeywordSegment" => Some(REJECT_KEYWORD_SEGMENT.clone()),
            "RelativeKeywordSegment" => Some(RELATIVE_KEYWORD_SEGMENT.clone()),
            "ReleaseKeywordSegment" => Some(RELEASE_KEYWORD_SEGMENT.clone()),
            "RenameKeywordSegment" => Some(RENAME_KEYWORD_SEGMENT.clone()),
            "RenameStatementSegment" => Some(RENAME_STATEMENT_SEGMENT.clone()),
            "ReorganizeKeywordSegment" => Some(REORGANIZE_KEYWORD_SEGMENT.clone()),
            "RepeatKeywordSegment" => Some(REPEAT_KEYWORD_SEGMENT.clone()),
            "RepeatableKeywordSegment" => Some(REPEATABLE_KEYWORD_SEGMENT.clone()),
            "ReplaceKeywordSegment" => Some(REPLACE_KEYWORD_SEGMENT.clone()),
            "ResetKeywordSegment" => Some(RESET_KEYWORD_SEGMENT.clone()),
            "RespectKeywordSegment" => Some(RESPECT_KEYWORD_SEGMENT.clone()),
            "RestoreKeywordSegment" => Some(RESTORE_KEYWORD_SEGMENT.clone()),
            "RestrictKeywordSegment" => Some(RESTRICT_KEYWORD_SEGMENT.clone()),
            "ResultKeywordSegment" => Some(RESULT_KEYWORD_SEGMENT.clone()),
            "ReturnKeywordSegment" => Some(RETURN_KEYWORD_SEGMENT.clone()),
            "Returned_lengthKeywordSegment" => Some(RETURNED_LENGTH_KEYWORD_SEGMENT.clone()),
            "Returned_octet_lengthKeywordSegment" => Some(RETURNED_OCTET_LENGTH_KEYWORD_SEGMENT.clone()),
            "ReturningKeywordSegment" => Some(RETURNING_KEYWORD_SEGMENT.clone()),
            "ReturnsKeywordSegment" => Some(RETURNS_KEYWORD_SEGMENT.clone()),
            "ReverseKeywordSegment" => Some(REVERSE_KEYWORD_SEGMENT.clone()),
            "RevokeKeywordSegment" => Some(REVOKE_KEYWORD_SEGMENT.clone()),
            "RightKeywordSegment" => Some(RIGHT_KEYWORD_SEGMENT.clone()),
            "RoleKeywordSegment" => Some(ROLE_KEYWORD_SEGMENT.clone()),
            "RoleReferenceSegment" => Some(ROLE_REFERENCE_SEGMENT.clone()),
            "RolesKeywordSegment" => Some(ROLES_KEYWORD_SEGMENT.clone()),
            "RollbackKeywordSegment" => Some(ROLLBACK_KEYWORD_SEGMENT.clone()),
            "RollupFunctionNameSegment" => Some(ROLLUP_FUNCTION_NAME_SEGMENT.clone()),
            "RollupKeywordSegment" => Some(ROLLUP_KEYWORD_SEGMENT.clone()),
            "RoundKeywordSegment" => Some(ROUND_KEYWORD_SEGMENT.clone()),
            "RoutineKeywordSegment" => Some(ROUTINE_KEYWORD_SEGMENT.clone()),
            "RowKeywordSegment" => Some(ROW_KEYWORD_SEGMENT.clone()),
            "Row_numberKeywordSegment" => Some(ROW_NUMBER_KEYWORD_SEGMENT.clone()),
            "RowcountKeywordSegment" => Some(ROWCOUNT_KEYWORD_SEGMENT.clone()),
            "RowidKeywordSegment" => Some(ROWID_KEYWORD_SEGMENT.clone()),
            "RowsKeywordSegment" => Some(ROWS_KEYWORD_SEGMENT.clone()),
            "RowtypeKeywordSegment" => Some(ROWTYPE_KEYWORD_SEGMENT.clone()),
            "RpadKeywordSegment" => Some(RPAD_KEYWORD_SEGMENT.clone()),
            "RtrimKeywordSegment" => Some(RTRIM_KEYWORD_SEGMENT.clone()),
            "SamplingExpressionSegment" => Some(SAMPLING_EXPRESSION_SEGMENT.clone()),
            "SavepointKeywordSegment" => Some(SAVEPOINT_KEYWORD_SEGMENT.clone()),
            "ScalarKeywordSegment" => Some(SCALAR_KEYWORD_SEGMENT.clone()),
            "SchemaKeywordSegment" => Some(SCHEMA_KEYWORD_SEGMENT.clone()),
            "SchemaReferenceSegment" => Some(SCHEMA_REFERENCE_SEGMENT.clone()),
            "SchemasKeywordSegment" => Some(SCHEMAS_KEYWORD_SEGMENT.clone()),
            "SchemeKeywordSegment" => Some(SCHEME_KEYWORD_SEGMENT.clone()),
            "ScopeKeywordSegment" => Some(SCOPE_KEYWORD_SEGMENT.clone()),
            "Scope_userKeywordSegment" => Some(SCOPE_USER_KEYWORD_SEGMENT.clone()),
            "ScriptContentSegment" => Some(SCRIPT_CONTENT_SEGMENT.clone()),
            "ScriptKeywordSegment" => Some(SCRIPT_KEYWORD_SEGMENT.clone()),
            "ScriptReferenceSegment" => Some(SCRIPT_REFERENCE_SEGMENT.clone()),
            "Script_languagesKeywordSegment" => Some(SCRIPT_LANGUAGES_KEYWORD_SEGMENT.clone()),
            "Script_output_addressKeywordSegment" => Some(SCRIPT_OUTPUT_ADDRESS_KEYWORD_SEGMENT.clone()),
            "ScrollKeywordSegment" => Some(SCROLL_KEYWORD_SEGMENT.clone()),
            "SearchKeywordSegment" => Some(SEARCH_KEYWORD_SEGMENT.clone()),
            "SecondKeywordSegment" => Some(SECOND_KEYWORD_SEGMENT.clone()),
            "Seconds_betweenKeywordSegment" => Some(SECONDS_BETWEEN_KEYWORD_SEGMENT.clone()),
            "SectionKeywordSegment" => Some(SECTION_KEYWORD_SEGMENT.clone()),
            "SecureKeywordSegment" => Some(SECURE_KEYWORD_SEGMENT.clone()),
            "SecurityKeywordSegment" => Some(SECURITY_KEYWORD_SEGMENT.clone()),
            "SelectClauseElementSegment" => Some(SELECT_CLAUSE_ELEMENT_SEGMENT.clone()),
            "SelectClauseModifierSegment" => Some(SELECT_CLAUSE_MODIFIER_SEGMENT.clone()),
            "SelectClauseSegment" => Some(SELECT_CLAUSE_SEGMENT.clone()),
            "SelectClauseTerminatorGrammar" => Some(SELECT_CLAUSE_TERMINATOR_GRAMMAR.clone()),
            "SelectKeywordSegment" => Some(SELECT_KEYWORD_SEGMENT.clone()),
            "SelectStatementSegment" => Some(SELECT_STATEMENT_SEGMENT.clone()),
            "SelectableGrammar" => Some(SELECTABLE_GRAMMAR.clone()),
            "SelectiveKeywordSegment" => Some(SELECTIVE_KEYWORD_SEGMENT.clone()),
            "SelfKeywordSegment" => Some(SELF_KEYWORD_SEGMENT.clone()),
            "SemicolonSegment" => Some(SEMICOLON_SEGMENT.clone()),
            "SensitiveKeywordSegment" => Some(SENSITIVE_KEYWORD_SEGMENT.clone()),
            "SeparatorKeywordSegment" => Some(SEPARATOR_KEYWORD_SEGMENT.clone()),
            "SequenceKeywordSegment" => Some(SEQUENCE_KEYWORD_SEGMENT.clone()),
            "SequenceMaxValueGrammar" => Some(SEQUENCE_MAX_VALUE_GRAMMAR.clone()),
            "SequenceMinValueGrammar" => Some(SEQUENCE_MIN_VALUE_GRAMMAR.clone()),
            "SequenceReferenceSegment" => Some(SEQUENCE_REFERENCE_SEGMENT.clone()),
            "SerializableKeywordSegment" => Some(SERIALIZABLE_KEYWORD_SEGMENT.clone()),
            "SessionKeywordSegment" => Some(SESSION_KEYWORD_SEGMENT.clone()),
            "SessionParameterSegment" => Some(SESSION_PARAMETER_SEGMENT.clone()),
            "Session_parameterKeywordSegment" => Some(SESSION_PARAMETER_KEYWORD_SEGMENT.clone()),
            "Session_temp_db_ram_limitKeywordSegment" => Some(SESSION_TEMP_DB_RAM_LIMIT_KEYWORD_SEGMENT.clone()),
            "Session_userKeywordSegment" => Some(SESSION_USER_KEYWORD_SEGMENT.clone()),
            "SessiontimezoneKeywordSegment" => Some(SESSIONTIMEZONE_KEYWORD_SEGMENT.clone()),
            "SetClauseListSegment" => Some(SET_CLAUSE_LIST_SEGMENT.clone()),
            "SetClauseSegment" => Some(SET_CLAUSE_SEGMENT.clone()),
            "SetExpressionSegment" => Some(SET_EXPRESSION_SEGMENT.clone()),
            "SetKeywordSegment" => Some(SET_KEYWORD_SEGMENT.clone()),
            "SetOperatorSegment" => Some(SET_OPERATOR_SEGMENT.clone()),
            "SetSchemaStatementSegment" => Some(SET_SCHEMA_STATEMENT_SEGMENT.clone()),
            "SetsKeywordSegment" => Some(SETS_KEYWORD_SEGMENT.clone()),
            "ShorthandCastSegment" => Some(SHORTHAND_CAST_SEGMENT.clone()),
            "ShortintKeywordSegment" => Some(SHORTINT_KEYWORD_SEGMENT.clone()),
            "ShutKeywordSegment" => Some(SHUT_KEYWORD_SEGMENT.clone()),
            "SignKeywordSegment" => Some(SIGN_KEYWORD_SEGMENT.clone()),
            "SignedSegmentGrammar" => Some(SIGNED_SEGMENT_GRAMMAR.clone()),
            "SimilarKeywordSegment" => Some(SIMILAR_KEYWORD_SEGMENT.clone()),
            "SimpleKeywordSegment" => Some(SIMPLE_KEYWORD_SEGMENT.clone()),
            "SinKeywordSegment" => Some(SIN_KEYWORD_SEGMENT.clone()),
            "SingleIdentifierGrammar" => Some(SINGLE_IDENTIFIER_GRAMMAR.clone()),
            "SingleIdentifierListSegment" => Some(SINGLE_IDENTIFIER_LIST_SEGMENT.clone()),
            "SingleQuotedIdentifierSegment" => Some(SINGLE_QUOTED_IDENTIFIER_SEGMENT.clone()),
            "SinhKeywordSegment" => Some(SINH_KEYWORD_SEGMENT.clone()),
            "SizeKeywordSegment" => Some(SIZE_KEYWORD_SEGMENT.clone()),
            "SizedArrayTypeSegment" => Some(SIZED_ARRAY_TYPE_SEGMENT.clone()),
            "SkipKeywordSegment" => Some(SKIP_KEYWORD_SEGMENT.clone()),
            "SlashSegment" => Some(SLASH_SEGMENT.clone()),
            "SliceSegment" => Some(SLICE_SEGMENT.clone()),
            "SmallintKeywordSegment" => Some(SMALLINT_KEYWORD_SEGMENT.clone()),
            "Snapshot_modeKeywordSegment" => Some(SNAPSHOT_MODE_KEYWORD_SEGMENT.clone()),
            "SomeKeywordSegment" => Some(SOME_KEYWORD_SEGMENT.clone()),
            "SoundexKeywordSegment" => Some(SOUNDEX_KEYWORD_SEGMENT.clone()),
            "SourceKeywordSegment" => Some(SOURCE_KEYWORD_SEGMENT.clone()),
            "SpaceKeywordSegment" => Some(SPACE_KEYWORD_SEGMENT.clone()),
            "SpecificKeywordSegment" => Some(SPECIFIC_KEYWORD_SEGMENT.clone()),
            "SpecifictypeKeywordSegment" => Some(SPECIFICTYPE_KEYWORD_SEGMENT.clone()),
            "SqlKeywordSegment" => Some(SQL_KEYWORD_SEGMENT.clone()),
            "Sql_bigintKeywordSegment" => Some(SQL_BIGINT_KEYWORD_SEGMENT.clone()),
            "Sql_bitKeywordSegment" => Some(SQL_BIT_KEYWORD_SEGMENT.clone()),
            "Sql_charKeywordSegment" => Some(SQL_CHAR_KEYWORD_SEGMENT.clone()),
            "Sql_dateKeywordSegment" => Some(SQL_DATE_KEYWORD_SEGMENT.clone()),
            "Sql_decimalKeywordSegment" => Some(SQL_DECIMAL_KEYWORD_SEGMENT.clone()),
            "Sql_doubleKeywordSegment" => Some(SQL_DOUBLE_KEYWORD_SEGMENT.clone()),
            "Sql_floatKeywordSegment" => Some(SQL_FLOAT_KEYWORD_SEGMENT.clone()),
            "Sql_integerKeywordSegment" => Some(SQL_INTEGER_KEYWORD_SEGMENT.clone()),
            "Sql_longvarcharKeywordSegment" => Some(SQL_LONGVARCHAR_KEYWORD_SEGMENT.clone()),
            "Sql_numericKeywordSegment" => Some(SQL_NUMERIC_KEYWORD_SEGMENT.clone()),
            "Sql_preprocessor_scriptKeywordSegment" => Some(SQL_PREPROCESSOR_SCRIPT_KEYWORD_SEGMENT.clone()),
            "Sql_realKeywordSegment" => Some(SQL_REAL_KEYWORD_SEGMENT.clone()),
            "Sql_smallintKeywordSegment" => Some(SQL_SMALLINT_KEYWORD_SEGMENT.clone()),
            "Sql_timestampKeywordSegment" => Some(SQL_TIMESTAMP_KEYWORD_SEGMENT.clone()),
            "Sql_tinyintKeywordSegment" => Some(SQL_TINYINT_KEYWORD_SEGMENT.clone()),
            "Sql_type_dateKeywordSegment" => Some(SQL_TYPE_DATE_KEYWORD_SEGMENT.clone()),
            "Sql_type_timestampKeywordSegment" => Some(SQL_TYPE_TIMESTAMP_KEYWORD_SEGMENT.clone()),
            "Sql_varcharKeywordSegment" => Some(SQL_VARCHAR_KEYWORD_SEGMENT.clone()),
            "SqlexceptionKeywordSegment" => Some(SQLEXCEPTION_KEYWORD_SEGMENT.clone()),
            "SqlstateKeywordSegment" => Some(SQLSTATE_KEYWORD_SEGMENT.clone()),
            "SqlwarningKeywordSegment" => Some(SQLWARNING_KEYWORD_SEGMENT.clone()),
            "SqrtKeywordSegment" => Some(SQRT_KEYWORD_SEGMENT.clone()),
            "St_areaKeywordSegment" => Some(ST_AREA_KEYWORD_SEGMENT.clone()),
            "St_boundaryKeywordSegment" => Some(ST_BOUNDARY_KEYWORD_SEGMENT.clone()),
            "St_bufferKeywordSegment" => Some(ST_BUFFER_KEYWORD_SEGMENT.clone()),
            "St_centroidKeywordSegment" => Some(ST_CENTROID_KEYWORD_SEGMENT.clone()),
            "St_containsKeywordSegment" => Some(ST_CONTAINS_KEYWORD_SEGMENT.clone()),
            "St_convexhullKeywordSegment" => Some(ST_CONVEXHULL_KEYWORD_SEGMENT.clone()),
            "St_crossesKeywordSegment" => Some(ST_CROSSES_KEYWORD_SEGMENT.clone()),
            "St_differenceKeywordSegment" => Some(ST_DIFFERENCE_KEYWORD_SEGMENT.clone()),
            "St_dimensionKeywordSegment" => Some(ST_DIMENSION_KEYWORD_SEGMENT.clone()),
            "St_disjointKeywordSegment" => Some(ST_DISJOINT_KEYWORD_SEGMENT.clone()),
            "St_distanceKeywordSegment" => Some(ST_DISTANCE_KEYWORD_SEGMENT.clone()),
            "St_endpointKeywordSegment" => Some(ST_ENDPOINT_KEYWORD_SEGMENT.clone()),
            "St_envelopeKeywordSegment" => Some(ST_ENVELOPE_KEYWORD_SEGMENT.clone()),
            "St_equalsKeywordSegment" => Some(ST_EQUALS_KEYWORD_SEGMENT.clone()),
            "St_exteriorringKeywordSegment" => Some(ST_EXTERIORRING_KEYWORD_SEGMENT.clone()),
            "St_force2dKeywordSegment" => Some(ST_FORCE2D_KEYWORD_SEGMENT.clone()),
            "St_geometrynKeywordSegment" => Some(ST_GEOMETRYN_KEYWORD_SEGMENT.clone()),
            "St_geometrytypeKeywordSegment" => Some(ST_GEOMETRYTYPE_KEYWORD_SEGMENT.clone()),
            "St_interiorringnKeywordSegment" => Some(ST_INTERIORRINGN_KEYWORD_SEGMENT.clone()),
            "St_intersectionKeywordSegment" => Some(ST_INTERSECTION_KEYWORD_SEGMENT.clone()),
            "St_intersectsKeywordSegment" => Some(ST_INTERSECTS_KEYWORD_SEGMENT.clone()),
            "St_isclosedKeywordSegment" => Some(ST_ISCLOSED_KEYWORD_SEGMENT.clone()),
            "St_isemptyKeywordSegment" => Some(ST_ISEMPTY_KEYWORD_SEGMENT.clone()),
            "St_isringKeywordSegment" => Some(ST_ISRING_KEYWORD_SEGMENT.clone()),
            "St_issimpleKeywordSegment" => Some(ST_ISSIMPLE_KEYWORD_SEGMENT.clone()),
            "St_lengthKeywordSegment" => Some(ST_LENGTH_KEYWORD_SEGMENT.clone()),
            "St_max_decimal_digitsKeywordSegment" => Some(ST_MAX_DECIMAL_DIGITS_KEYWORD_SEGMENT.clone()),
            "St_numgeometriesKeywordSegment" => Some(ST_NUMGEOMETRIES_KEYWORD_SEGMENT.clone()),
            "St_numinteriorringsKeywordSegment" => Some(ST_NUMINTERIORRINGS_KEYWORD_SEGMENT.clone()),
            "St_numpointsKeywordSegment" => Some(ST_NUMPOINTS_KEYWORD_SEGMENT.clone()),
            "St_overlapsKeywordSegment" => Some(ST_OVERLAPS_KEYWORD_SEGMENT.clone()),
            "St_pointnKeywordSegment" => Some(ST_POINTN_KEYWORD_SEGMENT.clone()),
            "St_setsridKeywordSegment" => Some(ST_SETSRID_KEYWORD_SEGMENT.clone()),
            "St_startpointKeywordSegment" => Some(ST_STARTPOINT_KEYWORD_SEGMENT.clone()),
            "St_symdifferenceKeywordSegment" => Some(ST_SYMDIFFERENCE_KEYWORD_SEGMENT.clone()),
            "St_touchesKeywordSegment" => Some(ST_TOUCHES_KEYWORD_SEGMENT.clone()),
            "St_transformKeywordSegment" => Some(ST_TRANSFORM_KEYWORD_SEGMENT.clone()),
            "St_unionKeywordSegment" => Some(ST_UNION_KEYWORD_SEGMENT.clone()),
            "St_withinKeywordSegment" => Some(ST_WITHIN_KEYWORD_SEGMENT.clone()),
            "St_xKeywordSegment" => Some(ST_X_KEYWORD_SEGMENT.clone()),
            "St_yKeywordSegment" => Some(ST_Y_KEYWORD_SEGMENT.clone()),
            "StarSegment" => Some(STAR_SEGMENT.clone()),
            "StartBracketSegment" => Some(START_BRACKET_SEGMENT.clone()),
            "StartCurlyBracketSegment" => Some(START_CURLY_BRACKET_SEGMENT.clone()),
            "StartKeywordSegment" => Some(START_KEYWORD_SEGMENT.clone()),
            "StartSquareBracketSegment" => Some(START_SQUARE_BRACKET_SEGMENT.clone()),
            "StateKeywordSegment" => Some(STATE_KEYWORD_SEGMENT.clone()),
            "StatementKeywordSegment" => Some(STATEMENT_KEYWORD_SEGMENT.clone()),
            "StatementSegment" => Some(STATEMENT_SEGMENT.clone()),
            "StaticKeywordSegment" => Some(STATIC_KEYWORD_SEGMENT.clone()),
            "StatisticsKeywordSegment" => Some(STATISTICS_KEYWORD_SEGMENT.clone()),
            "StddevKeywordSegment" => Some(STDDEV_KEYWORD_SEGMENT.clone()),
            "Stddev_popKeywordSegment" => Some(STDDEV_POP_KEYWORD_SEGMENT.clone()),
            "Stddev_sampKeywordSegment" => Some(STDDEV_SAMP_KEYWORD_SEGMENT.clone()),
            "StepKeywordSegment" => Some(STEP_KEYWORD_SEGMENT.clone()),
            "StringBinaryOperatorGrammar" => Some(STRING_BINARY_OPERATOR_GRAMMAR.clone()),
            "StructLiteralSegment" => Some(STRUCT_LITERAL_SEGMENT.clone()),
            "StructTypeSegment" => Some(STRUCT_TYPE_SEGMENT.clone()),
            "StructureKeywordSegment" => Some(STRUCTURE_KEYWORD_SEGMENT.clone()),
            "StyleKeywordSegment" => Some(STYLE_KEYWORD_SEGMENT.clone()),
            "SubjectKeywordSegment" => Some(SUBJECT_KEYWORD_SEGMENT.clone()),
            "SubstrKeywordSegment" => Some(SUBSTR_KEYWORD_SEGMENT.clone()),
            "SubstringKeywordSegment" => Some(SUBSTRING_KEYWORD_SEGMENT.clone()),
            "SubtypeKeywordSegment" => Some(SUBTYPE_KEYWORD_SEGMENT.clone()),
            "SumKeywordSegment" => Some(SUM_KEYWORD_SEGMENT.clone()),
            "SymbolSegment" => Some(SYMBOL_SEGMENT.clone()),
            "SymmetricKeywordSegment" => Some(SYMMETRIC_KEYWORD_SEGMENT.clone()),
            "Sys_connect_by_pathKeywordSegment" => Some(SYS_CONNECT_BY_PATH_KEYWORD_SEGMENT.clone()),
            "Sys_guidKeywordSegment" => Some(SYS_GUID_KEYWORD_SEGMENT.clone()),
            "SysdateKeywordSegment" => Some(SYSDATE_KEYWORD_SEGMENT.clone()),
            "SystemKeywordSegment" => Some(SYSTEM_KEYWORD_SEGMENT.clone()),
            "SystemParameterSegment" => Some(SYSTEM_PARAMETER_SEGMENT.clone()),
            "SystemPrivilegesSegment" => Some(SYSTEM_PRIVILEGES_SEGMENT.clone()),
            "System_userKeywordSegment" => Some(SYSTEM_USER_KEYWORD_SEGMENT.clone()),
            "SystimestampKeywordSegment" => Some(SYSTIMESTAMP_KEYWORD_SEGMENT.clone()),
            "TableConstraintEnableDisableGrammar" => Some(TABLE_CONSTRAINT_ENABLE_DISABLE_GRAMMAR.clone()),
            "TableConstraintSegment" => Some(TABLE_CONSTRAINT_SEGMENT.clone()),
            "TableContentDefinitionSegment" => Some(TABLE_CONTENT_DEFINITION_SEGMENT.clone()),
            "TableDistributeByGrammar" => Some(TABLE_DISTRIBUTE_BY_GRAMMAR.clone()),
            "TableDistributionPartitionClause" => Some(TABLE_DISTRIBUTION_PARTITION_CLAUSE.clone()),
            "TableEndClauseSegment" => Some(TABLE_END_CLAUSE_SEGMENT.clone()),
            "TableExpressionSegment" => Some(TABLE_EXPRESSION_SEGMENT.clone()),
            "TableInlineConstraintSegment" => Some(TABLE_INLINE_CONSTRAINT_SEGMENT.clone()),
            "TableKeywordSegment" => Some(TABLE_KEYWORD_SEGMENT.clone()),
            "TableOutOfLineConstraintSegment" => Some(TABLE_OUT_OF_LINE_CONSTRAINT_SEGMENT.clone()),
            "TablePartitionByGrammar" => Some(TABLE_PARTITION_BY_GRAMMAR.clone()),
            "TableReferenceSegment" => Some(TABLE_REFERENCE_SEGMENT.clone()),
            "TablesKeywordSegment" => Some(TABLES_KEYWORD_SEGMENT.clone()),
            "TablesampleKeywordSegment" => Some(TABLESAMPLE_KEYWORD_SEGMENT.clone()),
            "TablespaceReferenceSegment" => Some(TABLESPACE_REFERENCE_SEGMENT.clone()),
            "TagReferenceSegment" => Some(TAG_REFERENCE_SEGMENT.clone()),
            "Tail_Recurse_Expression_A_Grammar" => Some(TAIL_RECURSE_EXPRESSION_A_GRAMMAR.clone()),
            "Tail_Recurse_Expression_B_Grammar" => Some(TAIL_RECURSE_EXPRESSION_B_GRAMMAR.clone()),
            "TanKeywordSegment" => Some(TAN_KEYWORD_SEGMENT.clone()),
            "TanhKeywordSegment" => Some(TANH_KEYWORD_SEGMENT.clone()),
            "TasksKeywordSegment" => Some(TASKS_KEYWORD_SEGMENT.clone()),
            "Temp_db_ram_limitKeywordSegment" => Some(TEMP_DB_RAM_LIMIT_KEYWORD_SEGMENT.clone()),
            "TemporalQuerySegment" => Some(TEMPORAL_QUERY_SEGMENT.clone()),
            "TemporaryGrammar" => Some(TEMPORARY_GRAMMAR.clone()),
            "TemporaryKeywordSegment" => Some(TEMPORARY_KEYWORD_SEGMENT.clone()),
            "TemporaryTransientGrammar" => Some(TEMPORARY_TRANSIENT_GRAMMAR.clone()),
            "TextKeywordSegment" => Some(TEXT_KEYWORD_SEGMENT.clone()),
            "ThenKeywordSegment" => Some(THEN_KEYWORD_SEGMENT.clone()),
            "TiesKeywordSegment" => Some(TIES_KEYWORD_SEGMENT.clone()),
            "TildeSegment" => Some(TILDE_SEGMENT.clone()),
            "TimeKeywordSegment" => Some(TIME_KEYWORD_SEGMENT.clone()),
            "TimeWithTZGrammar" => Some(TIME_WITH_T_Z_GRAMMAR.clone()),
            "TimeZoneGrammar" => Some(TIME_ZONE_GRAMMAR.clone()),
            "Time_zoneKeywordSegment" => Some(TIME_ZONE_KEYWORD_SEGMENT.clone()),
            "Time_zone_behaviorKeywordSegment" => Some(TIME_ZONE_BEHAVIOR_KEYWORD_SEGMENT.clone()),
            "TimestampKeywordSegment" => Some(TIMESTAMP_KEYWORD_SEGMENT.clone()),
            "Timestamp_arithmetic_behaviorKeywordSegment" => Some(TIMESTAMP_ARITHMETIC_BEHAVIOR_KEYWORD_SEGMENT.clone()),
            "Timezone_hourKeywordSegment" => Some(TIMEZONE_HOUR_KEYWORD_SEGMENT.clone()),
            "Timezone_minuteKeywordSegment" => Some(TIMEZONE_MINUTE_KEYWORD_SEGMENT.clone()),
            "TinyintKeywordSegment" => Some(TINYINT_KEYWORD_SEGMENT.clone()),
            "ToKeywordSegment" => Some(TO_KEYWORD_SEGMENT.clone()),
            "To_charKeywordSegment" => Some(TO_CHAR_KEYWORD_SEGMENT.clone()),
            "To_dateKeywordSegment" => Some(TO_DATE_KEYWORD_SEGMENT.clone()),
            "To_dsintervalKeywordSegment" => Some(TO_DSINTERVAL_KEYWORD_SEGMENT.clone()),
            "To_numberKeywordSegment" => Some(TO_NUMBER_KEYWORD_SEGMENT.clone()),
            "To_timestampKeywordSegment" => Some(TO_TIMESTAMP_KEYWORD_SEGMENT.clone()),
            "To_ymintervalKeywordSegment" => Some(TO_YMINTERVAL_KEYWORD_SEGMENT.clone()),
            "TraceKeywordSegment" => Some(TRACE_KEYWORD_SEGMENT.clone()),
            "TrailingKeywordSegment" => Some(TRAILING_KEYWORD_SEGMENT.clone()),
            "TransactionKeywordSegment" => Some(TRANSACTION_KEYWORD_SEGMENT.clone()),
            "TransactionStatementSegment" => Some(TRANSACTION_STATEMENT_SEGMENT.clone()),
            "TransformKeywordSegment" => Some(TRANSFORM_KEYWORD_SEGMENT.clone()),
            "TransformsKeywordSegment" => Some(TRANSFORMS_KEYWORD_SEGMENT.clone()),
            "TranslateKeywordSegment" => Some(TRANSLATE_KEYWORD_SEGMENT.clone()),
            "TranslationKeywordSegment" => Some(TRANSLATION_KEYWORD_SEGMENT.clone()),
            "TreatKeywordSegment" => Some(TREAT_KEYWORD_SEGMENT.clone()),
            "TriggerKeywordSegment" => Some(TRIGGER_KEYWORD_SEGMENT.clone()),
            "TriggerReferenceSegment" => Some(TRIGGER_REFERENCE_SEGMENT.clone()),
            "TrimKeywordSegment" => Some(TRIM_KEYWORD_SEGMENT.clone()),
            "TrimParametersGrammar" => Some(TRIM_PARAMETERS_GRAMMAR.clone()),
            "TrueKeywordSegment" => Some(TRUE_KEYWORD_SEGMENT.clone()),
            "TrueSegment" => Some(TRUE_SEGMENT.clone()),
            "TruncKeywordSegment" => Some(TRUNC_KEYWORD_SEGMENT.clone()),
            "TruncateAuditLogsSegment" => Some(TRUNCATE_AUDIT_LOGS_SEGMENT.clone()),
            "TruncateKeywordSegment" => Some(TRUNCATE_KEYWORD_SEGMENT.clone()),
            "TruncateStatementSegment" => Some(TRUNCATE_STATEMENT_SEGMENT.clone()),
            "TupleSegment" => Some(TUPLE_SEGMENT.clone()),
            "TypeKeywordSegment" => Some(TYPE_KEYWORD_SEGMENT.clone()),
            "TypedArrayLiteralSegment" => Some(TYPED_ARRAY_LITERAL_SEGMENT.clone()),
            "TypedStructLiteralSegment" => Some(TYPED_STRUCT_LITERAL_SEGMENT.clone()),
            "TypeofKeywordSegment" => Some(TYPEOF_KEYWORD_SEGMENT.clone()),
            "UDFParameterDotSyntaxSegment" => Some(U_D_F_PARAMETER_DOT_SYNTAX_SEGMENT.clone()),
            "UDFParameterGrammar" => Some(U_D_F_PARAMETER_GRAMMAR.clone()),
            "UcaseKeywordSegment" => Some(UCASE_KEYWORD_SEGMENT.clone()),
            "UnboundedKeywordSegment" => Some(UNBOUNDED_KEYWORD_SEGMENT.clone()),
            "UncommittedKeywordSegment" => Some(UNCOMMITTED_KEYWORD_SEGMENT.clone()),
            "UnconditionalCrossJoinKeywordsGrammar" => Some(UNCONDITIONAL_CROSS_JOIN_KEYWORDS_GRAMMAR.clone()),
            "UnconditionalJoinKeywordsGrammar" => Some(UNCONDITIONAL_JOIN_KEYWORDS_GRAMMAR.clone()),
            "UnderKeywordSegment" => Some(UNDER_KEYWORD_SEGMENT.clone()),
            "UndoKeywordSegment" => Some(UNDO_KEYWORD_SEGMENT.clone()),
            "UnicodeKeywordSegment" => Some(UNICODE_KEYWORD_SEGMENT.clone()),
            "UnicodechrKeywordSegment" => Some(UNICODECHR_KEYWORD_SEGMENT.clone()),
            "UnionGrammar" => Some(UNION_GRAMMAR.clone()),
            "UnionKeywordSegment" => Some(UNION_KEYWORD_SEGMENT.clone()),
            "UniqueKeyGrammar" => Some(UNIQUE_KEY_GRAMMAR.clone()),
            "UniqueKeywordSegment" => Some(UNIQUE_KEYWORD_SEGMENT.clone()),
            "UnknownKeywordSegment" => Some(UNKNOWN_KEYWORD_SEGMENT.clone()),
            "UnknownLiteralSegment" => Some(UNKNOWN_LITERAL_SEGMENT.clone()),
            "UnknownSegment" => Some(UNKNOWN_SEGMENT.clone()),
            "UnlimitedKeywordSegment" => Some(UNLIMITED_KEYWORD_SEGMENT.clone()),
            "UnlinkKeywordSegment" => Some(UNLINK_KEYWORD_SEGMENT.clone()),
            "UnnestKeywordSegment" => Some(UNNEST_KEYWORD_SEGMENT.clone()),
            "UnorderedSelectStatementSegment" => Some(UNORDERED_SELECT_STATEMENT_SEGMENT.clone()),
            "UnorderedSetExpressionSegment" => Some(UNORDERED_SET_EXPRESSION_SEGMENT.clone()),
            "UntilKeywordSegment" => Some(UNTIL_KEYWORD_SEGMENT.clone()),
            "UpdateKeywordSegment" => Some(UPDATE_KEYWORD_SEGMENT.clone()),
            "UpdateStatementSegment" => Some(UPDATE_STATEMENT_SEGMENT.clone()),
            "UpperKeywordSegment" => Some(UPPER_KEYWORD_SEGMENT.clone()),
            "UsageKeywordSegment" => Some(USAGE_KEYWORD_SEGMENT.clone()),
            "UseKeywordSegment" => Some(USE_KEYWORD_SEGMENT.clone()),
            "UseStatementSegment" => Some(USE_STATEMENT_SEGMENT.clone()),
            "UserKerberosAuthSegment" => Some(USER_KERBEROS_AUTH_SEGMENT.clone()),
            "UserKeywordSegment" => Some(USER_KEYWORD_SEGMENT.clone()),
            "UserLDAPAuthSegment" => Some(USER_L_D_A_P_AUTH_SEGMENT.clone()),
            "UserOpenIDAuthSegment" => Some(USER_OPEN_I_D_AUTH_SEGMENT.clone()),
            "UserPasswordAuthSegment" => Some(USER_PASSWORD_AUTH_SEGMENT.clone()),
            "User_temp_db_ram_limitKeywordSegment" => Some(USER_TEMP_DB_RAM_LIMIT_KEYWORD_SEGMENT.clone()),
            "UsingKeywordSegment" => Some(USING_KEYWORD_SEGMENT.clone()),
            "Utf8KeywordSegment" => Some(UTF8_KEYWORD_SEGMENT.clone()),
            "Value2procKeywordSegment" => Some(VALUE2PROC_KEYWORD_SEGMENT.clone()),
            "ValueKeywordSegment" => Some(VALUE_KEYWORD_SEGMENT.clone()),
            "ValuesClauseSegment" => Some(VALUES_CLAUSE_SEGMENT.clone()),
            "ValuesKeywordSegment" => Some(VALUES_KEYWORD_SEGMENT.clone()),
            "ValuesRangeClauseSegment" => Some(VALUES_RANGE_CLAUSE_SEGMENT.clone()),
            "Var_popKeywordSegment" => Some(VAR_POP_KEYWORD_SEGMENT.clone()),
            "Var_sampKeywordSegment" => Some(VAR_SAMP_KEYWORD_SEGMENT.clone()),
            "Varchar2KeywordSegment" => Some(VARCHAR2_KEYWORD_SEGMENT.clone()),
            "VarcharKeywordSegment" => Some(VARCHAR_KEYWORD_SEGMENT.clone()),
            "VariableNameSegment" => Some(VARIABLE_NAME_SEGMENT.clone()),
            "VarianceKeywordSegment" => Some(VARIANCE_KEYWORD_SEGMENT.clone()),
            "VarrayKeywordSegment" => Some(VARRAY_KEYWORD_SEGMENT.clone()),
            "VaryingKeywordSegment" => Some(VARYING_KEYWORD_SEGMENT.clone()),
            "VerifyKeywordSegment" => Some(VERIFY_KEYWORD_SEGMENT.clone()),
            "ViewKeywordSegment" => Some(VIEW_KEYWORD_SEGMENT.clone()),
            "ViewReferenceSegment" => Some(VIEW_REFERENCE_SEGMENT.clone()),
            "VirtualKeywordSegment" => Some(VIRTUAL_KEYWORD_SEGMENT.clone()),
            "WalrusOperatorSegment" => Some(WALRUS_OPERATOR_SEGMENT.clone()),
            "WeekKeywordSegment" => Some(WEEK_KEYWORD_SEGMENT.clone()),
            "WhenClauseSegment" => Some(WHEN_CLAUSE_SEGMENT.clone()),
            "WhenKeywordSegment" => Some(WHEN_KEYWORD_SEGMENT.clone()),
            "WheneverKeywordSegment" => Some(WHENEVER_KEYWORD_SEGMENT.clone()),
            "WhereClauseSegment" => Some(WHERE_CLAUSE_SEGMENT.clone()),
            "WhereClauseTerminatorGrammar" => Some(WHERE_CLAUSE_TERMINATOR_GRAMMAR.clone()),
            "WhereKeywordSegment" => Some(WHERE_KEYWORD_SEGMENT.clone()),
            "WhileKeywordSegment" => Some(WHILE_KEYWORD_SEGMENT.clone()),
            "WhitespaceSegment" => Some(WHITESPACE_SEGMENT.clone()),
            "WildcardExpressionSegment" => Some(WILDCARD_EXPRESSION_SEGMENT.clone()),
            "WildcardIdentifierSegment" => Some(WILDCARD_IDENTIFIER_SEGMENT.clone()),
            "WindowKeywordSegment" => Some(WINDOW_KEYWORD_SEGMENT.clone()),
            "WindowSpecificationSegment" => Some(WINDOW_SPECIFICATION_SEGMENT.clone()),
            "WithCompoundNonSelectStatementSegment" => Some(WITH_COMPOUND_NON_SELECT_STATEMENT_SEGMENT.clone()),
            "WithCompoundStatementSegment" => Some(WITH_COMPOUND_STATEMENT_SEGMENT.clone()),
            "WithDataClauseSegment" => Some(WITH_DATA_CLAUSE_SEGMENT.clone()),
            "WithFillSegment" => Some(WITH_FILL_SEGMENT.clone()),
            "WithInvalidForeignKeySegment" => Some(WITH_INVALID_FOREIGN_KEY_SEGMENT.clone()),
            "WithInvalidUniquePKSegment" => Some(WITH_INVALID_UNIQUE_P_K_SEGMENT.clone()),
            "WithKeywordSegment" => Some(WITH_KEYWORD_SEGMENT.clone()),
            "WithNoSchemaBindingClauseSegment" => Some(WITH_NO_SCHEMA_BINDING_CLAUSE_SEGMENT.clone()),
            "WithinKeywordSegment" => Some(WITHIN_KEYWORD_SEGMENT.clone()),
            "WithoutKeywordSegment" => Some(WITHOUT_KEYWORD_SEGMENT.clone()),
            "WordSegment" => Some(WORD_SEGMENT.clone()),
            "WorkKeywordSegment" => Some(WORK_KEYWORD_SEGMENT.clone()),
            "WriteKeywordSegment" => Some(WRITE_KEYWORD_SEGMENT.clone()),
            "YearKeywordSegment" => Some(YEAR_KEYWORD_SEGMENT.clone()),
            "Years_betweenKeywordSegment" => Some(YEARS_BETWEEN_KEYWORD_SEGMENT.clone()),
            "YesKeywordSegment" => Some(YES_KEYWORD_SEGMENT.clone()),
            "ZeroifnullKeywordSegment" => Some(ZEROIFNULL_KEYWORD_SEGMENT.clone()),
            "ZoneKeywordSegment" => Some(ZONE_KEYWORD_SEGMENT.clone()),
            _ => None,
    }
}

pub fn get_exasol_segment_type(name: &str) -> Option<&'static str> {
    match name {
            "AccessStatementSegment" => Some("access_statement"),
            "AggregateOrderByClause" => Some("aggregate_order_by"),
            "AliasExpressionSegment" => Some("alias_expression"),
            "AlterConnectionSegment" => Some("alter_connection"),
            "AlterConsumerGroupSegment" => Some("alter_consumer_group_statement"),
            "AlterRoleStatementSegment" => Some("alter_role_statement"),
            "AlterSchemaStatementSegment" => Some("alter_schema_statement"),
            "AlterSequenceOptionsSegment" => Some("alter_sequence_options_segment"),
            "AlterSequenceStatementSegment" => Some("alter_sequence_statement"),
            "AlterSessionSegment" => Some("alter_session_statement"),
            "AlterSystemSegment" => Some("alter_system_statement"),
            "AlterTableAddColumnSegment" => Some("alter_table_add_column"),
            "AlterTableAlterColumnSegment" => Some("alter_table_alter_column"),
            "AlterTableColumnSegment" => Some("alter_table_column_statement"),
            "AlterTableConstraintSegment" => Some("alter_table_constraint_statement"),
            "AlterTableDistributePartitionSegment" => Some("alter_table_distribute_partition_statement"),
            "AlterTableDropColumnSegment" => Some("alter_table_drop_column"),
            "AlterTableModifyColumnSegment" => Some("alter_table_modify_column"),
            "AlterTableRenameColumnSegment" => Some("alter_table_rename_column"),
            "AlterTableStatementSegment" => Some("alter_table_statement"),
            "AlterUserStatementSegment" => Some("alter_user_statement"),
            "AlterVirtualSchemaStatementSegment" => Some("alter_virtual_schema_statement"),
            "ArrayAccessorSegment" => Some("array_accessor"),
            "ArrayExpressionSegment" => Some("array_expression"),
            "ArrayLiteralSegment" => Some("array_literal"),
            "ArrayTypeSegment" => Some("array_type"),
            "AsAliasOperatorSegment" => Some("alias_operator"),
            "BaseFileSegment" => Some("file"),
            "BaseSegment" => Some("base"),
            "BinaryOperatorSegment" => Some("binary_operator"),
            "BitwiseAndSegment" => Some("binary_operator"),
            "BitwiseLShiftSegment" => Some("binary_operator"),
            "BitwiseOrSegment" => Some("binary_operator"),
            "BitwiseRShiftSegment" => Some("binary_operator"),
            "BracketedArguments" => Some("bracketed_arguments"),
            "BracketedSegment" => Some("bracketed"),
            "CSVColumnDefinitionSegment" => Some("csv_cols"),
            "CTEColumnList" => Some("cte_column_list"),
            "CTEDefinitionSegment" => Some("common_table_expression"),
            "CaseExpressionSegment" => Some("case_expression"),
            "CloseSchemaSegment" => Some("close_schema_statement"),
            "CodeSegment" => Some("raw"),
            "CollationReferenceSegment" => Some("collation_reference"),
            "ColumnConstraintSegment" => Some("column_constraint_segment"),
            "ColumnDatatypeSegment" => Some("column_datatype_definition"),
            "ColumnDefinitionSegment" => Some("column_definition"),
            "ColumnReferenceSegment" => Some("column_reference"),
            "ColumnsExpressionFunctionContentsSegment" => Some("columns_expression"),
            "ColumnsExpressionFunctionNameSegment" => Some("function_name"),
            "CommentClauseSegment" => Some("comment_clause"),
            "CommentSegment" => Some("comment"),
            "CommentStatementSegment" => Some("comment_statement"),
            "ComparisonOperatorSegment" => Some("comparison_operator"),
            "CompositeBinaryOperatorSegment" => Some("binary_operator"),
            "CompositeComparisonOperatorSegment" => Some("comparison_operator"),
            "ConcatSegment" => Some("binary_operator"),
            "ConnectByClauseSegment" => Some("connect_by_clause"),
            "ConnectionDefinition" => Some("connection_definition"),
            "ConsumerGroupParameterSegment" => Some("consumer_group_parameter"),
            "CreateAdapterScriptStatementSegment" => Some("create_adapter_script"),
            "CreateCastStatementSegment" => Some("create_cast_statement"),
            "CreateConnectionSegment" => Some("create_connection"),
            "CreateConsumerGroupSegment" => Some("create_consumer_group_statement"),
            "CreateDatabaseStatementSegment" => Some("create_database_statement"),
            "CreateFunctionStatementSegment" => Some("create_function_statement"),
            "CreateIndexStatementSegment" => Some("create_index_statement"),
            "CreateModelStatementSegment" => Some("create_model_statement"),
            "CreateRoleStatementSegment" => Some("create_role_statement"),
            "CreateSchemaStatementSegment" => Some("create_schema_statement"),
            "CreateScriptingLuaScriptStatementSegment" => Some("create_scripting_lua_script"),
            "CreateSequenceOptionsSegment" => Some("create_sequence_options_segment"),
            "CreateSequenceStatementSegment" => Some("create_sequence_statement"),
            "CreateTableLikeClauseSegment" => Some("table_like_clause"),
            "CreateTableStatementSegment" => Some("create_table_statement"),
            "CreateTriggerStatementSegment" => Some("create_trigger"),
            "CreateUDFScriptStatementSegment" => Some("create_udf_script"),
            "CreateUserStatementSegment" => Some("create_user_statement"),
            "CreateViewStatementSegment" => Some("create_view_statement"),
            "CreateVirtualSchemaStatementSegment" => Some("create_virtual_schema_statement"),
            "CubeFunctionNameSegment" => Some("function_name"),
            "CubeRollupClauseSegment" => Some("cube_rollup_clause"),
            "DatabaseReferenceSegment" => Some("database_reference"),
            "DatatypeSegment" => Some("data_type"),
            "DatePartFunctionNameSegment" => Some("function_name"),
            "DateTimeFunctionContentsSegment" => Some("function_contents"),
            "Dedent" => Some("dedent"),
            "DeleteStatementSegment" => Some("delete_statement"),
            "DescribeStatementSegment" => Some("describe_statement"),
            "DropCastStatementSegment" => Some("drop_cast_statement"),
            "DropConnectionStatementSegment" => Some("drop_connection_statement"),
            "DropConsumerGroupSegment" => Some("drop_consumer_group_statement"),
            "DropDatabaseStatementSegment" => Some("drop_database_statement"),
            "DropFunctionStatementSegment" => Some("drop_function_statement"),
            "DropIndexStatementSegment" => Some("drop_index_statement"),
            "DropModelStatementSegment" => Some("drop_MODELstatement"),
            "DropRoleStatementSegment" => Some("drop_role_statement"),
            "DropSchemaStatementSegment" => Some("drop_schema_statement"),
            "DropScriptStatementSegment" => Some("drop_script_statement"),
            "DropSequenceStatementSegment" => Some("drop_sequence_statement"),
            "DropTableStatementSegment" => Some("drop_table_statement"),
            "DropTriggerStatementSegment" => Some("drop_trigger"),
            "DropTypeStatementSegment" => Some("drop_type_statement"),
            "DropUserStatementSegment" => Some("drop_user_statement"),
            "DropViewStatementSegment" => Some("drop_view_statement"),
            "ElseClauseSegment" => Some("else_clause"),
            "EmitsSegment" => Some("emits_segment"),
            "EmptyStructLiteralBracketsSegment" => Some("struct_literal"),
            "EmptyStructLiteralSegment" => Some("typed_struct_literal"),
            "EqualsSegment" => Some("comparison_operator"),
            "ExecuteScriptSegment" => Some("execute_script_statement"),
            "ExplainStatementSegment" => Some("explain_statement"),
            "ExplainVirtualSegment" => Some("explain_virtual_statement"),
            "ExportIntoClauseSegment" => Some("export_into_clause"),
            "ExportStatementSegment" => Some("export_statement"),
            "ExpressionSegment" => Some("expression"),
            "ExtensionReferenceSegment" => Some("extension_reference"),
            "FBVColumnDefinitionSegment" => Some("fbv_cols"),
            "FetchClauseSegment" => Some("fetch_clause"),
            "FileOptionSegment" => Some("file_opts"),
            "FileSegment" => Some("file"),
            "FlushStatisticsSegment" => Some("flush_statistics_statement"),
            "FrameClauseSegment" => Some("frame_clause"),
            "FromClauseSegment" => Some("from_clause"),
            "FromExpressionElementSegment" => Some("from_expression_element"),
            "FromExpressionSegment" => Some("from_expression"),
            "FunctionAssignmentSegment" => Some("function_assignment"),
            "FunctionBodySegment" => Some("function_body"),
            "FunctionContentsSegment" => Some("function_contents"),
            "FunctionDefinitionGrammar" => Some("function_definition"),
            "FunctionForLoopSegment" => Some("function_for_loop"),
            "FunctionIfBranchSegment" => Some("function_if_branch"),
            "FunctionNameSegment" => Some("function_name"),
            "FunctionParameterListGrammar" => Some("function_parameter_list"),
            "FunctionReferenceSegment" => Some("function_reference"),
            "FunctionScriptStatementSegment" => Some("statement"),
            "FunctionSegment" => Some("function"),
            "FunctionWhileLoopSegment" => Some("function_while_loop"),
            "GrantRevokeConnectionRestrictedSegment" => Some("grant_revoke_connection_restricted"),
            "GrantRevokeConnectionSegment" => Some("grant_revoke_connection"),
            "GrantRevokeImpersonationSegment" => Some("grant_revoke_impersonation"),
            "GrantRevokeObjectPrivilegesSegment" => Some("grant_revoke_object_privileges"),
            "GrantRevokeRolesSegment" => Some("grant_revoke_roles"),
            "GrantRevokeSystemPrivilegesSegment" => Some("grant_revoke_system_privileges"),
            "GreaterThanOrEqualToSegment" => Some("comparison_operator"),
            "GreaterThanSegment" => Some("comparison_operator"),
            "GroupByClauseSegment" => Some("groupby_clause"),
            "GroupingExpressionList" => Some("grouping_expression_list"),
            "GroupingSetsClauseSegment" => Some("grouping_sets_clause"),
            "HavingClauseSegment" => Some("having_clause"),
            "IdentifierSegment" => Some("identifier"),
            "ImpersonateSegment" => Some("impersonate_statement"),
            "ImplicitIndent" => Some("indent"),
            "ImportColumnsSegment" => Some("import_columns"),
            "ImportErrorDestinationSegment" => Some("import_error_destination"),
            "ImportErrorsClauseSegment" => Some("import_errors_clause"),
            "ImportFromClauseSegment" => Some("import_from_clause"),
            "ImportFromExportIntoDbSrcSegment" => Some("import_export_dbsrc"),
            "ImportFromExportIntoFileSegment" => Some("import_file"),
            "ImportFromExportIntoScriptSegment" => Some("import_script"),
            "ImportStatementSegment" => Some("import_statement"),
            "Indent" => Some("indent"),
            "IndexColumnDefinitionSegment" => Some("index_column_definition"),
            "IndexReferenceSegment" => Some("index_reference"),
            "InsertStatementSegment" => Some("insert_statement"),
            "IntervalExpressionSegment" => Some("interval_expression"),
            "IntoTableSegment" => Some("into_table_clause"),
            "JoinClauseSegment" => Some("join_clause"),
            "JoinOnConditionSegment" => Some("join_on_condition"),
            "KeywordSegment" => Some("keyword"),
            "KillSegment" => Some("kill_statement"),
            "LessThanOrEqualToSegment" => Some("comparison_operator"),
            "LessThanSegment" => Some("comparison_operator"),
            "LimitClauseSegment" => Some("limit_clause"),
            "LiteralKeywordSegment" => Some("literal"),
            "LiteralSegment" => Some("literal"),
            "LocalAliasSegment" => Some("local_alias_segment"),
            "MLTableExpressionSegment" => Some("ml_table_expression"),
            "MapTypeSegment" => Some("map_type"),
            "MatchConditionSegment" => Some("match_condition"),
            "MergeDeleteClauseSegment" => Some("merge_delete_clause"),
            "MergeInsertClauseSegment" => Some("merge_insert_clause"),
            "MergeMatchSegment" => Some("merge_match"),
            "MergeMatchedClauseSegment" => Some("merge_when_matched_clause"),
            "MergeNotMatchedClauseSegment" => Some("merge_when_not_matched_clause"),
            "MergeStatementSegment" => Some("merge_statement"),
            "MergeUpdateClauseSegment" => Some("merge_update_clause"),
            "NamedWindowExpressionSegment" => Some("named_window_expression"),
            "NamedWindowSegment" => Some("named_window"),
            "NewlineSegment" => Some("newline"),
            "NotEqualToSegment" => Some("comparison_operator"),
            "ObjectLiteralElementSegment" => Some("object_literal_element"),
            "ObjectLiteralSegment" => Some("object_literal"),
            "ObjectPrivilegesSegment" => Some("object_privilege"),
            "ObjectReferenceSegment" => Some("object_reference"),
            "OffsetClauseSegment" => Some("offset_clause"),
            "OpenSchemaSegment" => Some("open_schema_statement"),
            "OrderByClauseSegment" => Some("orderby_clause"),
            "OverClauseSegment" => Some("over_clause"),
            "OverlapsClauseSegment" => Some("overlaps_clause"),
            "PartitionClauseSegment" => Some("partitionby_clause"),
            "PathSegment" => Some("path_segment"),
            "PreferringClauseSegment" => Some("preferring_clause"),
            "PreferringPlusPriorTermSegment" => Some("plus_prior_inverse"),
            "PreferringPreferenceTermSegment" => Some("preference_term"),
            "PreloadSegment" => Some("preload_statement"),
            "QualifiedNumericLiteralSegment" => Some("numeric_literal"),
            "QualifyClauseSegment" => Some("qualify_clause"),
            "RawSegment" => Some("raw"),
            "RecompressReorganizeSegment" => Some("recompress_reorganize_statement"),
            "ReferencingClauseSegment" => Some("referencing_clause"),
            "RejectClauseSegment" => Some("reject_clause"),
            "RenameStatementSegment" => Some("rename_statement"),
            "RoleReferenceSegment" => Some("role_reference"),
            "RollupFunctionNameSegment" => Some("function_name"),
            "SamplingExpressionSegment" => Some("sample_expression"),
            "SchemaReferenceSegment" => Some("schema_reference"),
            "ScriptContentSegment" => Some("script_content"),
            "ScriptReferenceSegment" => Some("script_reference"),
            "SelectClauseElementSegment" => Some("select_clause_element"),
            "SelectClauseModifierSegment" => Some("select_clause_modifier"),
            "SelectClauseSegment" => Some("select_clause"),
            "SelectStatementSegment" => Some("select_statement"),
            "SequenceReferenceSegment" => Some("sequence_reference"),
            "SetClauseListSegment" => Some("set_clause_list"),
            "SetClauseSegment" => Some("set_clause"),
            "SetExpressionSegment" => Some("set_expression"),
            "SetOperatorSegment" => Some("set_operator"),
            "SetSchemaStatementSegment" => Some("set_schema_statement"),
            "ShorthandCastSegment" => Some("cast_expression"),
            "SingleIdentifierListSegment" => Some("identifier_list"),
            "SizedArrayTypeSegment" => Some("sized_array_type"),
            "StatementSegment" => Some("statement"),
            "StructLiteralSegment" => Some("struct_literal"),
            "StructTypeSegment" => Some("struct_type"),
            "SymbolSegment" => Some("symbol"),
            "SystemPrivilegesSegment" => Some("system_privilege"),
            "TableConstraintSegment" => Some("table_constraint"),
            "TableContentDefinitionSegment" => Some("table_content_definition"),
            "TableDistributionPartitionClause" => Some("table_distribution_partition_clause"),
            "TableEndClauseSegment" => Some("table_end_clause_segment"),
            "TableExpressionSegment" => Some("table_expression"),
            "TableInlineConstraintSegment" => Some("table_constraint_definition"),
            "TableOutOfLineConstraintSegment" => Some("table_constraint_definition"),
            "TableReferenceSegment" => Some("table_reference"),
            "TablespaceReferenceSegment" => Some("tablespace_reference"),
            "TagReferenceSegment" => Some("tag_reference"),
            "TemporalQuerySegment" => Some("temporal_query"),
            "TimeZoneGrammar" => Some("time_zone_grammar"),
            "TransactionStatementSegment" => Some("transaction_statement"),
            "TriggerReferenceSegment" => Some("trigger_reference"),
            "TruncateAuditLogsSegment" => Some("truncate_audit_logs_statement"),
            "TruncateStatementSegment" => Some("truncate_table"),
            "TupleSegment" => Some("tuple"),
            "TypedArrayLiteralSegment" => Some("typed_array_literal"),
            "TypedStructLiteralSegment" => Some("typed_struct_literal"),
            "UnorderedSelectStatementSegment" => Some("select_statement"),
            "UnorderedSetExpressionSegment" => Some("set_expression"),
            "UpdateStatementSegment" => Some("update_statement"),
            "UseStatementSegment" => Some("use_statement"),
            "UserKerberosAuthSegment" => Some("kerberos_auth"),
            "UserLDAPAuthSegment" => Some("ldap_auth"),
            "UserOpenIDAuthSegment" => Some("openid_auth"),
            "UserPasswordAuthSegment" => Some("password_auth"),
            "ValuesClauseSegment" => Some("values_clause"),
            "ValuesRangeClauseSegment" => Some("values_range_clause"),
            "ViewReferenceSegment" => Some("view_reference"),
            "WhenClauseSegment" => Some("when_clause"),
            "WhereClauseSegment" => Some("where_clause"),
            "WhitespaceSegment" => Some("whitespace"),
            "WildcardExpressionSegment" => Some("wildcard_expression"),
            "WildcardIdentifierSegment" => Some("wildcard_identifier"),
            "WindowSpecificationSegment" => Some("window_specification"),
            "WithCompoundNonSelectStatementSegment" => Some("with_compound_statement"),
            "WithCompoundStatementSegment" => Some("with_compound_statement"),
            "WithDataClauseSegment" => Some("with_data_clause"),
            "WithFillSegment" => Some("with_fill"),
            "WithInvalidForeignKeySegment" => Some("with_invalid_foreign_key_clause"),
            "WithInvalidUniquePKSegment" => Some("with_invalid_unique_pk_clause"),
            "WithNoSchemaBindingClauseSegment" => Some("with_no_schema_binding_clause"),
            "WordSegment" => Some("word"),
            _ => None,
    }
}

pub fn get_exasol_root_grammar() -> Arc<Grammar> {
    get_exasol_segment_grammar(
        "FileSegment"
    ).expect("Root grammar missing.")
}

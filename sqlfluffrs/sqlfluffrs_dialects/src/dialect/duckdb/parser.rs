/* This is a generated file! */
#![cfg_attr(rustfmt, rustfmt_skip)]
use std::sync::Arc;
use once_cell::sync::Lazy;
use sqlfluffrs_types::{Grammar, ParseMode, SimpleHint};
use sqlfluffrs_types::regex::RegexMode;

// name='AbortKeywordSegment'
pub static ABORT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ABORT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AbsoluteKeywordSegment'
pub static ABSOLUTE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ABSOLUTE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AccessKeywordSegment'
pub static ACCESS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ACCESS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AccessStatementSegment'
pub static ACCESS_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AccessStatementSegment
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "GrantKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GRANT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RoleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UserKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WarehouseKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WAREHOUSE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DatabaseKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATABASE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IntegrationKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INTEGRATION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATABASE".to_string(), "INTEGRATION".to_string(), "ROLE".to_string(), "USER".to_string(), "WAREHOUSE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ApplyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["APPLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MaskingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MASKING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PolicyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["POLICY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["APPLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExecuteKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXECUTE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TaskKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TASK".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXECUTE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ManageKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MANAGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "GrantsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GRANTS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MANAGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "MonitorKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MONITOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExecutionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "UsageKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USAGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MONITOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["APPLY".to_string(), "CREATE".to_string(), "EXECUTE".to_string(), "MANAGE".to_string(), "MONITOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SchemaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "MaskingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MASKING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PolicyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["POLICY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MASKING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PipeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PIPE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ViewKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VIEW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StageKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STAGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FUNCTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ProcedureKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PROCEDURE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RoutineKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROUTINE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SequenceKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SEQUENCE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StreamKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STREAM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TaskKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TASK".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "MaterializedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MATERIALIZED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ViewKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VIEW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MATERIALIZED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExternalKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXTERNAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXTERNAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FileKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FILE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FormatKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FORMAT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FILE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXTERNAL".to_string(), "FILE".to_string(), "FUNCTION".to_string(), "MATERIALIZED".to_string(), "PROCEDURE".to_string(), "ROUTINE".to_string(), "SEQUENCE".to_string(), "STAGE".to_string(), "STREAM".to_string(), "TABLE".to_string(), "TASK".to_string(), "VIEW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXTERNAL".to_string(), "FILE".to_string(), "FUNCTION".to_string(), "MASKING".to_string(), "MATERIALIZED".to_string(), "PIPE".to_string(), "PROCEDURE".to_string(), "ROUTINE".to_string(), "SCHEMA".to_string(), "SEQUENCE".to_string(), "STAGE".to_string(), "STREAM".to_string(), "TABLE".to_string(), "TASK".to_string(), "VIEW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "UseKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SchemaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CatalogKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CATALOG".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CATALOG".to_string(), "SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ImportedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IMPORTED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PrivilegesKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PRIVILEGES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IMPORTED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ApplyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["APPLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConnectKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONNECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DeleteKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DELETE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExecuteKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXECUTE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "InsertKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INSERT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ModifyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MODIFY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MonitorKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MONITOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OperateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OPERATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OwnershipKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OWNERSHIP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ReadKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["READ".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Reference_usageKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REFERENCE_USAGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ReferencesKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REFERENCES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SelectKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SELECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TempKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TEMP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TemporaryKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TEMPORARY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TriggerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TRIGGER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TruncateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TRUNCATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UpdateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UPDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UsageKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USAGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Use_any_roleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USE_ANY_ROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WriteKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WRITE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AllKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PrivilegesKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PRIVILEGES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string(), "APPLY".to_string(), "CONNECT".to_string(), "CREATE".to_string(), "DELETE".to_string(), "EXECUTE".to_string(), "IMPORTED".to_string(), "INSERT".to_string(), "MODIFY".to_string(), "MONITOR".to_string(), "OPERATE".to_string(), "OWNERSHIP".to_string(), "READ".to_string(), "REFERENCES".to_string(), "REFERENCE_USAGE".to_string(), "SELECT".to_string(), "TEMP".to_string(), "TEMPORARY".to_string(), "TRIGGER".to_string(), "TRUNCATE".to_string(), "UPDATE".to_string(), "USAGE".to_string(), "USE".to_string(), "USE_ANY_ROLE".to_string(), "WRITE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BracketedColumnReferenceListGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string(), "APPLY".to_string(), "CONNECT".to_string(), "CREATE".to_string(), "DELETE".to_string(), "EXECUTE".to_string(), "IMPORTED".to_string(), "INSERT".to_string(), "MODIFY".to_string(), "MONITOR".to_string(), "OPERATE".to_string(), "OWNERSHIP".to_string(), "READ".to_string(), "REFERENCES".to_string(), "REFERENCE_USAGE".to_string(), "SELECT".to_string(), "TEMP".to_string(), "TEMPORARY".to_string(), "TRIGGER".to_string(), "TRUNCATE".to_string(), "UPDATE".to_string(), "USAGE".to_string(), "USE".to_string(), "USE_ANY_ROLE".to_string(), "WRITE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string(), "APPLY".to_string(), "CONNECT".to_string(), "CREATE".to_string(), "DELETE".to_string(), "EXECUTE".to_string(), "IMPORTED".to_string(), "INSERT".to_string(), "MANAGE".to_string(), "MODIFY".to_string(), "MONITOR".to_string(), "OPERATE".to_string(), "OWNERSHIP".to_string(), "READ".to_string(), "REFERENCES".to_string(), "REFERENCE_USAGE".to_string(), "SELECT".to_string(), "TEMP".to_string(), "TEMPORARY".to_string(), "TRIGGER".to_string(), "TRUNCATE".to_string(), "UPDATE".to_string(), "USAGE".to_string(), "USE".to_string(), "USE_ANY_ROLE".to_string(), "WRITE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string(), "APPLY".to_string(), "CONNECT".to_string(), "CREATE".to_string(), "DELETE".to_string(), "EXECUTE".to_string(), "IMPORTED".to_string(), "INSERT".to_string(), "MANAGE".to_string(), "MODIFY".to_string(), "MONITOR".to_string(), "OPERATE".to_string(), "OWNERSHIP".to_string(), "READ".to_string(), "REFERENCES".to_string(), "REFERENCE_USAGE".to_string(), "SELECT".to_string(), "TEMP".to_string(), "TEMPORARY".to_string(), "TRIGGER".to_string(), "TRUNCATE".to_string(), "UPDATE".to_string(), "USAGE".to_string(), "USE".to_string(), "USE_ANY_ROLE".to_string(), "WRITE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AccountKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ACCOUNT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ResourceKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESOURCE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MonitorKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MONITOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESOURCE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WarehouseKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WAREHOUSE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DatabaseKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATABASE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DomainKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DOMAIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IntegrationKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INTEGRATION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LanguageKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LANGUAGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CatalogKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CATALOG".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RoleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TablespaceKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLESPACE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TypeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TYPE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ForeignKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOREIGN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ServerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SERVER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DataKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WrapperKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WRAPPER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATA".to_string(), "SERVER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOREIGN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AllKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemasKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMAS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "InKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DatabaseKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATABASE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FutureKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FUTURE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemasKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMAS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "InKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DatabaseKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATABASE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FUTURE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ViewKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VIEW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StageKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STAGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FUNCTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ProcedureKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PROCEDURE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RoutineKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROUTINE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SequenceKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SEQUENCE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StreamKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STREAM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TaskKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TASK".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "MaterializedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MATERIALIZED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ViewKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VIEW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MATERIALIZED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExternalKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXTERNAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXTERNAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FileKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FILE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FormatKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FORMAT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FILE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXTERNAL".to_string(), "FILE".to_string(), "FUNCTION".to_string(), "MATERIALIZED".to_string(), "PROCEDURE".to_string(), "ROUTINE".to_string(), "SEQUENCE".to_string(), "STAGE".to_string(), "STREAM".to_string(), "TABLE".to_string(), "TASK".to_string(), "VIEW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AllKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TablesKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ViewsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VIEWS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StagesKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STAGES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FUNCTIONS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ProceduresKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PROCEDURES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RoutinesKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROUTINES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SequencesKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SEQUENCES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StreamsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STREAMS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TasksKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TASKS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FUNCTIONS".to_string(), "PROCEDURES".to_string(), "ROUTINES".to_string(), "SEQUENCES".to_string(), "STAGES".to_string(), "STREAMS".to_string(), "TABLES".to_string(), "TASKS".to_string(), "VIEWS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "InKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FutureKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FUTURE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TablesKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ViewsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VIEWS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StagesKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STAGES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FUNCTIONS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ProceduresKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PROCEDURES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RoutinesKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROUTINES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SequencesKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SEQUENCES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StreamsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STREAMS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TasksKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TASKS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FUNCTIONS".to_string(), "PROCEDURES".to_string(), "ROUTINES".to_string(), "SEQUENCES".to_string(), "STAGES".to_string(), "STREAMS".to_string(), "TABLES".to_string(), "TASKS".to_string(), "VIEWS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "InKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DatabaseKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATABASE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATABASE".to_string(), "SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FUTURE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string(), "CATALOG".to_string(), "DATABASE".to_string(), "DOMAIN".to_string(), "EXTERNAL".to_string(), "FILE".to_string(), "FOREIGN".to_string(), "FUNCTION".to_string(), "FUTURE".to_string(), "INTEGRATION".to_string(), "LANGUAGE".to_string(), "MATERIALIZED".to_string(), "PROCEDURE".to_string(), "RESOURCE".to_string(), "ROLE".to_string(), "ROUTINE".to_string(), "SCHEMA".to_string(), "SEQUENCE".to_string(), "STAGE".to_string(), "STREAM".to_string(), "TABLE".to_string(), "TABLESPACE".to_string(), "TASK".to_string(), "TYPE".to_string(), "VIEW".to_string(), "WAREHOUSE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FunctionNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "FunctionParameterListGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "WildcardIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FromKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LargeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LARGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OBJECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LARGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string(), "APPLY".to_string(), "CONNECT".to_string(), "CREATE".to_string(), "DELETE".to_string(), "EXECUTE".to_string(), "IMPORTED".to_string(), "INSERT".to_string(), "MANAGE".to_string(), "MODIFY".to_string(), "MONITOR".to_string(), "OPERATE".to_string(), "OWNERSHIP".to_string(), "READ".to_string(), "REFERENCES".to_string(), "REFERENCE_USAGE".to_string(), "SELECT".to_string(), "TEMP".to_string(), "TEMPORARY".to_string(), "TRIGGER".to_string(), "TRUNCATE".to_string(), "UPDATE".to_string(), "USAGE".to_string(), "USE".to_string(), "USE_ANY_ROLE".to_string(), "WRITE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RoleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OwnershipKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OWNERSHIP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UserKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OWNERSHIP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "GroupKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UserKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RoleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ShareKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SHARE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUP".to_string(), "ROLE".to_string(), "SHARE".to_string(), "USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RoleReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "FunctionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "PublicKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PUBLIC".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "GrantKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GRANT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OptionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OPTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AdminKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADMIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OptionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OPTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CopyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COPY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CurrentKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "GrantsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GRANTS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COPY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COPY".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "GrantedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GRANTED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "Current_userKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Session_userKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SESSION_USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GRANTED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GRANT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RevokeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REVOKE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "GrantKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GRANT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OptionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OPTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ForKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GRANT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RoleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UserKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WarehouseKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WAREHOUSE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DatabaseKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATABASE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IntegrationKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INTEGRATION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATABASE".to_string(), "INTEGRATION".to_string(), "ROLE".to_string(), "USER".to_string(), "WAREHOUSE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ApplyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["APPLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MaskingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MASKING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PolicyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["POLICY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["APPLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExecuteKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXECUTE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TaskKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TASK".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXECUTE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ManageKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MANAGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "GrantsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GRANTS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MANAGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "MonitorKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MONITOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExecutionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "UsageKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USAGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MONITOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["APPLY".to_string(), "CREATE".to_string(), "EXECUTE".to_string(), "MANAGE".to_string(), "MONITOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SchemaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "MaskingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MASKING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PolicyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["POLICY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MASKING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PipeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PIPE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ViewKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VIEW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StageKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STAGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FUNCTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ProcedureKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PROCEDURE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RoutineKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROUTINE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SequenceKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SEQUENCE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StreamKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STREAM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TaskKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TASK".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "MaterializedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MATERIALIZED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ViewKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VIEW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MATERIALIZED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExternalKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXTERNAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXTERNAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FileKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FILE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FormatKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FORMAT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FILE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXTERNAL".to_string(), "FILE".to_string(), "FUNCTION".to_string(), "MATERIALIZED".to_string(), "PROCEDURE".to_string(), "ROUTINE".to_string(), "SEQUENCE".to_string(), "STAGE".to_string(), "STREAM".to_string(), "TABLE".to_string(), "TASK".to_string(), "VIEW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXTERNAL".to_string(), "FILE".to_string(), "FUNCTION".to_string(), "MASKING".to_string(), "MATERIALIZED".to_string(), "PIPE".to_string(), "PROCEDURE".to_string(), "ROUTINE".to_string(), "SCHEMA".to_string(), "SEQUENCE".to_string(), "STAGE".to_string(), "STREAM".to_string(), "TABLE".to_string(), "TASK".to_string(), "VIEW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "UseKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SchemaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CatalogKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CATALOG".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CATALOG".to_string(), "SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ImportedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IMPORTED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PrivilegesKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PRIVILEGES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IMPORTED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ApplyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["APPLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConnectKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONNECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DeleteKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DELETE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExecuteKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXECUTE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "InsertKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INSERT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ModifyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MODIFY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MonitorKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MONITOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OperateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OPERATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OwnershipKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OWNERSHIP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ReadKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["READ".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Reference_usageKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REFERENCE_USAGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ReferencesKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REFERENCES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SelectKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SELECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TempKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TEMP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TemporaryKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TEMPORARY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TriggerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TRIGGER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TruncateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TRUNCATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UpdateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UPDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UsageKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USAGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Use_any_roleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USE_ANY_ROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WriteKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WRITE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AllKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PrivilegesKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PRIVILEGES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string(), "APPLY".to_string(), "CONNECT".to_string(), "CREATE".to_string(), "DELETE".to_string(), "EXECUTE".to_string(), "IMPORTED".to_string(), "INSERT".to_string(), "MODIFY".to_string(), "MONITOR".to_string(), "OPERATE".to_string(), "OWNERSHIP".to_string(), "READ".to_string(), "REFERENCES".to_string(), "REFERENCE_USAGE".to_string(), "SELECT".to_string(), "TEMP".to_string(), "TEMPORARY".to_string(), "TRIGGER".to_string(), "TRUNCATE".to_string(), "UPDATE".to_string(), "USAGE".to_string(), "USE".to_string(), "USE_ANY_ROLE".to_string(), "WRITE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BracketedColumnReferenceListGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string(), "APPLY".to_string(), "CONNECT".to_string(), "CREATE".to_string(), "DELETE".to_string(), "EXECUTE".to_string(), "IMPORTED".to_string(), "INSERT".to_string(), "MODIFY".to_string(), "MONITOR".to_string(), "OPERATE".to_string(), "OWNERSHIP".to_string(), "READ".to_string(), "REFERENCES".to_string(), "REFERENCE_USAGE".to_string(), "SELECT".to_string(), "TEMP".to_string(), "TEMPORARY".to_string(), "TRIGGER".to_string(), "TRUNCATE".to_string(), "UPDATE".to_string(), "USAGE".to_string(), "USE".to_string(), "USE_ANY_ROLE".to_string(), "WRITE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string(), "APPLY".to_string(), "CONNECT".to_string(), "CREATE".to_string(), "DELETE".to_string(), "EXECUTE".to_string(), "IMPORTED".to_string(), "INSERT".to_string(), "MANAGE".to_string(), "MODIFY".to_string(), "MONITOR".to_string(), "OPERATE".to_string(), "OWNERSHIP".to_string(), "READ".to_string(), "REFERENCES".to_string(), "REFERENCE_USAGE".to_string(), "SELECT".to_string(), "TEMP".to_string(), "TEMPORARY".to_string(), "TRIGGER".to_string(), "TRUNCATE".to_string(), "UPDATE".to_string(), "USAGE".to_string(), "USE".to_string(), "USE_ANY_ROLE".to_string(), "WRITE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string(), "APPLY".to_string(), "CONNECT".to_string(), "CREATE".to_string(), "DELETE".to_string(), "EXECUTE".to_string(), "IMPORTED".to_string(), "INSERT".to_string(), "MANAGE".to_string(), "MODIFY".to_string(), "MONITOR".to_string(), "OPERATE".to_string(), "OWNERSHIP".to_string(), "READ".to_string(), "REFERENCES".to_string(), "REFERENCE_USAGE".to_string(), "SELECT".to_string(), "TEMP".to_string(), "TEMPORARY".to_string(), "TRIGGER".to_string(), "TRUNCATE".to_string(), "UPDATE".to_string(), "USAGE".to_string(), "USE".to_string(), "USE_ANY_ROLE".to_string(), "WRITE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AccountKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ACCOUNT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ResourceKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESOURCE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MonitorKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MONITOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESOURCE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WarehouseKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WAREHOUSE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DatabaseKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATABASE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DomainKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DOMAIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IntegrationKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INTEGRATION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LanguageKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LANGUAGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CatalogKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CATALOG".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RoleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TablespaceKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLESPACE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TypeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TYPE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ForeignKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOREIGN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ServerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SERVER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DataKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WrapperKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WRAPPER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATA".to_string(), "SERVER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOREIGN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AllKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemasKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMAS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "InKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DatabaseKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATABASE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FutureKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FUTURE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemasKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMAS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "InKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DatabaseKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATABASE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FUTURE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ViewKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VIEW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StageKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STAGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FUNCTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ProcedureKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PROCEDURE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RoutineKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROUTINE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SequenceKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SEQUENCE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StreamKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STREAM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TaskKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TASK".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "MaterializedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MATERIALIZED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ViewKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VIEW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MATERIALIZED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExternalKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXTERNAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXTERNAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FileKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FILE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FormatKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FORMAT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FILE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXTERNAL".to_string(), "FILE".to_string(), "FUNCTION".to_string(), "MATERIALIZED".to_string(), "PROCEDURE".to_string(), "ROUTINE".to_string(), "SEQUENCE".to_string(), "STAGE".to_string(), "STREAM".to_string(), "TABLE".to_string(), "TASK".to_string(), "VIEW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AllKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TablesKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ViewsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VIEWS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StagesKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STAGES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FUNCTIONS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ProceduresKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PROCEDURES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RoutinesKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROUTINES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SequencesKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SEQUENCES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StreamsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STREAMS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TasksKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TASKS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FUNCTIONS".to_string(), "PROCEDURES".to_string(), "ROUTINES".to_string(), "SEQUENCES".to_string(), "STAGES".to_string(), "STREAMS".to_string(), "TABLES".to_string(), "TASKS".to_string(), "VIEWS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "InKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FutureKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FUTURE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TablesKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ViewsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VIEWS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StagesKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STAGES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FUNCTIONS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ProceduresKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PROCEDURES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RoutinesKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROUTINES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SequencesKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SEQUENCES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StreamsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STREAMS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TasksKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TASKS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FUNCTIONS".to_string(), "PROCEDURES".to_string(), "ROUTINES".to_string(), "SEQUENCES".to_string(), "STAGES".to_string(), "STREAMS".to_string(), "TABLES".to_string(), "TASKS".to_string(), "VIEWS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "InKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DatabaseKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATABASE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATABASE".to_string(), "SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FUTURE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string(), "CATALOG".to_string(), "DATABASE".to_string(), "DOMAIN".to_string(), "EXTERNAL".to_string(), "FILE".to_string(), "FOREIGN".to_string(), "FUNCTION".to_string(), "FUTURE".to_string(), "INTEGRATION".to_string(), "LANGUAGE".to_string(), "MATERIALIZED".to_string(), "PROCEDURE".to_string(), "RESOURCE".to_string(), "ROLE".to_string(), "ROUTINE".to_string(), "SCHEMA".to_string(), "SEQUENCE".to_string(), "STAGE".to_string(), "STREAM".to_string(), "TABLE".to_string(), "TABLESPACE".to_string(), "TASK".to_string(), "TYPE".to_string(), "VIEW".to_string(), "WAREHOUSE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FunctionNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "FunctionParameterListGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "WildcardIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FromKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LargeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LARGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OBJECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LARGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string(), "APPLY".to_string(), "CONNECT".to_string(), "CREATE".to_string(), "DELETE".to_string(), "EXECUTE".to_string(), "IMPORTED".to_string(), "INSERT".to_string(), "MANAGE".to_string(), "MODIFY".to_string(), "MONITOR".to_string(), "OPERATE".to_string(), "OWNERSHIP".to_string(), "READ".to_string(), "REFERENCES".to_string(), "REFERENCE_USAGE".to_string(), "SELECT".to_string(), "TEMP".to_string(), "TEMPORARY".to_string(), "TRIGGER".to_string(), "TRUNCATE".to_string(), "UPDATE".to_string(), "USAGE".to_string(), "USE".to_string(), "USE_ANY_ROLE".to_string(), "WRITE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RoleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OwnershipKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OWNERSHIP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UserKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OWNERSHIP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "FromKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "GroupKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UserKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RoleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ShareKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SHARE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUP".to_string(), "ROLE".to_string(), "SHARE".to_string(), "USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DropBehaviorGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string(), "RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REVOKE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GRANT".to_string(), "REVOKE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AccessorGrammar'
pub static ACCESSOR_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ArrayAccessorSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["[".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SemiStructuredAccessorSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string(), "[".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AccountKeywordSegment'
pub static ACCOUNT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ACCOUNT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AccountsKeywordSegment'
pub static ACCOUNTS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ACCOUNTS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ActionKeywordSegment'
pub static ACTION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ACTION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AddKeywordSegment'
pub static ADD_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ADD",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AdjacentSegment'
pub static ADJACENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AdjacentSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "MinusSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["-".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PipeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["|".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MinusSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["-".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: false,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["-".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AdminKeywordSegment'
pub static ADMIN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ADMIN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AfterKeywordSegment'
pub static AFTER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "AFTER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AggregateKeywordSegment'
pub static AGGREGATE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "AGGREGATE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AggregateOrderByClause'
pub static AGGREGATE_ORDER_BY_CLAUSE: Lazy<Arc<Grammar>> = Lazy::new(||
// AggregateOrderByClause
Arc::new(Grammar::Ref {
    name: "OrderByClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AliasExpressionSegment'
pub static ALIAS_EXPRESSION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AliasExpressionSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::Ref {
    name: "AsAliasOperatorSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierListSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "SingleQuotedIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["single_quote".to_string()]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("dedent"))
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='AliasKeywordSegment'
pub static ALIAS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ALIAS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AliasedTableReferenceGrammar'
pub static ALIASED_TABLE_REFERENCE_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AliasExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='AllKeywordSegment'
pub static ALL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ALL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Allow_connectionsKeywordSegment'
pub static ALLOW_CONNECTIONS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ALLOW_CONNECTIONS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AlsoKeywordSegment'
pub static ALSO_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ALSO",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AlterAggregateStatementSegment'
pub static ALTER_AGGREGATE_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AlterAggregateStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AggregateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AGGREGATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FunctionParameterListGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Anything)
,
Arc::new(Grammar::Ref {
    name: "StarSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["*".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RenameKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OwnerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OWNER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "Current_roleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_ROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Current_userKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Session_userKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SESSION_USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RoleReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OWNER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OWNER".to_string(), "RENAME".to_string(), "SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AlterDatabaseStatementSegment'
pub static ALTER_DATABASE_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AlterDatabaseStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DatabaseKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATABASE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DatabaseReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "Allow_connectionsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALLOW_CONNECTIONS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BooleanLiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FALSE".to_string(), "TRUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALLOW_CONNECTIONS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ConnectionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONNECTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LimitKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LIMIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONNECTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "Is_templateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IS_TEMPLATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BooleanLiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FALSE".to_string(), "TRUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IS_TEMPLATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 1,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALLOW_CONNECTIONS".to_string(), "CONNECTION".to_string(), "IS_TEMPLATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALLOW_CONNECTIONS".to_string(), "CONNECTION".to_string(), "IS_TEMPLATE".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RenameKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DatabaseReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OwnerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OWNER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "Current_roleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_ROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Current_userKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Session_userKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SESSION_USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OWNER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TablespaceKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLESPACE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TablespaceReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string(), "TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DefaultKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "+".to_string(), "-".to_string(), ":".to_string(), "ARRAY".to_string(), "DATE".to_string(), "FALSE".to_string(), "INTERVAL".to_string(), "NULL".to_string(), "TIME".to_string(), "TIMESTAMP".to_string(), "TIMESTAMPTZ".to_string(), "TIMETZ".to_string(), "TRUE".to_string(), "VARIADIC".to_string(), "[".to_string(), "{".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_numeric_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "numeric_literal".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NakedIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "QuotedIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["double_quote".to_string()]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string(), "TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FromKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CurrentKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string(), "FROM".to_string(), "TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ResetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AllKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALLOW_CONNECTIONS".to_string(), "CONNECTION".to_string(), "IS_TEMPLATE".to_string(), "OWNER".to_string(), "RENAME".to_string(), "RESET".to_string(), "SET".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AlterDefaultPrivilegesGrantSegment'
pub static ALTER_DEFAULT_PRIVILEGES_GRANT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AlterDefaultPrivilegesGrantSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "GrantKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GRANT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AlterDefaultPrivilegesObjectPrivilegesSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string(), "CREATE".to_string(), "DELETE".to_string(), "EXECUTE".to_string(), "INSERT".to_string(), "REFERENCES".to_string(), "SELECT".to_string(), "TRIGGER".to_string(), "TRUNCATE".to_string(), "UPDATE".to_string(), "USAGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AlterDefaultPrivilegesSchemaObjectsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FUNCTIONS".to_string(), "ROUTINES".to_string(), "SCHEMAS".to_string(), "SEQUENCES".to_string(), "TABLES".to_string(), "TYPES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterDefaultPrivilegesToFromRolesSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "GrantKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GRANT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OptionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OPTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GRANT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AlterDefaultPrivilegesObjectPrivilegesSegment'
pub static ALTER_DEFAULT_PRIVILEGES_OBJECT_PRIVILEGES_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AlterDefaultPrivilegesObjectPrivilegesSegment
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AllKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PrivilegesKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PRIVILEGES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DeleteKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DELETE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExecuteKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXECUTE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "InsertKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INSERT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ReferencesKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REFERENCES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SelectKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SELECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TriggerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TRIGGER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TruncateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TRUNCATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UpdateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UPDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UsageKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USAGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string(), "DELETE".to_string(), "EXECUTE".to_string(), "INSERT".to_string(), "REFERENCES".to_string(), "SELECT".to_string(), "TRIGGER".to_string(), "TRUNCATE".to_string(), "UPDATE".to_string(), "USAGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string(), "CREATE".to_string(), "DELETE".to_string(), "EXECUTE".to_string(), "INSERT".to_string(), "REFERENCES".to_string(), "SELECT".to_string(), "TRIGGER".to_string(), "TRUNCATE".to_string(), "UPDATE".to_string(), "USAGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AlterDefaultPrivilegesRevokeSegment'
pub static ALTER_DEFAULT_PRIVILEGES_REVOKE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AlterDefaultPrivilegesRevokeSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RevokeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REVOKE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "GrantKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GRANT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OptionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OPTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ForKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GRANT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AlterDefaultPrivilegesObjectPrivilegesSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string(), "CREATE".to_string(), "DELETE".to_string(), "EXECUTE".to_string(), "INSERT".to_string(), "REFERENCES".to_string(), "SELECT".to_string(), "TRIGGER".to_string(), "TRUNCATE".to_string(), "UPDATE".to_string(), "USAGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AlterDefaultPrivilegesSchemaObjectsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FUNCTIONS".to_string(), "ROUTINES".to_string(), "SCHEMAS".to_string(), "SEQUENCES".to_string(), "TABLES".to_string(), "TYPES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FromKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterDefaultPrivilegesToFromRolesSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "RestrictKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CascadeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DropBehaviorGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string(), "RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REVOKE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AlterDefaultPrivilegesSchemaObjectsSegment'
pub static ALTER_DEFAULT_PRIVILEGES_SCHEMA_OBJECTS_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AlterDefaultPrivilegesSchemaObjectsSegment
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TablesKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FUNCTIONS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RoutinesKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROUTINES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SequencesKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SEQUENCES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TypesKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TYPES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemasKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMAS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FUNCTIONS".to_string(), "ROUTINES".to_string(), "SCHEMAS".to_string(), "SEQUENCES".to_string(), "TABLES".to_string(), "TYPES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AlterDefaultPrivilegesStatementSegment'
pub static ALTER_DEFAULT_PRIVILEGES_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AlterDefaultPrivilegesStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DefaultKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PrivilegesKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PRIVILEGES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ForKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RoleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UserKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROLE".to_string(), "USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "InKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "GrantKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GRANT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RevokeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REVOKE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "InKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SchemaReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "GrantKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GRANT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RevokeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REVOKE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterDefaultPrivilegesGrantSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GRANT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AlterDefaultPrivilegesRevokeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REVOKE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GRANT".to_string(), "REVOKE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AlterDefaultPrivilegesToFromRolesSegment'
pub static ALTER_DEFAULT_PRIVILEGES_TO_FROM_ROLES_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AlterDefaultPrivilegesToFromRolesSegment
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "GroupKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RoleReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "PublicKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PUBLIC".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='AlterDomainStatementSegment'
pub static ALTER_DOMAIN_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AlterDomainStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DomainKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DOMAIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DefaultKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DefaultKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string(), "SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NotKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NullKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string(), "SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AddKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ConstraintKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRAINT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRAINT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NotKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NullKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOT".to_string(), "NULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CheckKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHECK".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHECK".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHECK".to_string(), "NOT".to_string(), "NULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NotKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ValidKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VALID".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConstraintKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRAINT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RestrictKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CascadeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string(), "RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RenameKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConstraintKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRAINT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ValidateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VALIDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConstraintKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRAINT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VALIDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OwnerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OWNER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "Current_roleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_ROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Current_userKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Session_userKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SESSION_USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OWNER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RenameKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string(), "DROP".to_string(), "OWNER".to_string(), "RENAME".to_string(), "SET".to_string(), "VALIDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AlterExtensionStatementSegment'
pub static ALTER_EXTENSION_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AlterExtensionStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExtensionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXTENSION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExtensionReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "UpdateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UPDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "+".to_string(), "-".to_string(), ":".to_string(), "ARRAY".to_string(), "DATE".to_string(), "FALSE".to_string(), "INTERVAL".to_string(), "NULL".to_string(), "TIME".to_string(), "TIMESTAMP".to_string(), "TIMESTAMPTZ".to_string(), "TIMETZ".to_string(), "TRUE".to_string(), "VARIADIC".to_string(), "[".to_string(), "{".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_numeric_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "numeric_literal".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UPDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SchemaReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "Current_schemaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AddKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string(), "DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AccessKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ACCESS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MethodKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["METHOD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ACCESS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CollationKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLLATION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConversionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONVERSION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DomainKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DOMAIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "EventKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EVENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TriggerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TRIGGER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EVENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ForeignKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOREIGN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DataKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WrapperKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WRAPPER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOREIGN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ForeignKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOREIGN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOREIGN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ProceduralKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PROCEDURAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LanguageKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LANGUAGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LANGUAGE".to_string(), "PROCEDURAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SequenceKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SEQUENCE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ServerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SERVER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TextKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TEXT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SearchKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SEARCH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ConfigurationKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONFIGURATION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DictionaryKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DICTIONARY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ParserKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PARSER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TemplateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TEMPLATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONFIGURATION".to_string(), "DICTIONARY".to_string(), "PARSER".to_string(), "TEMPLATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TEXT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TypeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TYPE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ACCESS".to_string(), "COLLATION".to_string(), "CONVERSION".to_string(), "DOMAIN".to_string(), "EVENT".to_string(), "FOREIGN".to_string(), "LANGUAGE".to_string(), "PROCEDURAL".to_string(), "SCHEMA".to_string(), "SEQUENCE".to_string(), "SERVER".to_string(), "TEXT".to_string(), "TYPE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ACCESS".to_string(), "COLLATION".to_string(), "CONVERSION".to_string(), "DOMAIN".to_string(), "EVENT".to_string(), "FOREIGN".to_string(), "LANGUAGE".to_string(), "PROCEDURAL".to_string(), "SCHEMA".to_string(), "SEQUENCE".to_string(), "SERVER".to_string(), "TEXT".to_string(), "TYPE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "MaterializedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MATERIALIZED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ViewKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VIEW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MATERIALIZED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ViewKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VIEW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MATERIALIZED".to_string(), "TABLE".to_string(), "VIEW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MATERIALIZED".to_string(), "TABLE".to_string(), "VIEW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AggregateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AGGREGATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Anything)
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AGGREGATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CastKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CAST".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CAST".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FunctionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FUNCTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ProcedureKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PROCEDURE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RoutineKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROUTINE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FUNCTION".to_string(), "PROCEDURE".to_string(), "ROUTINE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FunctionNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "FunctionParameterListGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FUNCTION".to_string(), "PROCEDURE".to_string(), "ROUTINE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OperatorKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OPERATOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DatatypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DatatypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ClassKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CLASS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FamilyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FAMILY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CLASS".to_string(), "FAMILY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "UsingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IndexAccessMethodSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CLASS".to_string(), "FAMILY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OPERATOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TransformKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TRANSFORM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ForKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TypeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TYPE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TRANSFORM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ACCESS".to_string(), "AGGREGATE".to_string(), "CAST".to_string(), "COLLATION".to_string(), "CONVERSION".to_string(), "DOMAIN".to_string(), "EVENT".to_string(), "FOREIGN".to_string(), "FUNCTION".to_string(), "LANGUAGE".to_string(), "MATERIALIZED".to_string(), "OPERATOR".to_string(), "PROCEDURAL".to_string(), "PROCEDURE".to_string(), "ROUTINE".to_string(), "SCHEMA".to_string(), "SEQUENCE".to_string(), "SERVER".to_string(), "TABLE".to_string(), "TEXT".to_string(), "TRANSFORM".to_string(), "TYPE".to_string(), "VIEW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string(), "DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string(), "DROP".to_string(), "SET".to_string(), "UPDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AlterForeignTableActionSegment'
pub static ALTER_FOREIGN_TABLE_ACTION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AlterForeignTableActionSegment
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AddKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLUMN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfNotExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DatatypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CollateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLLATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CollationReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLLATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColumnConstraintSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHECK".to_string(), "COLLATE".to_string(), "DEFAULT".to_string(), "NOT".to_string(), "NULL".to_string(), "PRIMARY".to_string(), "REFERENCES".to_string(), "UNIQUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHECK".to_string(), "COLLATE".to_string(), "DEFAULT".to_string(), "NOT".to_string(), "NULL".to_string(), "PRIMARY".to_string(), "REFERENCES".to_string(), "UNIQUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLUMN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DropBehaviorGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string(), "RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLUMN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DataKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TypeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TYPE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DatatypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CollateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLLATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CollationReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLLATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "UsingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string(), "TYPE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DefaultKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "+".to_string(), "-".to_string(), ":".to_string(), "ARRAY".to_string(), "DATE".to_string(), "FALSE".to_string(), "INTERVAL".to_string(), "NULL".to_string(), "TIME".to_string(), "TIMESTAMP".to_string(), "TIMESTAMPTZ".to_string(), "TIMETZ".to_string(), "TRUE".to_string(), "VARIADIC".to_string(), "[".to_string(), "{".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_numeric_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "numeric_literal".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "BareFunctionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_CATALOG".to_string(), "CURRENT_DATE".to_string(), "CURRENT_ROLE".to_string(), "CURRENT_SCHEMA".to_string(), "CURRENT_TIME".to_string(), "CURRENT_TIMESTAMP".to_string(), "CURRENT_USER".to_string(), "LOCALTIME".to_string(), "LOCALTIMESTAMP".to_string(), "SESSION_USER".to_string(), "SYSTEM_USER".to_string(), "USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DefaultKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string(), "SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NotKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NullKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string(), "NOT".to_string(), "SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXPRESSION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AddKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "GeneratedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GENERATED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlwaysKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALWAYS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DefaultKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALWAYS".to_string(), "BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IdentityKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IDENTITY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterSequenceOptionsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string(), "CACHE".to_string(), "CYCLE".to_string(), "INCREMENT".to_string(), "MAXVALUE".to_string(), "MINVALUE".to_string(), "NO".to_string(), "OWNED".to_string(), "RESTART".to_string(), "SEQUENCE".to_string(), "START".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string(), "CACHE".to_string(), "CYCLE".to_string(), "INCREMENT".to_string(), "MAXVALUE".to_string(), "MINVALUE".to_string(), "NO".to_string(), "OWNED".to_string(), "RESTART".to_string(), "SEQUENCE".to_string(), "START".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "GeneratedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GENERATED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlwaysKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALWAYS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DefaultKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALWAYS".to_string(), "BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AlterSequenceOptionsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string(), "CACHE".to_string(), "CYCLE".to_string(), "INCREMENT".to_string(), "MAXVALUE".to_string(), "MINVALUE".to_string(), "NO".to_string(), "OWNED".to_string(), "RESTART".to_string(), "SEQUENCE".to_string(), "START".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RestartKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESTART".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESTART".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESTART".to_string(), "SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESTART".to_string(), "SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IdentityKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IDENTITY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StatisticsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STATISTICS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RelationOptionsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ResetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RelationOptionsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StorageKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STORAGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PlainKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PLAIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExternalKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXTERNAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExtendedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXTENDED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MainKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MAIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXTENDED".to_string(), "EXTERNAL".to_string(), "MAIN".to_string(), "PLAIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string(), "DROP".to_string(), "NOT".to_string(), "RESET".to_string(), "RESTART".to_string(), "SET".to_string(), "TYPE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AddKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableConstraintSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHECK".to_string(), "CONSTRAINT".to_string(), "EXCLUDE".to_string(), "FOREIGN".to_string(), "PRIMARY".to_string(), "UNIQUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AddKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableConstraintUsingIndexSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRAINT".to_string(), "PRIMARY".to_string(), "UNIQUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConstraintKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRAINT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DeferrableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFERRABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NotKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DeferrableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFERRABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFERRABLE".to_string(), "NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "InitiallyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INITIALLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DeferredKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFERRED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INITIALLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "InitiallyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INITIALLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ImmediateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IMMEDIATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INITIALLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INITIALLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ValidateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VALIDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConstraintKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRAINT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VALIDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConstraintKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRAINT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DropBehaviorGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string(), "RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "EnableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ENABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DisableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DISABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DISABLE".to_string(), "ENABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TriggerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TRIGGER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AllKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UserKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DISABLE".to_string(), "ENABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "EnableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ENABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ReplicaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REPLICA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AlwaysKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALWAYS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALWAYS".to_string(), "REPLICA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TriggerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TRIGGER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ENABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "EnableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ENABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DisableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DISABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "EnableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ENABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ReplicaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REPLICA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ENABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "EnableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ENABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RuleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RULE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ENABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DISABLE".to_string(), "ENABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RuleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RULE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DISABLE".to_string(), "ENABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DisableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DISABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EnableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ENABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ForceKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FORCE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NoKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ForceKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FORCE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DISABLE".to_string(), "ENABLE".to_string(), "FORCE".to_string(), "NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RowKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LevelKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LEVEL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SecurityKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SECURITY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DISABLE".to_string(), "ENABLE".to_string(), "FORCE".to_string(), "NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ClusterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CLUSTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CLUSTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WithoutKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITHOUT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ClusterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CLUSTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OidsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OIDS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CLUSTER".to_string(), "OIDS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TablespaceKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLESPACE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TablespaceReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LoggedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LOGGED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UnloggedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UNLOGGED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LOGGED".to_string(), "UNLOGGED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RelationOptionsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ResetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RelationOptionsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NoKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "InheritKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INHERIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INHERIT".to_string(), "NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OfKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NotKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OfKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OwnerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OWNER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "Current_roleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_ROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Current_userKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Session_userKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SESSION_USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OWNER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ReplicaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REPLICA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IdentityKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IDENTITY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DefaultKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "UsingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IndexKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INDEX".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IndexReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FullKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NothingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOTHING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string(), "FULL".to_string(), "NOTHING".to_string(), "USING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REPLICA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "COLUMN",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OptionsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OPTIONS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AddKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string(), "DROP".to_string(), "SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string(), "OPTIONS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string(), "ALTER".to_string(), "CLUSTER".to_string(), "DISABLE".to_string(), "DROP".to_string(), "ENABLE".to_string(), "FORCE".to_string(), "INHERIT".to_string(), "NO".to_string(), "NOT".to_string(), "OF".to_string(), "OPTIONS".to_string(), "OWNER".to_string(), "REPLICA".to_string(), "RESET".to_string(), "SET".to_string(), "VALIDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AlterForeignTableStatementSegment'
pub static ALTER_FOREIGN_TABLE_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AlterForeignTableStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ForeignKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOREIGN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OnlyKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ONLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "StarSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["*".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterForeignTableActionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string(), "ALTER".to_string(), "CLUSTER".to_string(), "DISABLE".to_string(), "DROP".to_string(), "ENABLE".to_string(), "FORCE".to_string(), "INHERIT".to_string(), "NO".to_string(), "NOT".to_string(), "OF".to_string(), "OPTIONS".to_string(), "OWNER".to_string(), "REPLICA".to_string(), "RESET".to_string(), "SET".to_string(), "VALIDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string(), "ALTER".to_string(), "CLUSTER".to_string(), "DISABLE".to_string(), "DROP".to_string(), "ENABLE".to_string(), "FORCE".to_string(), "INHERIT".to_string(), "NO".to_string(), "NOT".to_string(), "OF".to_string(), "OPTIONS".to_string(), "OWNER".to_string(), "REPLICA".to_string(), "RESET".to_string(), "SET".to_string(), "VALIDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RenameKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLUMN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RenameKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string(), "ALTER".to_string(), "CLUSTER".to_string(), "DISABLE".to_string(), "DROP".to_string(), "ENABLE".to_string(), "FORCE".to_string(), "INHERIT".to_string(), "NO".to_string(), "NOT".to_string(), "OF".to_string(), "OPTIONS".to_string(), "OWNER".to_string(), "RENAME".to_string(), "REPLICA".to_string(), "RESET".to_string(), "SET".to_string(), "VALIDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AlterFunctionActionSegment'
pub static ALTER_FUNCTION_ACTION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AlterFunctionActionSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CalledKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CALLED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NullKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "InputKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INPUT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CALLED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ReturnsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RETURNS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NullKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NullKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "InputKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INPUT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RETURNS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StrictKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CALLED".to_string(), "RETURNS".to_string(), "STRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ImmutableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IMMUTABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "VolatileKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VOLATILE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IMMUTABLE".to_string(), "STABLE".to_string(), "VOLATILE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NotKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LeakproofKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LEAKPROOF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LEAKPROOF".to_string(), "NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExternalKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXTERNAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SecurityKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SECURITY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DefinerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFINER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "InvokerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INVOKER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFINER".to_string(), "INVOKER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXTERNAL".to_string(), "SECURITY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ParallelKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PARALLEL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "UnsafeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UNSAFE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RestrictedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESTRICTED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SafeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SAFE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESTRICTED".to_string(), "SAFE".to_string(), "UNSAFE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PARALLEL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CostKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COST".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COST".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RowsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROWS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROWS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SupportKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SUPPORT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SUPPORT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string(), "TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "+".to_string(), "-".to_string(), ":".to_string(), "ARRAY".to_string(), "DATE".to_string(), "FALSE".to_string(), "INTERVAL".to_string(), "NULL".to_string(), "TIME".to_string(), "TIMESTAMP".to_string(), "TIMESTAMPTZ".to_string(), "TIMETZ".to_string(), "TRUE".to_string(), "VARIADIC".to_string(), "[".to_string(), "{".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_numeric_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "numeric_literal".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NakedIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DefaultKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string(), "TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FromKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CurrentKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string(), "FROM".to_string(), "TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ResetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AllKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CALLED".to_string(), "COST".to_string(), "EXTERNAL".to_string(), "IMMUTABLE".to_string(), "LEAKPROOF".to_string(), "NOT".to_string(), "PARALLEL".to_string(), "RESET".to_string(), "RETURNS".to_string(), "ROWS".to_string(), "SECURITY".to_string(), "SET".to_string(), "STABLE".to_string(), "STRICT".to_string(), "SUPPORT".to_string(), "VOLATILE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RestrictKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CALLED".to_string(), "COST".to_string(), "EXTERNAL".to_string(), "IMMUTABLE".to_string(), "LEAKPROOF".to_string(), "NOT".to_string(), "PARALLEL".to_string(), "RESET".to_string(), "RETURNS".to_string(), "ROWS".to_string(), "SECURITY".to_string(), "SET".to_string(), "STABLE".to_string(), "STRICT".to_string(), "SUPPORT".to_string(), "VOLATILE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AlterFunctionStatementSegment'
pub static ALTER_FUNCTION_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AlterFunctionStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FUNCTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FunctionNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "FunctionParameterListGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterFunctionActionSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CALLED".to_string(), "COST".to_string(), "EXTERNAL".to_string(), "IMMUTABLE".to_string(), "LEAKPROOF".to_string(), "NOT".to_string(), "PARALLEL".to_string(), "RESET".to_string(), "RETURNS".to_string(), "ROWS".to_string(), "SECURITY".to_string(), "SET".to_string(), "STABLE".to_string(), "STRICT".to_string(), "SUPPORT".to_string(), "VOLATILE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RenameKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OwnerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OWNER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "QuotedIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["double_quote".to_string()]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "Current_roleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_ROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Current_userKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Session_userKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SESSION_USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OWNER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NoKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DependsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEPENDS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExtensionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXTENSION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExtensionReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEPENDS".to_string(), "NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CALLED".to_string(), "COST".to_string(), "DEPENDS".to_string(), "EXTERNAL".to_string(), "IMMUTABLE".to_string(), "LEAKPROOF".to_string(), "NO".to_string(), "NOT".to_string(), "OWNER".to_string(), "PARALLEL".to_string(), "RENAME".to_string(), "RESET".to_string(), "RETURNS".to_string(), "ROWS".to_string(), "SECURITY".to_string(), "SET".to_string(), "STABLE".to_string(), "STRICT".to_string(), "SUPPORT".to_string(), "VOLATILE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AlterIndexStatementSegment'
pub static ALTER_INDEX_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AlterIndexStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IndexKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INDEX".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IndexReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RenameKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IndexReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TablespaceKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLESPACE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TablespaceReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AttachKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ATTACH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PartitionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PARTITION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IndexReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ATTACH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NoKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DependsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEPENDS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExtensionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXTENSION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExtensionReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEPENDS".to_string(), "NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "+".to_string(), "-".to_string(), ":".to_string(), "ARRAY".to_string(), "DATE".to_string(), "FALSE".to_string(), "INTERVAL".to_string(), "NULL".to_string(), "TIME".to_string(), "TIMESTAMP".to_string(), "TIMESTAMPTZ".to_string(), "TIMETZ".to_string(), "TRUE".to_string(), "VARIADIC".to_string(), "[".to_string(), "{".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_numeric_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "numeric_literal".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ResetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLUMN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StatisticsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STATISTICS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string(), "ATTACH".to_string(), "DEPENDS".to_string(), "NO".to_string(), "RENAME".to_string(), "RESET".to_string(), "SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AllKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "InKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TablespaceKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLESPACE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TablespaceReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OwnedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OWNED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RoleReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OWNED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TablespaceKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLESPACE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TablespaceReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "NowaitKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOWAIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AlterKeywordSegment'
pub static ALTER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ALTER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AlterMaterializedViewActionSegment'
pub static ALTER_MATERIALIZED_VIEW_ACTION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AlterMaterializedViewActionSegment
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLUMN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StatisticsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STATISTICS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "+".to_string(), "-".to_string(), ":".to_string(), "ARRAY".to_string(), "DATE".to_string(), "FALSE".to_string(), "INTERVAL".to_string(), "NULL".to_string(), "TIME".to_string(), "TIMESTAMP".to_string(), "TIMESTAMPTZ".to_string(), "TIMETZ".to_string(), "TRUE".to_string(), "VARIADIC".to_string(), "[".to_string(), "{".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_numeric_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "numeric_literal".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ResetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StorageKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STORAGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PlainKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PLAIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExternalKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXTERNAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExtendedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXTENDED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MainKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MAIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXTENDED".to_string(), "EXTERNAL".to_string(), "MAIN".to_string(), "PLAIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CompressionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COMPRESSION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESET".to_string(), "SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ClusterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CLUSTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CLUSTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WithoutKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITHOUT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ClusterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CLUSTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "+".to_string(), "-".to_string(), ":".to_string(), "ARRAY".to_string(), "DATE".to_string(), "FALSE".to_string(), "INTERVAL".to_string(), "NULL".to_string(), "TIME".to_string(), "TIMESTAMP".to_string(), "TIMESTAMPTZ".to_string(), "TIMETZ".to_string(), "TRUE".to_string(), "VARIADIC".to_string(), "[".to_string(), "{".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_numeric_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "numeric_literal".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ResetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OwnerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OWNER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "Current_roleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_ROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Current_userKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Session_userKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SESSION_USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OWNER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string(), "CLUSTER".to_string(), "OWNER".to_string(), "RESET".to_string(), "SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AlterMaterializedViewStatementSegment'
pub static ALTER_MATERIALIZED_VIEW_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AlterMaterializedViewStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MaterializedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MATERIALIZED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ViewKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VIEW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterMaterializedViewActionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string(), "CLUSTER".to_string(), "OWNER".to_string(), "RESET".to_string(), "SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string(), "CLUSTER".to_string(), "OWNER".to_string(), "RESET".to_string(), "SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RenameKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColumnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLUMN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLUMN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RenameKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string(), "CLUSTER".to_string(), "OWNER".to_string(), "RENAME".to_string(), "RESET".to_string(), "SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "NoKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DependsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEPENDS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExtensionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXTENSION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExtensionReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AllKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "InKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TablespaceKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLESPACE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TablespaceReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OwnedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OWNED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OWNED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TablespaceKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLESPACE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TablespaceReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NowaitKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOWAIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOWAIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AlterPolicyStatementSegment'
pub static ALTER_POLICY_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AlterPolicyStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PolicyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["POLICY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RenameKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::AnySetOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RoleReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "PublicKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PUBLIC".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Current_roleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_ROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Current_userKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Session_userKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SESSION_USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "UsingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CheckKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHECK".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 1,
    max_times: None,
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string(), "USING".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string(), "TO".to_string(), "USING".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AlterProcedureActionSegment'
pub static ALTER_PROCEDURE_ACTION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AlterProcedureActionSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExternalKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXTERNAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SecurityKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SECURITY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DefinerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFINER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "InvokerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INVOKER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFINER".to_string(), "INVOKER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXTERNAL".to_string(), "SECURITY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string(), "TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "+".to_string(), "-".to_string(), ":".to_string(), "ARRAY".to_string(), "DATE".to_string(), "FALSE".to_string(), "INTERVAL".to_string(), "NULL".to_string(), "TIME".to_string(), "TIMESTAMP".to_string(), "TIMESTAMPTZ".to_string(), "TIMETZ".to_string(), "TRUE".to_string(), "VARIADIC".to_string(), "[".to_string(), "{".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_numeric_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "numeric_literal".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NakedIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DefaultKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string(), "TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FromKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CurrentKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string(), "FROM".to_string(), "TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ResetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AllKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXTERNAL".to_string(), "RESET".to_string(), "SECURITY".to_string(), "SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RestrictKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXTERNAL".to_string(), "RESET".to_string(), "SECURITY".to_string(), "SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AlterProcedureStatementSegment'
pub static ALTER_PROCEDURE_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AlterProcedureStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ProcedureKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PROCEDURE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FunctionNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "FunctionParameterListGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterProcedureActionSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXTERNAL".to_string(), "RESET".to_string(), "SECURITY".to_string(), "SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RenameKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string(), "TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "LiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "+".to_string(), "-".to_string(), ":".to_string(), "ARRAY".to_string(), "DATE".to_string(), "FALSE".to_string(), "INTERVAL".to_string(), "NULL".to_string(), "TIME".to_string(), "TIMESTAMP".to_string(), "TIMESTAMPTZ".to_string(), "TIMETZ".to_string(), "TRUE".to_string(), "VARIADIC".to_string(), "[".to_string(), "{".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_numeric_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "numeric_literal".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string(), "TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FromKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CurrentKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string(), "FROM".to_string(), "TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OwnerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OWNER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "QuotedIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["double_quote".to_string()]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "Current_roleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_ROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Current_userKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Session_userKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SESSION_USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OWNER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NoKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DependsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEPENDS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExtensionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXTENSION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExtensionReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEPENDS".to_string(), "NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEPENDS".to_string(), "EXTERNAL".to_string(), "NO".to_string(), "OWNER".to_string(), "RENAME".to_string(), "RESET".to_string(), "SECURITY".to_string(), "SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AlterPublicationStatementSegment'
pub static ALTER_PUBLICATION_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AlterPublicationStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PublicationKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PUBLICATION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PublicationReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DefinitionParametersSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AddKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PublicationObjectsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string(), "TABLES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string(), "TABLES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PublicationObjectsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string(), "TABLES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string(), "TABLES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PublicationObjectsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string(), "TABLES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string(), "TABLES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RenameKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PublicationReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OwnerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OWNER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "Current_roleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_ROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Current_userKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Session_userKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SESSION_USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RoleReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OWNER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string(), "DROP".to_string(), "OWNER".to_string(), "RENAME".to_string(), "SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AlterRoleStatementSegment'
pub static ALTER_ROLE_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AlterRoleStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RoleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UserKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROLE".to_string(), "USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "Current_roleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_ROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Current_userKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Session_userKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SESSION_USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RoleReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::AnySetOf {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SuperuserKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SUPERUSER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NosuperuserKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOSUPERUSER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOSUPERUSER".to_string(), "SUPERUSER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreatedbKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATEDB".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NocreatedbKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOCREATEDB".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATEDB".to_string(), "NOCREATEDB".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateroleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATEROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NocreateroleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOCREATEROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATEROLE".to_string(), "NOCREATEROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "InheritKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INHERIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NoinheritKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOINHERIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INHERIT".to_string(), "NOINHERIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LoginKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LOGIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NologinKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOLOGIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LOGIN".to_string(), "NOLOGIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ReplicationKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REPLICATION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NoreplicationKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOREPLICATION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOREPLICATION".to_string(), "REPLICATION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "BypassrlsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BYPASSRLS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NobypassrlsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOBYPASSRLS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BYPASSRLS".to_string(), "NOBYPASSRLS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ConnectionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONNECTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LimitKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LIMIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONNECTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "EncryptedKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ENCRYPTED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PasswordKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PASSWORD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NullKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ENCRYPTED".to_string(), "PASSWORD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ValidKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VALID".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UntilKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UNTIL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VALID".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 0,
    max_times: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BYPASSRLS".to_string(), "CONNECTION".to_string(), "CREATEDB".to_string(), "CREATEROLE".to_string(), "ENCRYPTED".to_string(), "INHERIT".to_string(), "LOGIN".to_string(), "NOBYPASSRLS".to_string(), "NOCREATEDB".to_string(), "NOCREATEROLE".to_string(), "NOINHERIT".to_string(), "NOLOGIN".to_string(), "NOREPLICATION".to_string(), "NOSUPERUSER".to_string(), "PASSWORD".to_string(), "REPLICATION".to_string(), "SUPERUSER".to_string(), "VALID".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RoleReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RenameKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RoleReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "Current_roleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_ROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Current_userKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Session_userKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SESSION_USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AllKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RoleReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "InKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DatabaseKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATABASE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DatabaseReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string(), "TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DefaultKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "+".to_string(), "-".to_string(), ":".to_string(), "ARRAY".to_string(), "DATE".to_string(), "FALSE".to_string(), "INTERVAL".to_string(), "NULL".to_string(), "TIME".to_string(), "TIMESTAMP".to_string(), "TIMESTAMPTZ".to_string(), "TIMETZ".to_string(), "TRUE".to_string(), "VARIADIC".to_string(), "[".to_string(), "{".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_numeric_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "numeric_literal".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NakedIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "OnKeywordAsIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string(), "TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FromKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CurrentKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string(), "FROM".to_string(), "TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ResetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AllKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESET".to_string(), "SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AlterSchemaStatementSegment'
pub static ALTER_SCHEMA_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AlterSchemaStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RenameKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OwnerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OWNER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RoleReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OWNER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OWNER".to_string(), "RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AlterSequenceOptionsSegment'
pub static ALTER_SEQUENCE_OPTIONS_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AlterSequenceOptionsSegment
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DatatypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IncrementKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INCREMENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SignedSegmentGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["+".to_string(), "-".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INCREMENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "MinvalueKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MINVALUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SignedSegmentGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["+".to_string(), "-".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MINVALUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NoKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MinvalueKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MINVALUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MINVALUE".to_string(), "NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "MaxvalueKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MAXVALUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SignedSegmentGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["+".to_string(), "-".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MAXVALUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NoKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MaxvalueKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MAXVALUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MAXVALUE".to_string(), "NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SequenceKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SEQUENCE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NameKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SequenceReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SEQUENCE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "StartKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["START".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SignedSegmentGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["+".to_string(), "-".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["START".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RestartKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESTART".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SignedSegmentGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["+".to_string(), "-".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESTART".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CacheKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CACHE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CACHE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NoKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CycleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CYCLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CYCLE".to_string(), "NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OwnedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OWNED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NoneKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NONE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OWNED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string(), "CACHE".to_string(), "CYCLE".to_string(), "INCREMENT".to_string(), "MAXVALUE".to_string(), "MINVALUE".to_string(), "NO".to_string(), "OWNED".to_string(), "RESTART".to_string(), "SEQUENCE".to_string(), "START".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AlterSequenceStatementSegment'
pub static ALTER_SEQUENCE_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AlterSequenceStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SequenceKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SEQUENCE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SequenceReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterSequenceOptionsSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string(), "CACHE".to_string(), "CYCLE".to_string(), "INCREMENT".to_string(), "MAXVALUE".to_string(), "MINVALUE".to_string(), "NO".to_string(), "OWNED".to_string(), "RESTART".to_string(), "SEQUENCE".to_string(), "START".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string(), "CACHE".to_string(), "CYCLE".to_string(), "INCREMENT".to_string(), "MAXVALUE".to_string(), "MINVALUE".to_string(), "NO".to_string(), "OWNED".to_string(), "RESTART".to_string(), "SEQUENCE".to_string(), "START".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OwnerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OWNER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "Current_userKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Session_userKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SESSION_USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OWNER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RenameKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SequenceReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string(), "CACHE".to_string(), "CYCLE".to_string(), "INCREMENT".to_string(), "MAXVALUE".to_string(), "MINVALUE".to_string(), "NO".to_string(), "OWNED".to_string(), "OWNER".to_string(), "RENAME".to_string(), "RESTART".to_string(), "SEQUENCE".to_string(), "SET".to_string(), "START".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AlterStatisticsStatementSegment'
pub static ALTER_STATISTICS_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AlterStatisticsStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StatisticsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STATISTICS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StatisticsReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OwnerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OWNER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "QuotedIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["double_quote".to_string()]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "Current_roleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_ROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Current_userKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Session_userKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SESSION_USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OWNER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RenameKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StatisticsReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SchemaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "StatisticsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STATISTICS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STATISTICS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string(), "STATISTICS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OWNER".to_string(), "RENAME".to_string(), "SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AlterSubscriptionStatementSegment'
pub static ALTER_SUBSCRIPTION_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AlterSubscriptionStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SubscriptionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SUBSCRIPTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SubscriptionReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ConnectionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONNECTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONNECTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AddKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string(), "DROP".to_string(), "SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PublicationKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PUBLICATION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PublicationReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DefinitionParametersSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string(), "DROP".to_string(), "SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RefreshKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REFRESH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PublicationKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PUBLICATION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DefinitionParametersSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REFRESH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EnableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ENABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DisableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DISABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DefinitionParametersSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SkipKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SKIP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "RawEqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SKIP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OwnerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OWNER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "Current_roleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_ROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Current_userKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Current_sessionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OWNER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RenameKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SubscriptionReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string(), "CONNECTION".to_string(), "DISABLE".to_string(), "DROP".to_string(), "ENABLE".to_string(), "OWNER".to_string(), "REFRESH".to_string(), "RENAME".to_string(), "SET".to_string(), "SKIP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AlterTableActionSegment'
pub static ALTER_TABLE_ACTION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AlterTableActionSegment
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AddKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLUMN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfNotExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DatatypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CollateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLLATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CollationReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLLATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColumnConstraintSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHECK".to_string(), "COLLATE".to_string(), "DEFAULT".to_string(), "NOT".to_string(), "NULL".to_string(), "PRIMARY".to_string(), "REFERENCES".to_string(), "UNIQUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHECK".to_string(), "COLLATE".to_string(), "DEFAULT".to_string(), "NOT".to_string(), "NULL".to_string(), "PRIMARY".to_string(), "REFERENCES".to_string(), "UNIQUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLUMN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DropBehaviorGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string(), "RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLUMN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DataKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TypeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TYPE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DatatypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CollateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLLATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CollationReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLLATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "UsingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string(), "TYPE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DefaultKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "+".to_string(), "-".to_string(), ":".to_string(), "ARRAY".to_string(), "DATE".to_string(), "FALSE".to_string(), "INTERVAL".to_string(), "NULL".to_string(), "TIME".to_string(), "TIMESTAMP".to_string(), "TIMESTAMPTZ".to_string(), "TIMETZ".to_string(), "TRUE".to_string(), "VARIADIC".to_string(), "[".to_string(), "{".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_numeric_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "numeric_literal".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "BareFunctionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_CATALOG".to_string(), "CURRENT_DATE".to_string(), "CURRENT_ROLE".to_string(), "CURRENT_SCHEMA".to_string(), "CURRENT_TIME".to_string(), "CURRENT_TIMESTAMP".to_string(), "CURRENT_USER".to_string(), "LOCALTIME".to_string(), "LOCALTIMESTAMP".to_string(), "SESSION_USER".to_string(), "SYSTEM_USER".to_string(), "USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DefaultKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string(), "SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NotKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NullKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string(), "NOT".to_string(), "SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXPRESSION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AddKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "GeneratedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GENERATED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlwaysKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALWAYS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DefaultKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALWAYS".to_string(), "BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IdentityKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IDENTITY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterSequenceOptionsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string(), "CACHE".to_string(), "CYCLE".to_string(), "INCREMENT".to_string(), "MAXVALUE".to_string(), "MINVALUE".to_string(), "NO".to_string(), "OWNED".to_string(), "RESTART".to_string(), "SEQUENCE".to_string(), "START".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string(), "CACHE".to_string(), "CYCLE".to_string(), "INCREMENT".to_string(), "MAXVALUE".to_string(), "MINVALUE".to_string(), "NO".to_string(), "OWNED".to_string(), "RESTART".to_string(), "SEQUENCE".to_string(), "START".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "GeneratedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GENERATED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlwaysKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALWAYS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DefaultKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALWAYS".to_string(), "BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AlterSequenceOptionsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string(), "CACHE".to_string(), "CYCLE".to_string(), "INCREMENT".to_string(), "MAXVALUE".to_string(), "MINVALUE".to_string(), "NO".to_string(), "OWNED".to_string(), "RESTART".to_string(), "SEQUENCE".to_string(), "START".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RestartKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESTART".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESTART".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESTART".to_string(), "SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESTART".to_string(), "SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IdentityKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IDENTITY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StatisticsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STATISTICS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RelationOptionsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ResetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RelationOptionsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StorageKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STORAGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PlainKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PLAIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExternalKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXTERNAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExtendedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXTENDED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MainKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MAIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXTENDED".to_string(), "EXTERNAL".to_string(), "MAIN".to_string(), "PLAIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string(), "DROP".to_string(), "NOT".to_string(), "RESET".to_string(), "RESTART".to_string(), "SET".to_string(), "TYPE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AddKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableConstraintSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHECK".to_string(), "CONSTRAINT".to_string(), "EXCLUDE".to_string(), "FOREIGN".to_string(), "PRIMARY".to_string(), "UNIQUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AddKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableConstraintUsingIndexSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRAINT".to_string(), "PRIMARY".to_string(), "UNIQUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConstraintKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRAINT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DeferrableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFERRABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NotKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DeferrableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFERRABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFERRABLE".to_string(), "NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "InitiallyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INITIALLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DeferredKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFERRED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INITIALLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "InitiallyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INITIALLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ImmediateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IMMEDIATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INITIALLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INITIALLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ValidateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VALIDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConstraintKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRAINT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VALIDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConstraintKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRAINT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DropBehaviorGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string(), "RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "EnableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ENABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DisableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DISABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DISABLE".to_string(), "ENABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TriggerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TRIGGER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AllKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UserKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DISABLE".to_string(), "ENABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "EnableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ENABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ReplicaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REPLICA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AlwaysKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALWAYS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALWAYS".to_string(), "REPLICA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TriggerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TRIGGER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ENABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "EnableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ENABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DisableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DISABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "EnableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ENABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ReplicaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REPLICA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ENABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "EnableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ENABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RuleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RULE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ENABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DISABLE".to_string(), "ENABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RuleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RULE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DISABLE".to_string(), "ENABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DisableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DISABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EnableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ENABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ForceKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FORCE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NoKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ForceKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FORCE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DISABLE".to_string(), "ENABLE".to_string(), "FORCE".to_string(), "NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RowKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LevelKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LEVEL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SecurityKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SECURITY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DISABLE".to_string(), "ENABLE".to_string(), "FORCE".to_string(), "NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ClusterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CLUSTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CLUSTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WithoutKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITHOUT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ClusterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CLUSTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OidsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OIDS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CLUSTER".to_string(), "OIDS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TablespaceKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLESPACE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TablespaceReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LoggedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LOGGED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UnloggedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UNLOGGED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LOGGED".to_string(), "UNLOGGED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RelationOptionsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ResetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RelationOptionsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NoKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "InheritKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INHERIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INHERIT".to_string(), "NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OfKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NotKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OfKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OwnerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OWNER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "Current_roleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_ROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Current_userKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Session_userKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SESSION_USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OWNER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ReplicaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REPLICA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IdentityKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IDENTITY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DefaultKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "UsingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IndexKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INDEX".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IndexReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FullKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NothingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOTHING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string(), "FULL".to_string(), "NOTHING".to_string(), "USING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REPLICA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string(), "ALTER".to_string(), "CLUSTER".to_string(), "DISABLE".to_string(), "DROP".to_string(), "ENABLE".to_string(), "FORCE".to_string(), "INHERIT".to_string(), "NO".to_string(), "NOT".to_string(), "OF".to_string(), "OWNER".to_string(), "REPLICA".to_string(), "RESET".to_string(), "SET".to_string(), "VALIDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AlterTableDropColumnGrammar'
pub static ALTER_TABLE_DROP_COLUMN_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLUMN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AlterTableOptionsGrammar'
pub static ALTER_TABLE_OPTIONS_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "+".to_string(), "-".to_string(), ":".to_string(), "ARRAY".to_string(), "DATE".to_string(), "FALSE".to_string(), "INTERVAL".to_string(), "NULL".to_string(), "TIME".to_string(), "TIMESTAMP".to_string(), "TIMESTAMPTZ".to_string(), "TIMETZ".to_string(), "TRUE".to_string(), "VARIADIC".to_string(), "[".to_string(), "{".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_numeric_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "numeric_literal".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NakedIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AddKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ModifyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MODIFY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string(), "MODIFY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLUMN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnDefinitionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FirstKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FIRST".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AfterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AFTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AFTER".to_string(), "FIRST".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AFTER".to_string(), "FIRST".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BracketedColumnReferenceListGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "AFTER".to_string(), "FIRST".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string(), "MODIFY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AlterTableDropColumnGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RenameKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string(), "TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='AlterTableStatementSegment'
pub static ALTER_TABLE_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AlterTableStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OnlyKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ONLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "StarSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["*".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterTableActionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string(), "ALTER".to_string(), "CLUSTER".to_string(), "DISABLE".to_string(), "DROP".to_string(), "ENABLE".to_string(), "FORCE".to_string(), "INHERIT".to_string(), "NO".to_string(), "NOT".to_string(), "OF".to_string(), "OWNER".to_string(), "REPLICA".to_string(), "RESET".to_string(), "SET".to_string(), "VALIDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string(), "ALTER".to_string(), "CLUSTER".to_string(), "DISABLE".to_string(), "DROP".to_string(), "ENABLE".to_string(), "FORCE".to_string(), "INHERIT".to_string(), "NO".to_string(), "NOT".to_string(), "OF".to_string(), "OWNER".to_string(), "REPLICA".to_string(), "RESET".to_string(), "SET".to_string(), "VALIDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RenameKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLUMN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RenameKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConstraintKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRAINT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string(), "ALTER".to_string(), "CLUSTER".to_string(), "DISABLE".to_string(), "DROP".to_string(), "ENABLE".to_string(), "FORCE".to_string(), "INHERIT".to_string(), "NO".to_string(), "NOT".to_string(), "OF".to_string(), "OWNER".to_string(), "RENAME".to_string(), "REPLICA".to_string(), "RESET".to_string(), "SET".to_string(), "VALIDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RenameKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AttachKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ATTACH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PartitionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PARTITION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ForKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ValuesKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PartitionBoundSpecSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string(), "IN".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DefaultKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string(), "FOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ATTACH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DetachKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DETACH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PartitionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PARTITION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ConcurrentlyKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONCURRENTLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FinalizeKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FINALIZE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DETACH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ATTACH".to_string(), "DETACH".to_string(), "RENAME".to_string(), "SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AllKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "InKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TablespaceKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLESPACE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TablespaceReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OwnedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OWNED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OWNED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TablespaceKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLESPACE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TablespaceReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "NowaitKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOWAIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AlterTextSearchConfigurationStatementSegment'
pub static ALTER_TEXT_SEARCH_CONFIGURATION_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AlterTextSearchConfigurationStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TextKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TEXT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SearchKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SEARCH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConfigurationKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONFIGURATION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AddKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MappingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MAPPING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ForKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MappingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MAPPING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ForKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MappingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MAPPING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ReplaceKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REPLACE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MappingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MAPPING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ForKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ReplaceKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REPLACE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MappingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MAPPING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ForKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RenameKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OwnerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OWNER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "Current_roleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_ROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Current_userKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Session_userKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SESSION_USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OWNER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string(), "ALTER".to_string(), "DROP".to_string(), "OWNER".to_string(), "RENAME".to_string(), "SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AlterTriggerStatementSegment'
pub static ALTER_TRIGGER_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AlterTriggerStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TriggerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TRIGGER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TriggerReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RenameKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TriggerReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NoKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DependsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEPENDS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExtensionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXTENSION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExtensionReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEPENDS".to_string(), "NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEPENDS".to_string(), "NO".to_string(), "RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AlterTypeStatementSegment'
pub static ALTER_TYPE_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AlterTypeStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TypeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TYPE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OwnerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OWNER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "Current_userKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Session_userKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SESSION_USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Current_roleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_ROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OWNER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RenameKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ValueKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VALUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RenameKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AddKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AttributeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ATTRIBUTE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DatatypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CollateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLLATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CollationReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLLATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CascadeRestrictGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string(), "RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AttributeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ATTRIBUTE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DataKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TypeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TYPE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DatatypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CollateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLLATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CollationReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLLATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CascadeRestrictGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string(), "RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AttributeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ATTRIBUTE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "CascadeRestrictGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string(), "RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RenameKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AttributeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ATTRIBUTE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "CascadeRestrictGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string(), "RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string(), "ALTER".to_string(), "DROP".to_string(), "RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AddKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ValueKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VALUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfNotExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "BeforeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BEFORE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AfterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AFTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AFTER".to_string(), "BEFORE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AFTER".to_string(), "BEFORE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADD".to_string(), "ALTER".to_string(), "DROP".to_string(), "OWNER".to_string(), "RENAME".to_string(), "SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AlterViewStatementSegment'
pub static ALTER_VIEW_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AlterViewStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ViewKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VIEW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AlterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLUMN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DefaultKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "+".to_string(), "-".to_string(), ":".to_string(), "ARRAY".to_string(), "DATE".to_string(), "FALSE".to_string(), "INTERVAL".to_string(), "NULL".to_string(), "TIME".to_string(), "TIMESTAMP".to_string(), "TIMESTAMPTZ".to_string(), "TIMETZ".to_string(), "TRUE".to_string(), "VARIADIC".to_string(), "[".to_string(), "{".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_numeric_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "numeric_literal".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "BareFunctionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_CATALOG".to_string(), "CURRENT_DATE".to_string(), "CURRENT_ROLE".to_string(), "CURRENT_SCHEMA".to_string(), "CURRENT_TIME".to_string(), "CURRENT_TIMESTAMP".to_string(), "CURRENT_USER".to_string(), "LOCALTIME".to_string(), "LOCALTIMESTAMP".to_string(), "SESSION_USER".to_string(), "SYSTEM_USER".to_string(), "USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DefaultKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string(), "SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OwnerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OWNER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "Current_roleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_ROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Current_userKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Session_userKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SESSION_USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OWNER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RenameKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLUMN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RenameKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "+".to_string(), "-".to_string(), ":".to_string(), "ARRAY".to_string(), "DATE".to_string(), "FALSE".to_string(), "INTERVAL".to_string(), "NULL".to_string(), "TIME".to_string(), "TIMESTAMP".to_string(), "TIMESTAMPTZ".to_string(), "TIMETZ".to_string(), "TRUE".to_string(), "VARIADIC".to_string(), "[".to_string(), "{".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_numeric_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "numeric_literal".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ResetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string(), "OWNER".to_string(), "RENAME".to_string(), "RESET".to_string(), "SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AlwaysKeywordSegment'
pub static ALWAYS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ALWAYS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AmpersandSegment'
pub static AMPERSAND_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "&",
    token_type: "ampersand",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='AnalyseKeywordSegment'
pub static ANALYSE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ANALYSE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AnalyzeKeywordSegment'
pub static ANALYZE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ANALYZE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AnalyzeStatementSegment'
pub static ANALYZE_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AnalyzeStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AnalyzeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ANALYZE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AnalyseKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ANALYSE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ANALYSE".to_string(), "ANALYZE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "VerboseKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VERBOSE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Skip_lockedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SKIP_LOCKED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SKIP_LOCKED".to_string(), "VERBOSE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BooleanLiteralGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FALSE".to_string(), "TRUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SKIP_LOCKED".to_string(), "VERBOSE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SKIP_LOCKED".to_string(), "VERBOSE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "VerboseKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VERBOSE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "VERBOSE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: true,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ANALYSE".to_string(), "ANALYZE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AndKeywordSegment'
pub static AND_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "AND",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AndOperatorGrammar'
pub static AND_OPERATOR_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "AND",
    token_type: "binary_operator",
    raw_class: "BinaryOperatorSegment",
    optional: false,
})
);

// name='AntiKeywordSegment'
pub static ANTI_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ANTI",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AnyKeywordSegment'
pub static ANY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ANY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AppendKeywordSegment'
pub static APPEND_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "APPEND",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ApplyKeywordSegment'
pub static APPLY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "APPLY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ArithmeticBinaryOperatorGrammar'
pub static ARITHMETIC_BINARY_OPERATOR_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PlusSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["+".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MinusSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["-".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DivideSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["/".to_string(), "//".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MultiplySegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["*".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ModuloSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["%".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BitwiseAndSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["&".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BitwiseOrSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["|".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BitwiseXorSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["^".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BitwiseLShiftSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["<".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BitwiseRShiftSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([">".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["%".to_string(), "&".to_string(), "*".to_string(), "+".to_string(), "-".to_string(), "/".to_string(), "//".to_string(), "<".to_string(), ">".to_string(), "^".to_string(), "|".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ArrayAccessorSegment'
pub static ARRAY_ACCESSOR_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ArrayAccessorSegment
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "QualifiedNumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["+".to_string(), "-".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "QualifiedNumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["+".to_string(), "-".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "SliceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([":".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "QualifiedNumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["+".to_string(), "-".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "[",
    token_type: "start_square_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: "]",
    token_type: "end_square_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["[".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ArrayExpressionSegment'
pub static ARRAY_EXPRESSION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ArrayExpressionSegment
Arc::new(Grammar::Nothing())
);

// name='ArrayKeywordSegment'
pub static ARRAY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ARRAY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ArrayLiteralSegment'
pub static ARRAY_LITERAL_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ArrayLiteralSegment
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "BaseExpressionElementGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: true,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "[",
    token_type: "start_square_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: "]",
    token_type: "end_square_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["[".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ArrayTypeSegment'
pub static ARRAY_TYPE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ArrayTypeSegment
Arc::new(Grammar::Ref {
    name: "ArrayKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ARRAY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AsAliasExpressionSegment'
pub static AS_ALIAS_EXPRESSION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AsAliasExpressionSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::Ref {
    name: "AsAliasOperatorSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("dedent"))
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='AsAliasOperatorSegment'
pub static AS_ALIAS_OPERATOR_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// AsAliasOperatorSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='AsKeywordSegment'
pub static AS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "AS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AscKeywordSegment'
pub static ASC_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ASC",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AsofKeywordSegment'
pub static ASOF_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ASOF",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AssertionKeywordSegment'
pub static ASSERTION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ASSERTION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AssignmentKeywordSegment'
pub static ASSIGNMENT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ASSIGNMENT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AsymmetricKeywordSegment'
pub static ASYMMETRIC_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ASYMMETRIC",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AtKeywordSegment'
pub static AT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "AT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AtomicKeywordSegment'
pub static ATOMIC_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ATOMIC",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AttachKeywordSegment'
pub static ATTACH_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ATTACH",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AttributeKeywordSegment'
pub static ATTRIBUTE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ATTRIBUTE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AuditKeywordSegment'
pub static AUDIT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "AUDIT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AuthorizationKeywordSegment'
pub static AUTHORIZATION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "AUTHORIZATION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='AutoIncrementGrammar'
pub static AUTO_INCREMENT_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "Auto_incrementKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AUTO_INCREMENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AUTO_INCREMENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='Auto_incrementKeywordSegment'
pub static AUTO_INCREMENT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "AUTO_INCREMENT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Avg_row_lengthKeywordSegment'
pub static AVG_ROW_LENGTH_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "AVG_ROW_LENGTH",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='BackupKeywordSegment'
pub static BACKUP_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "BACKUP",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='BackwardKeywordSegment'
pub static BACKWARD_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "BACKWARD",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='BareFunctionSegment'
pub static BARE_FUNCTION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::MultiStringParser {
    templates: vec!["CURRENT_CATALOG", "CURRENT_DATE", "CURRENT_ROLE", "CURRENT_SCHEMA", "CURRENT_TIME", "CURRENT_TIMESTAMP", "CURRENT_USER", "LOCALTIME", "LOCALTIMESTAMP", "SESSION_USER", "SYSTEM_USER", "USER"],
    token_type: "bare_function",
    raw_class: "CodeSegment",
    optional: false,
})
);

// name='BaseExpressionElementGrammar'
pub static BASE_EXPRESSION_ELEMENT_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "+".to_string(), "-".to_string(), ":".to_string(), "ARRAY".to_string(), "DATE".to_string(), "FALSE".to_string(), "INTERVAL".to_string(), "NULL".to_string(), "TIME".to_string(), "TIMESTAMP".to_string(), "TIMESTAMPTZ".to_string(), "TIMETZ".to_string(), "TRUE".to_string(), "VARIADIC".to_string(), "[".to_string(), "{".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_numeric_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "numeric_literal".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BareFunctionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_CATALOG".to_string(), "CURRENT_DATE".to_string(), "CURRENT_ROLE".to_string(), "CURRENT_SCHEMA".to_string(), "CURRENT_TIME".to_string(), "CURRENT_TIMESTAMP".to_string(), "CURRENT_USER".to_string(), "LOCALTIME".to_string(), "LOCALTIMESTAMP".to_string(), "SESSION_USER".to_string(), "SYSTEM_USER".to_string(), "USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IntervalExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INTERVAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DatatypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "LiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "+".to_string(), "-".to_string(), ":".to_string(), "ARRAY".to_string(), "DATE".to_string(), "FALSE".to_string(), "INTERVAL".to_string(), "NULL".to_string(), "TIME".to_string(), "TIMESTAMP".to_string(), "TIMESTAMPTZ".to_string(), "TIMETZ".to_string(), "TRUE".to_string(), "VARIADIC".to_string(), "[".to_string(), "{".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_numeric_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "numeric_literal".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='BaseFileSegment'
pub static BASE_FILE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Token{
    token_type: "file",
//    token_type: "BaseFileSegment",
})
);

// name='BaseSegment'
pub static BASE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Token{
    token_type: "base",
//    token_type: "BaseSegment",
})
);

// name='BeforeKeywordSegment'
pub static BEFORE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "BEFORE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='BeginKeywordSegment'
pub static BEGIN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "BEGIN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='BernoulliKeywordSegment'
pub static BERNOULLI_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "BERNOULLI",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='BetweenKeywordSegment'
pub static BETWEEN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "BETWEEN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='BigintKeywordSegment'
pub static BIGINT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "BIGINT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='BigserialKeywordSegment'
pub static BIGSERIAL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "BIGSERIAL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='BinaryKeywordSegment'
pub static BINARY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "BINARY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='BinaryOperatorGrammar'
pub static BINARY_OPERATOR_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ArithmeticBinaryOperatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["%".to_string(), "&".to_string(), "*".to_string(), "+".to_string(), "-".to_string(), "/".to_string(), "//".to_string(), "<".to_string(), ">".to_string(), "^".to_string(), "|".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StringBinaryOperatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLLATE".to_string(), "|".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BooleanBinaryOperatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AND".to_string(), "OR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ComparisonOperatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["!".to_string(), "<".to_string(), "=".to_string(), "==".to_string(), ">".to_string(), "IS".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["glob_operator".to_string(), "like_operator".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "JsonOperatorSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["json_operator".to_string()]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["!".to_string(), "%".to_string(), "&".to_string(), "*".to_string(), "+".to_string(), "-".to_string(), "/".to_string(), "//".to_string(), "<".to_string(), "=".to_string(), "==".to_string(), ">".to_string(), "AND".to_string(), "COLLATE".to_string(), "IS".to_string(), "OR".to_string(), "^".to_string(), "|".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["glob_operator".to_string(), "json_operator".to_string(), "like_operator".to_string()]),
        }),
})
);

// name='BinaryOperatorSegment'
pub static BINARY_OPERATOR_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Token{
    token_type: "binary_operator",
//    token_type: "BinaryOperatorSegment",
})
);

// name='BindingKeywordSegment'
pub static BINDING_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "BINDING",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='BitKeywordSegment'
pub static BIT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "BIT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='BitvarKeywordSegment'
pub static BITVAR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "BITVAR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='BitwiseAndSegment'
pub static BITWISE_AND_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// BitwiseAndSegment
Arc::new(Grammar::Ref {
    name: "AmpersandSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["&".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='BitwiseLShiftSegment'
pub static BITWISE_L_SHIFT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// BitwiseLShiftSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RawLessThanSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["<".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RawLessThanSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["<".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: false,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["<".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='BitwiseOrSegment'
pub static BITWISE_OR_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// BitwiseOrSegment
Arc::new(Grammar::Ref {
    name: "PipeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["|".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='BitwiseRShiftSegment'
pub static BITWISE_R_SHIFT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// BitwiseRShiftSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RawGreaterThanSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([">".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RawGreaterThanSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([">".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: false,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([">".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='BitwiseXorSegment'
pub static BITWISE_XOR_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "^",
    token_type: "binary_operator",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='BoolKeywordSegment'
pub static BOOL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "BOOL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='BooleanBinaryOperatorGrammar'
pub static BOOLEAN_BINARY_OPERATOR_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AndOperatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AND".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OrOperatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AND".to_string(), "OR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='BooleanKeywordSegment'
pub static BOOLEAN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "BOOLEAN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='BooleanLiteralGrammar'
pub static BOOLEAN_LITERAL_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TrueSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TRUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FalseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FALSE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FALSE".to_string(), "TRUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='BothKeywordSegment'
pub static BOTH_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "BOTH",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='BoxKeywordSegment'
pub static BOX_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "BOX",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='BpcharKeywordSegment'
pub static BPCHAR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "BPCHAR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='BracketedArguments'
pub static BRACKETED_ARGUMENTS: Lazy<Arc<Grammar>> = Lazy::new(||
// BracketedArguments
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "+".to_string(), "-".to_string(), ":".to_string(), "ARRAY".to_string(), "DATE".to_string(), "FALSE".to_string(), "INTERVAL".to_string(), "NULL".to_string(), "TIME".to_string(), "TIMESTAMP".to_string(), "TIMESTAMPTZ".to_string(), "TIMETZ".to_string(), "TRUE".to_string(), "VARIADIC".to_string(), "[".to_string(), "{".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_numeric_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "numeric_literal".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: true,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "+".to_string(), "-".to_string(), ":".to_string(), "ARRAY".to_string(), "DATE".to_string(), "FALSE".to_string(), "INTERVAL".to_string(), "NULL".to_string(), "TIME".to_string(), "TIMESTAMP".to_string(), "TIMESTAMPTZ".to_string(), "TIMETZ".to_string(), "TRUE".to_string(), "VARIADIC".to_string(), "[".to_string(), "{".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_numeric_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "numeric_literal".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='BracketedColumnReferenceListGrammar'
pub static BRACKETED_COLUMN_REFERENCE_LIST_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='BracketedSegment'
pub static BRACKETED_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Token{
    token_type: "bracketed",
//    token_type: "BracketedSegment",
})
);

// name='BracketedSetExpressionGrammar'
pub static BRACKETED_SET_EXPRESSION_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "FROM".to_string(), "PIVOT".to_string(), "PIVOT_LONGER".to_string(), "PIVOT_WIDER".to_string(), "SELECT".to_string(), "UNPIVOT".to_string(), "VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='BreadthKeywordSegment'
pub static BREADTH_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "BREADTH",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='BreakKeywordSegment'
pub static BREAK_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "BREAK",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='BrowseKeywordSegment'
pub static BROWSE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "BROWSE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='BuffersKeywordSegment'
pub static BUFFERS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "BUFFERS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='BulkKeywordSegment'
pub static BULK_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "BULK",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ByKeywordSegment'
pub static BY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "BY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='BypassrlsKeywordSegment'
pub static BYPASSRLS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "BYPASSRLS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ByteaKeywordSegment'
pub static BYTEA_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "BYTEA",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CTEColumnList'
pub static C_T_E_COLUMN_LIST: Lazy<Arc<Grammar>> = Lazy::new(||
// CTEColumnList
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierListSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CTEDefinitionSegment'
pub static C_T_E_DEFINITION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CTEDefinitionSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "CTEColumnList",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NotKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MaterializedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MATERIALIZED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MATERIALIZED".to_string(), "NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SelectableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "DELETE".to_string(), "FROM".to_string(), "INSERT".to_string(), "PIVOT".to_string(), "PIVOT_LONGER".to_string(), "PIVOT_WIDER".to_string(), "SELECT".to_string(), "UNPIVOT".to_string(), "UPDATE".to_string(), "VALUES".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Greedy,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SearchKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SEARCH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "BreadthKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BREADTH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DepthKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEPTH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BREADTH".to_string(), "DEPTH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FirstKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FIRST".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SEARCH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CycleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CYCLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "UsingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CYCLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CYCLE".to_string(), "SEARCH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='CacheKeywordSegment'
pub static CACHE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CACHE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CallKeywordSegment'
pub static CALL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CALL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CallStoredProcedureSegment'
pub static CALL_STORED_PROCEDURE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CallStoredProcedureSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CallKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CALL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CALL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CalledKeywordSegment'
pub static CALLED_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CALLED",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CascadeKeywordSegment'
pub static CASCADE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CASCADE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CascadeRestrictGrammar'
pub static CASCADE_RESTRICT_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CascadeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RestrictKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string(), "RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CascadedKeywordSegment'
pub static CASCADED_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CASCADED",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CaseExpressionSegment'
pub static CASE_EXPRESSION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CaseExpressionSegment
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CaseKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WhenClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "ElseKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ELSE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EndKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["END".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: true,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ElseClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "EndKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["END".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: true,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ELSE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("dedent"))
,
Arc::new(Grammar::Ref {
    name: "EndKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["END".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CaseKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WhenClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "ElseKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ELSE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EndKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["END".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: true,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ElseClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "EndKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["END".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: true,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ELSE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("dedent"))
,
Arc::new(Grammar::Ref {
    name: "EndKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["END".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "ComparisonOperatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["!".to_string(), "<".to_string(), "=".to_string(), "==".to_string(), ">".to_string(), "IS".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["glob_operator".to_string(), "like_operator".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BinaryOperatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["!".to_string(), "%".to_string(), "&".to_string(), "*".to_string(), "+".to_string(), "-".to_string(), "/".to_string(), "//".to_string(), "<".to_string(), "=".to_string(), "==".to_string(), ">".to_string(), "AND".to_string(), "COLLATE".to_string(), "IS".to_string(), "OR".to_string(), "^".to_string(), "|".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["glob_operator".to_string(), "json_operator".to_string(), "like_operator".to_string()]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CaseKeywordSegment'
pub static CASE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CASE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CastKeywordSegment'
pub static CAST_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CAST",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CastOperatorSegment'
pub static CAST_OPERATOR_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "::",
    token_type: "casting_operator",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='CatalogKeywordSegment'
pub static CATALOG_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CATALOG",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ChainKeywordSegment'
pub static CHAIN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CHAIN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ChangeKeywordSegment'
pub static CHANGE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CHANGE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CharCharacterSetGrammar'
pub static CHAR_CHARACTER_SET_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Nothing())
);

// name='CharKeywordSegment'
pub static CHAR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CHAR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CharacterKeywordSegment'
pub static CHARACTER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CHARACTER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CharacteristicsKeywordSegment'
pub static CHARACTERISTICS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CHARACTERISTICS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CheckKeywordSegment'
pub static CHECK_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CHECK",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CheckedKeywordSegment'
pub static CHECKED_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CHECKED",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CheckpointKeywordSegment'
pub static CHECKPOINT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CHECKPOINT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ChecksumKeywordSegment'
pub static CHECKSUM_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CHECKSUM",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CidrKeywordSegment'
pub static CIDR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CIDR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CircleKeywordSegment'
pub static CIRCLE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CIRCLE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CircularstringKeywordSegment'
pub static CIRCULARSTRING_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CIRCULARSTRING",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ClassKeywordSegment'
pub static CLASS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CLASS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CloseKeywordSegment'
pub static CLOSE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CLOSE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ClusterKeywordSegment'
pub static CLUSTER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CLUSTER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ClusterStatementSegment'
pub static CLUSTER_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ClusterStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ClusterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CLUSTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "VerboseKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VERBOSE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "UsingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IndexReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IndexReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CLUSTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ClusteredKeywordSegment'
pub static CLUSTERED_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CLUSTERED",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CoalesceKeywordSegment'
pub static COALESCE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "COALESCE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CodeSegment'
pub static CODE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Token{
    token_type: "raw",
//    token_type: "CodeSegment",
})
);

// name='CollateGrammar'
pub static COLLATE_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Nothing())
);

// name='CollateKeywordSegment'
pub static COLLATE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "COLLATE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CollationKeywordSegment'
pub static COLLATION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "COLLATION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CollationReferenceSegment'
pub static COLLATION_REFERENCE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CollationReferenceSegment
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "ObjectReferenceDelimiterGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "ObjectReferenceTerminatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["!".to_string(), "%".to_string(), "&".to_string(), "(".to_string(), "*".to_string(), "+".to_string(), ",".to_string(), "-".to_string(), "/".to_string(), "//".to_string(), ":".to_string(), "::".to_string(), ";".to_string(), "<".to_string(), "=".to_string(), "==".to_string(), ">".to_string(), "AND".to_string(), "AS".to_string(), "COLLATE".to_string(), "IS".to_string(), "ON".to_string(), "OR".to_string(), "PIVOT".to_string(), "UNPIVOT".to_string(), "USING".to_string(), "[".to_string(), "^".to_string(), "|".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["glob_operator".to_string(), "json_operator".to_string(), "like_operator".to_string()]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: false,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='ColonDelimiterSegment'
pub static COLON_DELIMITER_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: ":",
    token_type: "colon_delimiter",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='ColonPrefixSegment'
pub static COLON_PREFIX_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: ":",
    token_type: "colon_prefix",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='ColonSegment'
pub static COLON_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: ":",
    token_type: "colon",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='ColumnConstraintDefaultGrammar'
pub static COLUMN_CONSTRAINT_DEFAULT_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ShorthandCastSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "LiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "+".to_string(), "-".to_string(), ":".to_string(), "ARRAY".to_string(), "DATE".to_string(), "FALSE".to_string(), "INTERVAL".to_string(), "NULL".to_string(), "TIME".to_string(), "TIMESTAMP".to_string(), "TIMESTAMPTZ".to_string(), "TIMETZ".to_string(), "TRUE".to_string(), "VARIADIC".to_string(), "[".to_string(), "{".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_numeric_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "numeric_literal".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "BareFunctionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_CATALOG".to_string(), "CURRENT_DATE".to_string(), "CURRENT_ROLE".to_string(), "CURRENT_SCHEMA".to_string(), "CURRENT_TIME".to_string(), "CURRENT_TIMESTAMP".to_string(), "CURRENT_USER".to_string(), "LOCALTIME".to_string(), "LOCALTIMESTAMP".to_string(), "SESSION_USER".to_string(), "SYSTEM_USER".to_string(), "USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='ColumnConstraintSegment'
pub static COLUMN_CONSTRAINT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ColumnConstraintSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NotKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NullKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOT".to_string(), "NULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CheckKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHECK".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHECK".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DefaultKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "+".to_string(), "-".to_string(), ":".to_string(), "ARRAY".to_string(), "DATE".to_string(), "FALSE".to_string(), "INTERVAL".to_string(), "NULL".to_string(), "TIME".to_string(), "TIMESTAMP".to_string(), "TIMESTAMPTZ".to_string(), "TIMETZ".to_string(), "TRUE".to_string(), "VARIADIC".to_string(), "[".to_string(), "{".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_numeric_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "numeric_literal".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UniqueKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UNIQUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PrimaryKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PRIMARY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "KeyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["KEY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PRIMARY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ReferenceDefinitionGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REFERENCES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CollateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLLATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CollationReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLLATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHECK".to_string(), "COLLATE".to_string(), "DEFAULT".to_string(), "NOT".to_string(), "NULL".to_string(), "PRIMARY".to_string(), "REFERENCES".to_string(), "UNIQUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHECK".to_string(), "COLLATE".to_string(), "DEFAULT".to_string(), "NOT".to_string(), "NULL".to_string(), "PRIMARY".to_string(), "REFERENCES".to_string(), "UNIQUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ColumnDefinitionSegment'
pub static COLUMN_DEFINITION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ColumnDefinitionSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DatatypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColumnConstraintSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHECK".to_string(), "COLLATE".to_string(), "DEFAULT".to_string(), "NOT".to_string(), "NULL".to_string(), "PRIMARY".to_string(), "REFERENCES".to_string(), "UNIQUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CollateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLLATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CollationReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLLATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHECK".to_string(), "COLLATE".to_string(), "DEFAULT".to_string(), "NOT".to_string(), "NULL".to_string(), "PRIMARY".to_string(), "REFERENCES".to_string(), "UNIQUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='ColumnGeneratedGrammar'
pub static COLUMN_GENERATED_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Nothing())
);

// name='ColumnKeywordSegment'
pub static COLUMN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "COLUMN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ColumnReferenceSegment'
pub static COLUMN_REFERENCE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ColumnReferenceSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DotSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DotSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DotSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierFullGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DotSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DotSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DotSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UsingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CastOperatorSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["::".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StartSquareBracketSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["[".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StartBracketSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BinaryOperatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["!".to_string(), "%".to_string(), "&".to_string(), "*".to_string(), "+".to_string(), "-".to_string(), "/".to_string(), "//".to_string(), "<".to_string(), "=".to_string(), "==".to_string(), ">".to_string(), "AND".to_string(), "COLLATE".to_string(), "IS".to_string(), "OR".to_string(), "^".to_string(), "|".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["glob_operator".to_string(), "json_operator".to_string(), "like_operator".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColonSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([":".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DelimiterGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([";".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "JoinLikeClauseGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PIVOT".to_string(), "UNPIVOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Token{
    token_type: "bracketed",
//    token_type: "BracketedSegment",
})
,
    ],
    reset_terminators: false,
    allow_gaps: false,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: false,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: false,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='ColumnTypeReferenceSegment'
pub static COLUMN_TYPE_REFERENCE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ColumnTypeReferenceSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ModuloSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["%".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TypeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TYPE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='ColumnsExpressionFunctionContentsSegment'
pub static COLUMNS_EXPRESSION_FUNCTION_CONTENTS_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ColumnsExpressionFunctionContentsSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WildcardExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "LambdaExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "BaseExpressionElementGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ColumnsExpressionFunctionNameSegment'
pub static COLUMNS_EXPRESSION_FUNCTION_NAME_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ColumnsExpressionFunctionNameSegment
Arc::new(Grammar::Ref {
    name: "ColumnsExpressionNameGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLUMNS".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["star".to_string()]),
        }),
})
);

// name='ColumnsExpressionGrammar'
pub static COLUMNS_EXPRESSION_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColumnsExpressionFunctionNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLUMNS".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["star".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnsExpressionFunctionContentsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLUMNS".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["star".to_string()]),
        }),
})
);

// name='ColumnsExpressionNameGrammar'
pub static COLUMNS_EXPRESSION_NAME_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "UnpackingOperatorSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["star".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLUMNS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLUMNS".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["star".to_string()]),
        }),
})
);

// name='ColumnsKeywordSegment'
pub static COLUMNS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "COLUMNS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CommaSegment'
pub static COMMA_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: ",",
    token_type: "comma",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='CommentClauseSegment'
pub static COMMENT_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CommentClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CommentKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COMMENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COMMENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CommentKeywordSegment'
pub static COMMENT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "COMMENT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CommentOnStatementSegment'
pub static COMMENT_ON_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CommentOnStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CommentKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COMMENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ViewKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VIEW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string(), "VIEW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string(), "VIEW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CastKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CAST".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CAST".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColumnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLUMN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLUMN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ConstraintKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRAINT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DomainKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DOMAIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRAINT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DatabaseKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATABASE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DatabaseReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATABASE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExtensionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXTENSION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExtensionReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXTENSION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FunctionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FUNCTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FunctionParameterListGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FUNCTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IndexKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INDEX".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IndexReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INDEX".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SchemaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CollationKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLLATION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConversionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONVERSION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DomainKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DOMAIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LanguageKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LANGUAGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PolicyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["POLICY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PublicationKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PUBLICATION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RoleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RuleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RULE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SequenceKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SEQUENCE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ServerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SERVER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StatisticsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STATISTICS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SubscriptionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SUBSCRIPTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TablespaceKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLESPACE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TriggerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TRIGGER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TypeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TYPE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AccessKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ACCESS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MethodKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["METHOD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ACCESS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "EventKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EVENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TriggerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TRIGGER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EVENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ForeignKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOREIGN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DataKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WrapperKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WRAPPER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOREIGN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ForeignKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOREIGN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOREIGN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "MaterializedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MATERIALIZED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ViewKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VIEW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MATERIALIZED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TextKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TEXT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SearchKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SEARCH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConfigurationKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONFIGURATION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TEXT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TextKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TEXT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SearchKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SEARCH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DictionaryKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DICTIONARY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TEXT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TextKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TEXT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SearchKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SEARCH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ParserKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PARSER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TEXT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TextKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TEXT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SearchKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SEARCH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TemplateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TEMPLATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TEXT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ACCESS".to_string(), "COLLATION".to_string(), "CONVERSION".to_string(), "DOMAIN".to_string(), "EVENT".to_string(), "FOREIGN".to_string(), "LANGUAGE".to_string(), "MATERIALIZED".to_string(), "POLICY".to_string(), "PUBLICATION".to_string(), "ROLE".to_string(), "RULE".to_string(), "SEQUENCE".to_string(), "SERVER".to_string(), "STATISTICS".to_string(), "SUBSCRIPTION".to_string(), "TABLESPACE".to_string(), "TEXT".to_string(), "TRIGGER".to_string(), "TYPE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ACCESS".to_string(), "COLLATION".to_string(), "CONVERSION".to_string(), "DOMAIN".to_string(), "EVENT".to_string(), "FOREIGN".to_string(), "LANGUAGE".to_string(), "MATERIALIZED".to_string(), "POLICY".to_string(), "PUBLICATION".to_string(), "ROLE".to_string(), "RULE".to_string(), "SEQUENCE".to_string(), "SERVER".to_string(), "STATISTICS".to_string(), "SUBSCRIPTION".to_string(), "TABLESPACE".to_string(), "TEXT".to_string(), "TRIGGER".to_string(), "TYPE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AggregateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AGGREGATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ProcedureKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PROCEDURE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RoutineKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROUTINE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AGGREGATE".to_string(), "PROCEDURE".to_string(), "ROUTINE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Anything)
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AGGREGATE".to_string(), "PROCEDURE".to_string(), "ROUTINE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ACCESS".to_string(), "AGGREGATE".to_string(), "CAST".to_string(), "COLLATION".to_string(), "COLUMN".to_string(), "CONSTRAINT".to_string(), "CONVERSION".to_string(), "DATABASE".to_string(), "DOMAIN".to_string(), "EVENT".to_string(), "EXTENSION".to_string(), "FOREIGN".to_string(), "FUNCTION".to_string(), "INDEX".to_string(), "LANGUAGE".to_string(), "MATERIALIZED".to_string(), "POLICY".to_string(), "PROCEDURE".to_string(), "PUBLICATION".to_string(), "ROLE".to_string(), "ROUTINE".to_string(), "RULE".to_string(), "SCHEMA".to_string(), "SEQUENCE".to_string(), "SERVER".to_string(), "STATISTICS".to_string(), "SUBSCRIPTION".to_string(), "TABLE".to_string(), "TABLESPACE".to_string(), "TEXT".to_string(), "TRIGGER".to_string(), "TYPE".to_string(), "VIEW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NullKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ACCESS".to_string(), "AGGREGATE".to_string(), "CAST".to_string(), "COLLATION".to_string(), "COLUMN".to_string(), "CONSTRAINT".to_string(), "CONVERSION".to_string(), "DATABASE".to_string(), "DOMAIN".to_string(), "EVENT".to_string(), "EXTENSION".to_string(), "FOREIGN".to_string(), "FUNCTION".to_string(), "INDEX".to_string(), "LANGUAGE".to_string(), "MATERIALIZED".to_string(), "POLICY".to_string(), "PROCEDURE".to_string(), "PUBLICATION".to_string(), "ROLE".to_string(), "ROUTINE".to_string(), "RULE".to_string(), "SCHEMA".to_string(), "SEQUENCE".to_string(), "SERVER".to_string(), "STATISTICS".to_string(), "SUBSCRIPTION".to_string(), "TABLE".to_string(), "TABLESPACE".to_string(), "TEXT".to_string(), "TRIGGER".to_string(), "TYPE".to_string(), "VIEW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COMMENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CommentSegment'
pub static COMMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Token{
    token_type: "comment",
//    token_type: "CommentSegment",
})
);

// name='CommentsKeywordSegment'
pub static COMMENTS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "COMMENTS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CommitKeywordSegment'
pub static COMMIT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "COMMIT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CommittedKeywordSegment'
pub static COMMITTED_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "COMMITTED",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CommutatorKeywordSegment'
pub static COMMUTATOR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "COMMUTATOR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ComparisonOperatorGrammar'
pub static COMPARISON_OPERATOR_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "GreaterThanSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([">".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LessThanSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["<".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "GreaterThanOrEqualToSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([">".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LessThanOrEqualToSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["<".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NotEqualToSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["!".to_string(), "<".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LikeOperatorSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["like_operator".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IsDistinctFromGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment_a",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["==".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "GlobOperatorSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["glob_operator".to_string()]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["!".to_string(), "<".to_string(), "=".to_string(), "==".to_string(), ">".to_string(), "IS".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["glob_operator".to_string(), "like_operator".to_string()]),
        }),
})
);

// name='ComparisonOperatorSegment'
pub static COMPARISON_OPERATOR_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Token{
    token_type: "comparison_operator",
//    token_type: "ComparisonOperatorSegment",
})
);

// name='CompletionKeywordSegment'
pub static COMPLETION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "COMPLETION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CompositeBinaryOperatorSegment'
pub static COMPOSITE_BINARY_OPERATOR_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Token{
    token_type: "binary_operator",
//    token_type: "CompositeBinaryOperatorSegment",
})
);

// name='CompositeComparisonOperatorSegment'
pub static COMPOSITE_COMPARISON_OPERATOR_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Token{
    token_type: "comparison_operator",
//    token_type: "CompositeComparisonOperatorSegment",
})
);

// name='CompoundcurveKeywordSegment'
pub static COMPOUNDCURVE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "COMPOUNDCURVE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CompressKeywordSegment'
pub static COMPRESS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "COMPRESS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CompressionKeywordSegment'
pub static COMPRESSION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "COMPRESSION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Compression_levelKeywordSegment'
pub static COMPRESSION_LEVEL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "COMPRESSION_LEVEL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ComputeKeywordSegment'
pub static COMPUTE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "COMPUTE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ConcatSegment'
pub static CONCAT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ConcatSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PipeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["|".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PipeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["|".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: false,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["|".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ConcurrentlyKeywordSegment'
pub static CONCURRENTLY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CONCURRENTLY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ConditionalCrossJoinKeywordsGrammar'
pub static CONDITIONAL_CROSS_JOIN_KEYWORDS_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Nothing())
);

// name='ConditionalJoinKeywordsGrammar'
pub static CONDITIONAL_JOIN_KEYWORDS_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "JoinTypeKeywordsGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FULL".to_string(), "INNER".to_string(), "LEFT".to_string(), "RIGHT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConditionalCrossJoinKeywordsGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "NonStandardJoinTypeKeywordsGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ANTI".to_string(), "ASOF".to_string(), "SEMI".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='ConfigurationKeywordSegment'
pub static CONFIGURATION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CONFIGURATION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ConflictActionSegment'
pub static CONFLICT_ACTION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ConflictActionSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DoKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NothingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOTHING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "UpdateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UPDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DefaultKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RowKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DefaultKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SelectableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "DELETE".to_string(), "FROM".to_string(), "INSERT".to_string(), "PIVOT".to_string(), "PIVOT_LONGER".to_string(), "PIVOT_WIDER".to_string(), "SELECT".to_string(), "UNPIVOT".to_string(), "UPDATE".to_string(), "VALUES".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("dedent"))
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WhereKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHERE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHERE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("dedent"))
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UPDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOTHING".to_string(), "UPDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ConflictKeywordSegment'
pub static CONFLICT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CONFLICT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ConflictTargetSegment'
pub static CONFLICT_TARGET_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ConflictTargetSegment
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CollateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLLATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CollationReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLLATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OperationClassReferenceSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WhereKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHERE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHERE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConstraintKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRAINT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ConnectKeywordSegment'
pub static CONNECT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CONNECT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ConnectionKeywordSegment'
pub static CONNECTION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CONNECTION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ConstraintKeywordSegment'
pub static CONSTRAINT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CONSTRAINT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ConstraintsKeywordSegment'
pub static CONSTRAINTS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CONSTRAINTS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ContainstableKeywordSegment'
pub static CONTAINSTABLE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CONTAINSTABLE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ContentKeywordSegment'
pub static CONTENT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CONTENT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ContinueKeywordSegment'
pub static CONTINUE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CONTINUE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ConversionKeywordSegment'
pub static CONVERSION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CONVERSION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CopyKeywordSegment'
pub static COPY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "COPY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CopyStatementSegment'
pub static COPY_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CopyStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CopyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COPY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SelectableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "DELETE".to_string(), "FROM".to_string(), "INSERT".to_string(), "PIVOT".to_string(), "PIVOT_LONGER".to_string(), "PIVOT_WIDER".to_string(), "SELECT".to_string(), "UNPIVOT".to_string(), "UPDATE".to_string(), "VALUES".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FormatKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FORMAT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FORMAT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "Overwrite_or_ignoreKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OVERWRITE_OR_IGNORE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BooleanLiteralGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FALSE".to_string(), "TRUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OVERWRITE_OR_IGNORE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OverwriteKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OVERWRITE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BooleanLiteralGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FALSE".to_string(), "TRUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OVERWRITE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AppendKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["APPEND".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BooleanLiteralGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FALSE".to_string(), "TRUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["APPEND".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "Partition_byKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PARTITION_BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PARTITION_BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "Write_partition_columnsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WRITE_PARTITION_COLUMNS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BooleanLiteralGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FALSE".to_string(), "TRUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WRITE_PARTITION_COLUMNS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CompressionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COMPRESSION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COMPRESSION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "Compression_levelKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COMPRESSION_LEVEL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COMPRESSION_LEVEL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "Row_group_size_bytesKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROW_GROUP_SIZE_BYTES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROW_GROUP_SIZE_BYTES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "Row_group_sizeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROW_GROUP_SIZE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROW_GROUP_SIZE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "Parquet_versionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PARQUET_VERSION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PARQUET_VERSION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["APPEND".to_string(), "COMPRESSION".to_string(), "COMPRESSION_LEVEL".to_string(), "FORMAT".to_string(), "OVERWRITE".to_string(), "OVERWRITE_OR_IGNORE".to_string(), "PARQUET_VERSION".to_string(), "PARTITION_BY".to_string(), "ROW_GROUP_SIZE".to_string(), "ROW_GROUP_SIZE_BYTES".to_string(), "WRITE_PARTITION_COLUMNS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["APPEND".to_string(), "COMPRESSION".to_string(), "COMPRESSION_LEVEL".to_string(), "FORMAT".to_string(), "OVERWRITE".to_string(), "OVERWRITE_OR_IGNORE".to_string(), "PARQUET_VERSION".to_string(), "PARTITION_BY".to_string(), "ROW_GROUP_SIZE".to_string(), "ROW_GROUP_SIZE_BYTES".to_string(), "WRITE_PARTITION_COLUMNS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "FromKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::AnySetOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FormatKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FORMAT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FORMAT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FreezeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FREEZE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BooleanLiteralGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FALSE".to_string(), "TRUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FREEZE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DelimiterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DELIMITER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DELIMITER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NullKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "HeaderKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["HEADER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BooleanLiteralGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FALSE".to_string(), "TRUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["HEADER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "QuoteKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["QUOTE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["QUOTE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "EscapeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ESCAPE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ESCAPE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "Force_quoteKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FORCE_QUOTE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StarSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["*".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "*".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FORCE_QUOTE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "Force_not_nullKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FORCE_NOT_NULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FORCE_NOT_NULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "Force_nullKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FORCE_NULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FORCE_NULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "EncodingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ENCODING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ENCODING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 0,
    max_times: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DELIMITER".to_string(), "ENCODING".to_string(), "ESCAPE".to_string(), "FORCE_NOT_NULL".to_string(), "FORCE_NULL".to_string(), "FORCE_QUOTE".to_string(), "FORMAT".to_string(), "FREEZE".to_string(), "HEADER".to_string(), "NULL".to_string(), "QUOTE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DELIMITER".to_string(), "ENCODING".to_string(), "ESCAPE".to_string(), "FORCE_NOT_NULL".to_string(), "FORCE_NULL".to_string(), "FORCE_QUOTE".to_string(), "FORMAT".to_string(), "FREEZE".to_string(), "HEADER".to_string(), "NULL".to_string(), "QUOTE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COPY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CostKeywordSegment'
pub static COST_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "COST",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CostsKeywordSegment'
pub static COSTS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "COSTS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CreateAggregateStatementSegment'
pub static CREATE_AGGREGATE_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CreateAggregateStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OrReplaceGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AggregateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AGGREGATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Anything)
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionParameterListGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CreateCastStatementSegment'
pub static CREATE_CAST_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CreateCastStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CastKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CAST".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DatatypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DatatypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FUNCTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "FunctionParameterListGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithoutKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITHOUT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FUNCTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITHOUT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "InoutKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INOUT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string(), "WITHOUT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AssignmentKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ASSIGNMENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ImplicitKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IMPLICIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CreateCollationStatementSegment'
pub static CREATE_COLLATION_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CreateCollationStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CollationKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLLATION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfNotExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LocaleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LOCALE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LOCALE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "Lc_collateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LC_COLLATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LC_COLLATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "Lc_ctypeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LC_CTYPE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LC_CTYPE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ProviderKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PROVIDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IcuKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ICU".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LibcKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LIBC".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ICU".to_string(), "LIBC".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PROVIDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DeterministicKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DETERMINISTIC".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BooleanLiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FALSE".to_string(), "TRUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DETERMINISTIC".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "VersionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VERSION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VERSION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DETERMINISTIC".to_string(), "LC_COLLATE".to_string(), "LC_CTYPE".to_string(), "LOCALE".to_string(), "PROVIDER".to_string(), "VERSION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FromKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CreateDatabaseStatementSegment'
pub static CREATE_DATABASE_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CreateDatabaseStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DatabaseKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATABASE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DatabaseReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OwnerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OWNER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OWNER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TemplateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TEMPLATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TEMPLATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "EncodingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ENCODING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DefaultKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ENCODING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LocaleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LOCALE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LOCALE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "Lc_collateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LC_COLLATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LC_COLLATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "Lc_ctypeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LC_CTYPE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LC_CTYPE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LC_COLLATE".to_string(), "LC_CTYPE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LC_COLLATE".to_string(), "LC_CTYPE".to_string(), "LOCALE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TablespaceKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLESPACE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TablespaceReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DefaultKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLESPACE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "Allow_connectionsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALLOW_CONNECTIONS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BooleanLiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FALSE".to_string(), "TRUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALLOW_CONNECTIONS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ConnectionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONNECTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LimitKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LIMIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONNECTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "Is_templateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IS_TEMPLATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BooleanLiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FALSE".to_string(), "TRUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IS_TEMPLATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALLOW_CONNECTIONS".to_string(), "CONNECTION".to_string(), "ENCODING".to_string(), "IS_TEMPLATE".to_string(), "LC_COLLATE".to_string(), "LC_CTYPE".to_string(), "LOCALE".to_string(), "OWNER".to_string(), "TABLESPACE".to_string(), "TEMPLATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CreateDomainStatementSegment'
pub static CREATE_DOMAIN_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CreateDomainStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DomainKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DOMAIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DatatypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CollateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLLATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CollationReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLLATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DefaultKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ConstraintKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRAINT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRAINT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NotKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NullKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOT".to_string(), "NULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CheckKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHECK".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHECK".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHECK".to_string(), "NOT".to_string(), "NULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHECK".to_string(), "CONSTRAINT".to_string(), "NOT".to_string(), "NULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHECK".to_string(), "CONSTRAINT".to_string(), "NOT".to_string(), "NULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CreateExtensionStatementSegment'
pub static CREATE_EXTENSION_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CreateExtensionStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExtensionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXTENSION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfNotExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExtensionReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SchemaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "VersionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VERSION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "VersionIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VERSION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FromKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "VersionIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CascadeKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CreateForeignDataWrapperStatementSegment'
pub static CREATE_FOREIGN_DATA_WRAPPER_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CreateForeignDataWrapperStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ForeignDataWrapperGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOREIGN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::Ref {
    name: "HandlerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["HANDLER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("dedent"))
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::Ref {
    name: "ValidatorKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VALIDATOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("dedent"))
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CreateForeignTableGrammar'
pub static CREATE_FOREIGN_TABLE_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ForeignKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOREIGN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CreateForeignTableStatementSegment'
pub static CREATE_FOREIGN_TABLE_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CreateForeignTableStatementSegment
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateForeignTableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfNotExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DatatypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "OptionsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OPTIONS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CollateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLLATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CollationReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLLATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ForeignTableColumnConstraintSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHECK".to_string(), "CONSTRAINT".to_string(), "DEFAULT".to_string(), "GENERATED".to_string(), "NOT".to_string(), "NULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHECK".to_string(), "CONSTRAINT".to_string(), "DEFAULT".to_string(), "GENERATED".to_string(), "NOT".to_string(), "NULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ForeignTableTableConstraintSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHECK".to_string(), "CONSTRAINT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "InheritsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INHERITS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INHERITS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ServerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SERVER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ServerReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SERVER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OptionsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OPTIONS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateForeignTableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfNotExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PartitionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PARTITION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OfKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OptionsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OPTIONS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ForeignTableColumnConstraintSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHECK".to_string(), "CONSTRAINT".to_string(), "DEFAULT".to_string(), "GENERATED".to_string(), "NOT".to_string(), "NULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHECK".to_string(), "CONSTRAINT".to_string(), "DEFAULT".to_string(), "GENERATED".to_string(), "NOT".to_string(), "NULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ForeignTableTableConstraintSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHECK".to_string(), "CONSTRAINT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ForKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ValuesKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PartitionBoundSpecSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string(), "IN".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DefaultKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string(), "FOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PARTITION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ServerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SERVER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ServerReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SERVER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OptionsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OPTIONS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CreateFunctionStatementSegment'
pub static CREATE_FUNCTION_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CreateFunctionStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OrReplaceGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TemporaryGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TEMP".to_string(), "TEMPORARY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "MacroKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MACRO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FUNCTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FUNCTION".to_string(), "MACRO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "FunctionParameterListGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::Ref {
    name: "SelectableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "DELETE".to_string(), "FROM".to_string(), "INSERT".to_string(), "PIVOT".to_string(), "PIVOT_LONGER".to_string(), "PIVOT_WIDER".to_string(), "SELECT".to_string(), "UNPIVOT".to_string(), "UPDATE".to_string(), "VALUES".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("dedent"))
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CreateIndexStatementSegment'
pub static CREATE_INDEX_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CreateIndexStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UniqueKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UNIQUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IndexKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INDEX".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConcurrentlyKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONCURRENTLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IfNotExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IndexReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OnlyKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ONLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "UsingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IndexAccessMethodSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IndexElementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IncludeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INCLUDE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IndexElementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INCLUDE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NullsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NULLS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NotKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DistinctKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DISTINCT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NULLS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RelationOptionsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TablespaceKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLESPACE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TablespaceReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLESPACE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WhereKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHERE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHERE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CreateKeywordSegment'
pub static CREATE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CREATE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CreateMaterializedViewStatementSegment'
pub static CREATE_MATERIALIZED_VIEW_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CreateMaterializedViewStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OrReplaceGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MaterializedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MATERIALIZED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ViewKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VIEW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfNotExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "BracketedColumnReferenceListGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "UsingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RelationOptionsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TablespaceKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLESPACE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TablespaceReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLESPACE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SelectableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "DELETE".to_string(), "FROM".to_string(), "INSERT".to_string(), "PIVOT".to_string(), "PIVOT_LONGER".to_string(), "PIVOT_WIDER".to_string(), "SELECT".to_string(), "UNPIVOT".to_string(), "UPDATE".to_string(), "VALUES".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SelectableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "DELETE".to_string(), "FROM".to_string(), "INSERT".to_string(), "PIVOT".to_string(), "PIVOT_LONGER".to_string(), "PIVOT_WIDER".to_string(), "SELECT".to_string(), "UNPIVOT".to_string(), "UPDATE".to_string(), "VALUES".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "DELETE".to_string(), "FROM".to_string(), "INSERT".to_string(), "PIVOT".to_string(), "PIVOT_LONGER".to_string(), "PIVOT_WIDER".to_string(), "SELECT".to_string(), "UNPIVOT".to_string(), "UPDATE".to_string(), "VALUES".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ValuesClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExecuteKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXECUTE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXECUTE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExecuteKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXECUTE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXECUTE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "EXECUTE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "DELETE".to_string(), "EXECUTE".to_string(), "FROM".to_string(), "INSERT".to_string(), "PIVOT".to_string(), "PIVOT_LONGER".to_string(), "PIVOT_WIDER".to_string(), "SELECT".to_string(), "TABLE".to_string(), "UNPIVOT".to_string(), "UPDATE".to_string(), "VALUES".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WithDataClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CreateModelStatementSegment'
pub static CREATE_MODEL_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CreateModelStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OrReplaceGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ModelKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MODEL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfNotExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OptionsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OPTIONS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "+".to_string(), "-".to_string(), ":".to_string(), "ARRAY".to_string(), "DATE".to_string(), "FALSE".to_string(), "INTERVAL".to_string(), "NULL".to_string(), "TIME".to_string(), "TIMESTAMP".to_string(), "TIMESTAMPTZ".to_string(), "TIMETZ".to_string(), "TRUE".to_string(), "VARIADIC".to_string(), "[".to_string(), "{".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_numeric_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "numeric_literal".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "[",
    token_type: "start_square_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: "]",
    token_type: "end_square_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["[".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "+".to_string(), "-".to_string(), ":".to_string(), "ARRAY".to_string(), "DATE".to_string(), "FALSE".to_string(), "INTERVAL".to_string(), "NULL".to_string(), "TIME".to_string(), "TIMESTAMP".to_string(), "TIMESTAMPTZ".to_string(), "TIMETZ".to_string(), "TRUE".to_string(), "VARIADIC".to_string(), "[".to_string(), "{".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_numeric_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "numeric_literal".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OPTIONS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SelectableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "DELETE".to_string(), "FROM".to_string(), "INSERT".to_string(), "PIVOT".to_string(), "PIVOT_LONGER".to_string(), "PIVOT_WIDER".to_string(), "SELECT".to_string(), "UNPIVOT".to_string(), "UPDATE".to_string(), "VALUES".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CreateOperatorStatementSegment'
pub static CREATE_OPERATOR_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CreateOperatorStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OperatorKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OPERATOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::RegexParser {
    template: RegexMode::new(r#"^[+\-*/<>=~!@#%^&|`?]+$"#),
    token_type: "commutator",
    raw_class: "SymbolSegment",
    optional: false,
    anti_template: None,
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LeftargKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LEFTARG".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RightargKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RIGHTARG".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LEFTARG".to_string(), "RIGHTARG".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LEFTARG".to_string(), "RIGHTARG".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CommutatorKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COMMUTATOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::RegexParser {
    template: RegexMode::new(r#"^[+\-*/<>=~!@#%^&|`?]+$"#),
    token_type: "commutator",
    raw_class: "SymbolSegment",
    optional: false,
    anti_template: None,
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COMMUTATOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NegatorKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NEGATOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::RegexParser {
    template: RegexMode::new(r#"^[+\-*/<>=~!@#%^&|`?]+$"#),
    token_type: "negator",
    raw_class: "SymbolSegment",
    optional: false,
    anti_template: None,
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NEGATOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RestrictKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "JoinKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["JOIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ProcedureKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PROCEDURE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FUNCTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FUNCTION".to_string(), "PROCEDURE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FUNCTION".to_string(), "JOIN".to_string(), "PROCEDURE".to_string(), "RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FUNCTION".to_string(), "JOIN".to_string(), "PROCEDURE".to_string(), "RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "HashesKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["HASHES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MergesKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MERGES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COMMUTATOR".to_string(), "FUNCTION".to_string(), "HASHES".to_string(), "JOIN".to_string(), "LEFTARG".to_string(), "MERGES".to_string(), "NEGATOR".to_string(), "PROCEDURE".to_string(), "RESTRICT".to_string(), "RIGHTARG".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CreatePolicyStatementSegment'
pub static CREATE_POLICY_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CreatePolicyStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PolicyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["POLICY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PermissiveKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PERMISSIVE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RestrictiveKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESTRICTIVE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PERMISSIVE".to_string(), "RESTRICTIVE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ForKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AllKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SelectKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SELECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "InsertKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INSERT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UpdateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UPDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DeleteKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DELETE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string(), "DELETE".to_string(), "INSERT".to_string(), "SELECT".to_string(), "UPDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "PublicKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PUBLIC".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Current_roleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_ROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Current_userKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Session_userKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SESSION_USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "UsingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CheckKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHECK".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CreateProcedureStatementSegment'
pub static CREATE_PROCEDURE_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CreateProcedureStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OrReplaceGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ProcedureKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PROCEDURE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "FunctionParameterListGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionDefinitionGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string(), "BEGIN".to_string(), "CALLED".to_string(), "COST".to_string(), "EXTERNAL".to_string(), "IMMUTABLE".to_string(), "LANGUAGE".to_string(), "LEAKPROOF".to_string(), "NOT".to_string(), "PARALLEL".to_string(), "RETURN".to_string(), "RETURNS".to_string(), "ROWS".to_string(), "SECURITY".to_string(), "SET".to_string(), "STABLE".to_string(), "STRICT".to_string(), "SUPPORT".to_string(), "TRANSFORM".to_string(), "VOLATILE".to_string(), "WINDOW".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CreatePublicationStatementSegment'
pub static CREATE_PUBLICATION_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CreatePublicationStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PublicationKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PUBLICATION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PublicationReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ForKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AllKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TablesKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ForKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PublicationObjectsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string(), "TABLES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string(), "TABLES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DefinitionParametersSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CreateRoleStatementSegment'
pub static CREATE_ROLE_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CreateRoleStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RoleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UserKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROLE".to_string(), "USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RoleReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::AnySetOf {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SuperuserKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SUPERUSER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NosuperuserKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOSUPERUSER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOSUPERUSER".to_string(), "SUPERUSER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreatedbKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATEDB".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NocreatedbKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOCREATEDB".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATEDB".to_string(), "NOCREATEDB".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateroleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATEROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NocreateroleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOCREATEROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATEROLE".to_string(), "NOCREATEROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "InheritKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INHERIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NoinheritKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOINHERIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INHERIT".to_string(), "NOINHERIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LoginKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LOGIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NologinKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOLOGIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LOGIN".to_string(), "NOLOGIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ReplicationKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REPLICATION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NoreplicationKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOREPLICATION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOREPLICATION".to_string(), "REPLICATION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "BypassrlsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BYPASSRLS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NobypassrlsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOBYPASSRLS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BYPASSRLS".to_string(), "NOBYPASSRLS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ConnectionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONNECTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LimitKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LIMIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONNECTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "EncryptedKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ENCRYPTED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PasswordKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PASSWORD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NullKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ENCRYPTED".to_string(), "PASSWORD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ValidKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VALID".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UntilKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UNTIL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VALID".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "InKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RoleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RoleReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "InKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "GroupKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RoleReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RoleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RoleReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AdminKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADMIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RoleReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADMIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "UserKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RoleReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SysidKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SYSID".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SYSID".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 0,
    max_times: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADMIN".to_string(), "BYPASSRLS".to_string(), "CONNECTION".to_string(), "CREATEDB".to_string(), "CREATEROLE".to_string(), "ENCRYPTED".to_string(), "IN".to_string(), "INHERIT".to_string(), "LOGIN".to_string(), "NOBYPASSRLS".to_string(), "NOCREATEDB".to_string(), "NOCREATEROLE".to_string(), "NOINHERIT".to_string(), "NOLOGIN".to_string(), "NOREPLICATION".to_string(), "NOSUPERUSER".to_string(), "PASSWORD".to_string(), "REPLICATION".to_string(), "ROLE".to_string(), "SUPERUSER".to_string(), "SYSID".to_string(), "USER".to_string(), "VALID".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ADMIN".to_string(), "BYPASSRLS".to_string(), "CONNECTION".to_string(), "CREATEDB".to_string(), "CREATEROLE".to_string(), "ENCRYPTED".to_string(), "IN".to_string(), "INHERIT".to_string(), "LOGIN".to_string(), "NOBYPASSRLS".to_string(), "NOCREATEDB".to_string(), "NOCREATEROLE".to_string(), "NOINHERIT".to_string(), "NOLOGIN".to_string(), "NOREPLICATION".to_string(), "NOSUPERUSER".to_string(), "PASSWORD".to_string(), "REPLICATION".to_string(), "ROLE".to_string(), "SUPERUSER".to_string(), "SYSID".to_string(), "USER".to_string(), "VALID".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CreateSchemaStatementSegment'
pub static CREATE_SCHEMA_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CreateSchemaStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfNotExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SchemaReferenceSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AuthorizationKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AUTHORIZATION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RoleReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "SchemaReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CreateSequenceOptionsSegment'
pub static CREATE_SEQUENCE_OPTIONS_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CreateSequenceOptionsSegment
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DatatypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IncrementKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INCREMENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SignedSegmentGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["+".to_string(), "-".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INCREMENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "MinvalueKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MINVALUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SignedSegmentGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["+".to_string(), "-".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MINVALUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NoKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MinvalueKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MINVALUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MINVALUE".to_string(), "NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "MaxvalueKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MAXVALUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SignedSegmentGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["+".to_string(), "-".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MAXVALUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NoKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MaxvalueKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MAXVALUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MAXVALUE".to_string(), "NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "StartKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["START".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SignedSegmentGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["+".to_string(), "-".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["START".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CacheKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CACHE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CACHE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CycleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CYCLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NoKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CycleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CYCLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CYCLE".to_string(), "NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OwnedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OWNED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NoneKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NONE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OWNED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string(), "CACHE".to_string(), "CYCLE".to_string(), "INCREMENT".to_string(), "MAXVALUE".to_string(), "MINVALUE".to_string(), "NO".to_string(), "OWNED".to_string(), "START".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CreateSequenceStatementSegment'
pub static CREATE_SEQUENCE_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CreateSequenceStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TemporaryGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TEMP".to_string(), "TEMPORARY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SequenceKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SEQUENCE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfNotExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SequenceReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateSequenceOptionsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string(), "CACHE".to_string(), "CYCLE".to_string(), "INCREMENT".to_string(), "MAXVALUE".to_string(), "MINVALUE".to_string(), "NO".to_string(), "OWNED".to_string(), "START".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string(), "CACHE".to_string(), "CYCLE".to_string(), "INCREMENT".to_string(), "MAXVALUE".to_string(), "MINVALUE".to_string(), "NO".to_string(), "OWNED".to_string(), "START".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CreateServerStatementSegment'
pub static CREATE_SERVER_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CreateServerStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ServerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SERVER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfNotExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ServerReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TypeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TYPE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TYPE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "VersionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VERSION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "VersionIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VERSION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ForeignDataWrapperGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOREIGN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "OptionsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OPTIONS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CreateStatisticsStatementSegment'
pub static CREATE_STATISTICS_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CreateStatisticsStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StatisticsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STATISTICS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IfNotExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StatisticsReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DependenciesKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEPENDENCIES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "McvKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MCV".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NdistinctKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NDISTINCT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEPENDENCIES".to_string(), "MCV".to_string(), "NDISTINCT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "FromKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CreateSubscriptionStatementSegment'
pub static CREATE_SUBSCRIPTION_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CreateSubscriptionStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SubscriptionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SUBSCRIPTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SubscriptionReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ConnectionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONNECTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PublicationKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PUBLICATION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PublicationReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DefinitionParametersSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CreateTableAsStatementSegment'
pub static CREATE_TABLE_AS_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Nothing())
);

// name='CreateTableStatementSegment'
pub static CREATE_TABLE_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CreateTableStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OrReplaceGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TemporaryGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TEMP".to_string(), "TEMPORARY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfNotExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SelectableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "DELETE".to_string(), "FROM".to_string(), "INSERT".to_string(), "PIVOT".to_string(), "PIVOT_LONGER".to_string(), "PIVOT_WIDER".to_string(), "SELECT".to_string(), "UNPIVOT".to_string(), "UPDATE".to_string(), "VALUES".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SelectableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "DELETE".to_string(), "FROM".to_string(), "INSERT".to_string(), "PIVOT".to_string(), "PIVOT_LONGER".to_string(), "PIVOT_WIDER".to_string(), "SELECT".to_string(), "UNPIVOT".to_string(), "UPDATE".to_string(), "VALUES".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "DELETE".to_string(), "FROM".to_string(), "INSERT".to_string(), "PIVOT".to_string(), "PIVOT_LONGER".to_string(), "PIVOT_WIDER".to_string(), "SELECT".to_string(), "UNPIVOT".to_string(), "UPDATE".to_string(), "VALUES".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DatatypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColumnConstraintSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHECK".to_string(), "COLLATE".to_string(), "DEFAULT".to_string(), "NOT".to_string(), "NULL".to_string(), "PRIMARY".to_string(), "REFERENCES".to_string(), "UNIQUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHECK".to_string(), "COLLATE".to_string(), "DEFAULT".to_string(), "NOT".to_string(), "NULL".to_string(), "PRIMARY".to_string(), "REFERENCES".to_string(), "UNIQUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHECK".to_string(), "COLLATE".to_string(), "DEFAULT".to_string(), "NOT".to_string(), "NULL".to_string(), "PRIMARY".to_string(), "REFERENCES".to_string(), "UNIQUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DatatypeSegment",
    optional: true,
    allow_gaps: true,
    exclude: Some(Box::new(
Arc::new(Grammar::Ref {
    name: "AsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    )),
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "GeneratedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GENERATED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AlwaysKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALWAYS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GENERATED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "StoredKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STORED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "VirtualKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VIRTUAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STORED".to_string(), "VIRTUAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "TableConstraintSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHECK".to_string(), "CONSTRAINT".to_string(), "EXCLUDE".to_string(), "FOREIGN".to_string(), "PRIMARY".to_string(), "UNIQUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CreateTextSearchConfigurationStatementSegment'
pub static CREATE_TEXT_SEARCH_CONFIGURATION_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CreateTextSearchConfigurationStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TextKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TEXT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SearchKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SEARCH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConfigurationKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONFIGURATION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ParserKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PARSER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PARSER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CopyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COPY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COPY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COPY".to_string(), "PARSER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CreateTriggerStatementSegment'
pub static CREATE_TRIGGER_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CreateTriggerStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OrReplaceGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConstraintKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRAINT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TriggerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TRIGGER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TriggerReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "BeforeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BEFORE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AfterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AFTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "InsteadKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INSTEAD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OfKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INSTEAD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AFTER".to_string(), "BEFORE".to_string(), "INSTEAD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "InsertKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INSERT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DeleteKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DELETE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TruncateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TRUNCATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "UpdateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UPDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OfKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "OrKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UPDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "OrKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DELETE".to_string(), "INSERT".to_string(), "TRUNCATE".to_string(), "UPDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FromKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NotKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DeferrableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFERRABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DeferrableKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFERRABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "InitiallyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INITIALLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ImmediateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IMMEDIATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INITIALLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "InitiallyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INITIALLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DeferredKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFERRED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INITIALLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INITIALLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFERRABLE".to_string(), "INITIALLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFERRABLE".to_string(), "INITIALLY".to_string(), "NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ReferencingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REFERENCING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OldKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OLD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NewKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NEW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NEW".to_string(), "OLD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OldKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OLD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NewKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NEW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NEW".to_string(), "OLD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NEW".to_string(), "OLD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REFERENCING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ForKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EachKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EACH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RowKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StatementKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STATEMENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROW".to_string(), "STATEMENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WhenKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFERRABLE".to_string(), "FOR".to_string(), "FROM".to_string(), "INITIALLY".to_string(), "NOT".to_string(), "REFERENCING".to_string(), "WHEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExecuteKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXECUTE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FunctionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FUNCTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ProcedureKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PROCEDURE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FUNCTION".to_string(), "PROCEDURE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXECUTE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CreateTypeStatementSegment'
pub static CREATE_TYPE_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CreateTypeStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TypeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TYPE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DatatypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DatatypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "EnumKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ENUM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ENUM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StructTypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STRUCT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "UnionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UNION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StructTypeSchemaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UNION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CreateUserMappingGrammar'
pub static CREATE_USER_MAPPING_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UserKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MappingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MAPPING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CreateUserMappingStatementSegment'
pub static CREATE_USER_MAPPING_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CreateUserMappingStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateUserMappingGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfNotExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ForKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PublicKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PUBLIC".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "SessionInformationUserFunctionsGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_ROLE".to_string(), "CURRENT_USER".to_string(), "SESSION_USER".to_string(), "USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ServerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SERVER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ServerReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "OptionsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OPTIONS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CreateUserStatementSegment'
pub static CREATE_USER_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CreateUserStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UserKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RoleReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CreateViewStatementSegment'
pub static CREATE_VIEW_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CreateViewStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CreateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OrReplaceGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TemporaryGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TEMP".to_string(), "TEMPORARY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ViewKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VIEW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfNotExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "BracketedColumnReferenceListGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SelectableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "DELETE".to_string(), "FROM".to_string(), "INSERT".to_string(), "PIVOT".to_string(), "PIVOT_LONGER".to_string(), "PIVOT_WIDER".to_string(), "SELECT".to_string(), "UNPIVOT".to_string(), "UPDATE".to_string(), "VALUES".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SelectableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "DELETE".to_string(), "FROM".to_string(), "INSERT".to_string(), "PIVOT".to_string(), "PIVOT_LONGER".to_string(), "PIVOT_WIDER".to_string(), "SELECT".to_string(), "UNPIVOT".to_string(), "UPDATE".to_string(), "VALUES".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "DELETE".to_string(), "FROM".to_string(), "INSERT".to_string(), "PIVOT".to_string(), "PIVOT_LONGER".to_string(), "PIVOT_WIDER".to_string(), "SELECT".to_string(), "UNPIVOT".to_string(), "UPDATE".to_string(), "VALUES".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ValuesClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "DELETE".to_string(), "FROM".to_string(), "INSERT".to_string(), "PIVOT".to_string(), "PIVOT_LONGER".to_string(), "PIVOT_WIDER".to_string(), "SELECT".to_string(), "UNPIVOT".to_string(), "UPDATE".to_string(), "VALUES".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CreatedbKeywordSegment'
pub static CREATEDB_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CREATEDB",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CreateroleKeywordSegment'
pub static CREATEROLE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CREATEROLE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CreateuserKeywordSegment'
pub static CREATEUSER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CREATEUSER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CrossKeywordSegment'
pub static CROSS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CROSS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CsvKeywordSegment'
pub static CSV_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CSV",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CubeFunctionNameSegment'
pub static CUBE_FUNCTION_NAME_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CubeFunctionNameSegment
Arc::new(Grammar::StringParser {
    template: "CUBE",
    token_type: "function_name_identifier",
    raw_class: "CodeSegment",
    optional: false,
})
);

// name='CubeKeywordSegment'
pub static CUBE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CUBE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CubeRollupClauseSegment'
pub static CUBE_ROLLUP_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// CubeRollupClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CubeFunctionNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CUBE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RollupFunctionNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROLLUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CUBE".to_string(), "ROLLUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "GroupingExpressionList",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CUBE".to_string(), "ROLLUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='CurrentKeywordSegment'
pub static CURRENT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CURRENT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Current_catalogKeywordSegment'
pub static CURRENT_CATALOG_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CURRENT_CATALOG",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Current_dateKeywordSegment'
pub static CURRENT_DATE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CURRENT_DATE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Current_roleKeywordSegment'
pub static CURRENT_ROLE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CURRENT_ROLE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Current_schemaKeywordSegment'
pub static CURRENT_SCHEMA_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CURRENT_SCHEMA",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Current_timeKeywordSegment'
pub static CURRENT_TIME_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CURRENT_TIME",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Current_timestampKeywordSegment'
pub static CURRENT_TIMESTAMP_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CURRENT_TIMESTAMP",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Current_userKeywordSegment'
pub static CURRENT_USER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CURRENT_USER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CursorKeywordSegment'
pub static CURSOR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CURSOR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CurvepolygonKeywordSegment'
pub static CURVEPOLYGON_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CURVEPOLYGON",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='CycleKeywordSegment'
pub static CYCLE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "CYCLE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DataKeywordSegment'
pub static DATA_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DATA",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DatabaseKeywordSegment'
pub static DATABASE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DATABASE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DatabaseReferenceSegment'
pub static DATABASE_REFERENCE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DatabaseReferenceSegment
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "ObjectReferenceDelimiterGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "ObjectReferenceTerminatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["!".to_string(), "%".to_string(), "&".to_string(), "(".to_string(), "*".to_string(), "+".to_string(), ",".to_string(), "-".to_string(), "/".to_string(), "//".to_string(), ":".to_string(), "::".to_string(), ";".to_string(), "<".to_string(), "=".to_string(), "==".to_string(), ">".to_string(), "AND".to_string(), "AS".to_string(), "COLLATE".to_string(), "IS".to_string(), "ON".to_string(), "OR".to_string(), "PIVOT".to_string(), "UNPIVOT".to_string(), "USING".to_string(), "[".to_string(), "^".to_string(), "|".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["glob_operator".to_string(), "json_operator".to_string(), "like_operator".to_string()]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: false,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='DatabasesKeywordSegment'
pub static DATABASES_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DATABASES",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DatatypeIdentifierSegment'
pub static DATATYPE_IDENTIFIER_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::RegexParser {
    template: RegexMode::new(r#"[A-Z_][A-Z0-9_]*"#),
    token_type: "data_type_identifier",
    raw_class: "CodeSegment",
    optional: false,
    anti_template: Some(RegexMode::new(r#"^(NOT)$"#)),
})
,
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: Some(Box::new(
Arc::new(Grammar::Ref {
    name: "NakedIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
    )),
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='DatatypeSegment'
pub static DATATYPE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DatatypeSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DotSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: false,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WellKnownTextGeometrySegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CIRCULARSTRING".to_string(), "COMPOUNDCURVE".to_string(), "CURVEPOLYGON".to_string(), "GEOGRAPHY".to_string(), "GEOMETRY".to_string(), "GEOMETRYCOLLECTION".to_string(), "GEOMETRYCOLLECTIONM".to_string(), "GEOMETRYCOLLECTIONZ".to_string(), "GEOMETRYCOLLECTIONZM".to_string(), "LINESTRING".to_string(), "LINESTRINGM".to_string(), "LINESTRINGZ".to_string(), "LINESTRINGZM".to_string(), "MULTICURVE".to_string(), "MULTILINESTRING".to_string(), "MULTILINESTRINGM".to_string(), "MULTILINESTRINGZ".to_string(), "MULTILINESTRINGZM".to_string(), "MULTIPOINT".to_string(), "MULTIPOINTM".to_string(), "MULTIPOINTZ".to_string(), "MULTIPOINTZM".to_string(), "MULTIPOLYGON".to_string(), "MULTIPOLYGONM".to_string(), "MULTIPOLYGONZ".to_string(), "MULTIPOLYGONZM".to_string(), "MULTISURFACE".to_string(), "POINT".to_string(), "POINTM".to_string(), "POINTZ".to_string(), "POINTZM".to_string(), "POLYGON".to_string(), "POLYGONM".to_string(), "POLYGONZ".to_string(), "POLYGONZM".to_string(), "POLYHEDRALSURFACE".to_string(), "TIN".to_string(), "TRIANGLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DateTimeTypeIdentifier",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATE".to_string(), "INTERVAL".to_string(), "TIME".to_string(), "TIMESTAMP".to_string(), "TIMESTAMPTZ".to_string(), "TIMETZ".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StructTypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STRUCT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MapTypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MAP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SmallintKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SMALLINT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IntegerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INTEGER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IntKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Int2KeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INT2".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Int4KeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INT4".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Int8KeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INT8".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BigintKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BIGINT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Float4KeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FLOAT4".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Float8KeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FLOAT8".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RealKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DoubleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DOUBLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PrecisionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PRECISION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DOUBLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SmallserialKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SMALLSERIAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SerialKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SERIAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Serial2KeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SERIAL2".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Serial4KeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SERIAL4".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Serial8KeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SERIAL8".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BigserialKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BIGSERIAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FloatKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FLOAT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FLOAT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BracketedArguments",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FLOAT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DecimalKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DECIMAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NUMERIC".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DECIMAL".to_string(), "NUMERIC".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BracketedArguments",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DECIMAL".to_string(), "NUMERIC".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MoneyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MONEY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "BpcharKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BPCHAR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CharKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHAR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CharKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHAR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "VaryingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VARYING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHAR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CharacterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHARACTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CharacterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHARACTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "VaryingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VARYING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHARACTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "VarcharKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VARCHAR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BPCHAR".to_string(), "CHAR".to_string(), "CHARACTER".to_string(), "VARCHAR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BracketedArguments",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BPCHAR".to_string(), "CHAR".to_string(), "CHARACTER".to_string(), "VARCHAR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TextKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TEXT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BPCHAR".to_string(), "CHAR".to_string(), "CHARACTER".to_string(), "TEXT".to_string(), "VARCHAR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ByteaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BYTEA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "BooleanKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BOOLEAN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BoolKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BOOL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BOOL".to_string(), "BOOLEAN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PointKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["POINT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LineKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LINE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LsegKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LSEG".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BoxKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BOX".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PathKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PATH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PolygonKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["POLYGON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CircleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CIRCLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BOX".to_string(), "CIRCLE".to_string(), "LINE".to_string(), "LSEG".to_string(), "PATH".to_string(), "POINT".to_string(), "POLYGON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CidrKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CIDR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "InetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MacaddrKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MACADDR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Macaddr8KeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MACADDR8".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CIDR".to_string(), "INET".to_string(), "MACADDR".to_string(), "MACADDR8".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TsvectorKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TSVECTOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TsqueryKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TSQUERY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TSQUERY".to_string(), "TSVECTOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "BitKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "VaryingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VARYING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VARYING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BracketedArguments",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UuidKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UUID".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "XmlKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["XML".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "JsonKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["JSON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "JsonbKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["JSONB".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["JSON".to_string(), "JSONB".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Int4rangeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INT4RANGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Int8rangeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INT8RANGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumrangeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NUMRANGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TsrangeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TSRANGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TstzrangeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TSTZRANGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DaterangeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATERANGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Pg_lsnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PG_LSN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "VectorKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VECTOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BracketedArguments",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VECTOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BIGINT".to_string(), "BIGSERIAL".to_string(), "BIT".to_string(), "BOOL".to_string(), "BOOLEAN".to_string(), "BOX".to_string(), "BPCHAR".to_string(), "BYTEA".to_string(), "CHAR".to_string(), "CHARACTER".to_string(), "CIDR".to_string(), "CIRCLE".to_string(), "DATERANGE".to_string(), "DECIMAL".to_string(), "DOUBLE".to_string(), "FLOAT".to_string(), "FLOAT4".to_string(), "FLOAT8".to_string(), "INET".to_string(), "INT".to_string(), "INT2".to_string(), "INT4".to_string(), "INT4RANGE".to_string(), "INT8".to_string(), "INT8RANGE".to_string(), "INTEGER".to_string(), "JSON".to_string(), "JSONB".to_string(), "LINE".to_string(), "LSEG".to_string(), "MACADDR".to_string(), "MACADDR8".to_string(), "MONEY".to_string(), "NUMERIC".to_string(), "NUMRANGE".to_string(), "PATH".to_string(), "PG_LSN".to_string(), "POINT".to_string(), "POLYGON".to_string(), "REAL".to_string(), "SERIAL".to_string(), "SERIAL2".to_string(), "SERIAL4".to_string(), "SERIAL8".to_string(), "SMALLINT".to_string(), "SMALLSERIAL".to_string(), "TEXT".to_string(), "TSQUERY".to_string(), "TSRANGE".to_string(), "TSTZRANGE".to_string(), "TSVECTOR".to_string(), "UUID".to_string(), "VARCHAR".to_string(), "VECTOR".to_string(), "XML".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BIGINT".to_string(), "BIGSERIAL".to_string(), "BIT".to_string(), "BOOL".to_string(), "BOOLEAN".to_string(), "BOX".to_string(), "BPCHAR".to_string(), "BYTEA".to_string(), "CHAR".to_string(), "CHARACTER".to_string(), "CIDR".to_string(), "CIRCLE".to_string(), "DATERANGE".to_string(), "DECIMAL".to_string(), "DOUBLE".to_string(), "FLOAT".to_string(), "FLOAT4".to_string(), "FLOAT8".to_string(), "INET".to_string(), "INT".to_string(), "INT2".to_string(), "INT4".to_string(), "INT4RANGE".to_string(), "INT8".to_string(), "INT8RANGE".to_string(), "INTEGER".to_string(), "JSON".to_string(), "JSONB".to_string(), "LINE".to_string(), "LSEG".to_string(), "MACADDR".to_string(), "MACADDR8".to_string(), "MONEY".to_string(), "NUMERIC".to_string(), "NUMRANGE".to_string(), "PATH".to_string(), "PG_LSN".to_string(), "POINT".to_string(), "POLYGON".to_string(), "REAL".to_string(), "SERIAL".to_string(), "SERIAL2".to_string(), "SERIAL4".to_string(), "SERIAL8".to_string(), "SMALLINT".to_string(), "SMALLSERIAL".to_string(), "TEXT".to_string(), "TSQUERY".to_string(), "TSRANGE".to_string(), "TSTZRANGE".to_string(), "TSVECTOR".to_string(), "UUID".to_string(), "VARCHAR".to_string(), "VECTOR".to_string(), "XML".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DatatypeIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "[",
    token_type: "start_square_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: "]",
    token_type: "end_square_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["[".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["[".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ArrayTypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ARRAY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SizedArrayTypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ARRAY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ARRAY".to_string(), "[".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='DateKeywordSegment'
pub static DATE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DATE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DatePartFunctionName'
pub static DATE_PART_FUNCTION_NAME: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::MultiStringParser {
    templates: vec![],
    token_type: "function_name_identifier",
    raw_class: "CodeSegment",
    optional: false,
})
);

// name='DatePartFunctionNameSegment'
pub static DATE_PART_FUNCTION_NAME_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DatePartFunctionNameSegment
Arc::new(Grammar::Ref {
    name: "DatePartFunctionName",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DateTimeFunctionContentsSegment'
pub static DATE_TIME_FUNCTION_CONTENTS_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DateTimeFunctionContentsSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DatetimeUnitSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CENTURY".to_string(), "DAY".to_string(), "DAYOFYEAR".to_string(), "DECADE".to_string(), "DOW".to_string(), "DOY".to_string(), "EPOCH".to_string(), "HOUR".to_string(), "ISODOW".to_string(), "ISOYEAR".to_string(), "MICROSECONDS".to_string(), "MILLENNIUM".to_string(), "MILLISECOND".to_string(), "MILLISECONDS".to_string(), "MINUTE".to_string(), "MONTH".to_string(), "QUARTER".to_string(), "SECOND".to_string(), "TIMEZONE".to_string(), "TIMEZONE_HOUR".to_string(), "TIMEZONE_MINUTE".to_string(), "WEEK".to_string(), "WEEKDAY".to_string(), "YEAR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionContentsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DateTimeLiteralGrammar'
pub static DATE_TIME_LITERAL_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
// DateTimeLiteralGrammar
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DateTimeTypeIdentifier",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATE".to_string(), "INTERVAL".to_string(), "TIME".to_string(), "TIMESTAMP".to_string(), "TIMESTAMPTZ".to_string(), "TIMETZ".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATE".to_string(), "INTERVAL".to_string(), "TIME".to_string(), "TIMESTAMP".to_string(), "TIMESTAMPTZ".to_string(), "TIMETZ".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
);

// name='DateTimeTypeIdentifier'
pub static DATE_TIME_TYPE_IDENTIFIER: Lazy<Arc<Grammar>> = Lazy::new(||
// DateTimeTypeIdentifier
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TimeWithTZGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TIME".to_string(), "TIMESTAMP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IntervalKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INTERVAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TimetzKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TIMETZ".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TimestamptzKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TIMESTAMPTZ".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INTERVAL".to_string(), "TIMESTAMPTZ".to_string(), "TIMETZ".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INTERVAL".to_string(), "TIMESTAMPTZ".to_string(), "TIMETZ".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATE".to_string(), "INTERVAL".to_string(), "TIME".to_string(), "TIMESTAMP".to_string(), "TIMESTAMPTZ".to_string(), "TIMETZ".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DaterangeKeywordSegment'
pub static DATERANGE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DATERANGE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DatetimeKeywordSegment'
pub static DATETIME_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DATETIME",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DatetimeUnitSegment'
pub static DATETIME_UNIT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::MultiStringParser {
    templates: vec!["CENTURY", "DAY", "DAYOFYEAR", "DECADE", "DOW", "DOY", "EPOCH", "HOUR", "ISODOW", "ISOYEAR", "MICROSECONDS", "MILLENNIUM", "MILLISECOND", "MILLISECONDS", "MINUTE", "MONTH", "QUARTER", "SECOND", "TIMEZONE", "TIMEZONE_HOUR", "TIMEZONE_MINUTE", "WEEK", "WEEKDAY", "YEAR"],
    token_type: "date_part",
    raw_class: "CodeSegment",
    optional: false,
})
);

// name='DayKeywordSegment'
pub static DAY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DAY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Day_hourKeywordSegment'
pub static DAY_HOUR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DAY_HOUR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Day_microsecondKeywordSegment'
pub static DAY_MICROSECOND_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DAY_MICROSECOND",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Day_minuteKeywordSegment'
pub static DAY_MINUTE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DAY_MINUTE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Day_secondKeywordSegment'
pub static DAY_SECOND_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DAY_SECOND",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DayofmonthKeywordSegment'
pub static DAYOFMONTH_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DAYOFMONTH",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DayofweekKeywordSegment'
pub static DAYOFWEEK_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DAYOFWEEK",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DayofyearKeywordSegment'
pub static DAYOFYEAR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DAYOFYEAR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DaysKeywordSegment'
pub static DAYS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DAYS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DbccKeywordSegment'
pub static DBCC_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DBCC",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DeallocateKeywordSegment'
pub static DEALLOCATE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DEALLOCATE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DeallocateStatementSegment'
pub static DEALLOCATE_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DeallocateStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DeallocateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEALLOCATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PrepareKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PREPARE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AllKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEALLOCATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DecKeywordSegment'
pub static DEC_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DEC",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DecimalKeywordSegment'
pub static DECIMAL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DECIMAL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DeclareKeywordSegment'
pub static DECLARE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DECLARE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Dedent'
pub static DEDENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Meta("dedent"))
);

// name='DefaultKeywordSegment'
pub static DEFAULT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DEFAULT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DefaultValuesGrammar'
pub static DEFAULT_VALUES_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DefaultKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ValuesKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DefaultsKeywordSegment'
pub static DEFAULTS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DEFAULTS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DeferrableKeywordSegment'
pub static DEFERRABLE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DEFERRABLE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DeferredKeywordSegment'
pub static DEFERRED_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DEFERRED",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DefinerKeywordSegment'
pub static DEFINER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DEFINER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DefinitionArgumentValueGrammar'
pub static DEFINITION_ARGUMENT_VALUE_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "+".to_string(), "-".to_string(), ":".to_string(), "ARRAY".to_string(), "DATE".to_string(), "FALSE".to_string(), "INTERVAL".to_string(), "NULL".to_string(), "TIME".to_string(), "TIMESTAMP".to_string(), "TIMESTAMPTZ".to_string(), "TIMETZ".to_string(), "TRUE".to_string(), "VARIADIC".to_string(), "[".to_string(), "{".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_numeric_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "numeric_literal".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PropertiesNakedIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["word".to_string()]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "+".to_string(), "-".to_string(), ":".to_string(), "ARRAY".to_string(), "DATE".to_string(), "FALSE".to_string(), "INTERVAL".to_string(), "NULL".to_string(), "TIME".to_string(), "TIMESTAMP".to_string(), "TIMESTAMPTZ".to_string(), "TIMETZ".to_string(), "TRUE".to_string(), "VARIADIC".to_string(), "[".to_string(), "{".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_numeric_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "numeric_literal".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string(), "word".to_string()]),
        }),
})
);

// name='DefinitionParameterSegment'
pub static DEFINITION_PARAMETER_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DefinitionParameterSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PropertiesNakedIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["word".to_string()]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DefinitionArgumentValueGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "+".to_string(), "-".to_string(), ":".to_string(), "ARRAY".to_string(), "DATE".to_string(), "FALSE".to_string(), "INTERVAL".to_string(), "NULL".to_string(), "TIME".to_string(), "TIMESTAMP".to_string(), "TIMESTAMPTZ".to_string(), "TIMETZ".to_string(), "TRUE".to_string(), "VARIADIC".to_string(), "[".to_string(), "{".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_numeric_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "numeric_literal".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string(), "word".to_string()]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["word".to_string()]),
        }),
})
);

// name='DefinitionParametersSegment'
pub static DEFINITION_PARAMETERS_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DefinitionParametersSegment
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DefinitionParameterSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["word".to_string()]),
        }),
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["word".to_string()]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='Delay_key_writeKeywordSegment'
pub static DELAY_KEY_WRITE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DELAY_KEY_WRITE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DelayedKeywordSegment'
pub static DELAYED_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DELAYED",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DeleteKeywordSegment'
pub static DELETE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DELETE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DeleteStatementSegment'
pub static DELETE_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DeleteStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DeleteKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DELETE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FromKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OnlyKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ONLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "StarSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["*".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AliasExpressionSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "UsingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TableExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AliasExpressionSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("dedent"))
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "JoinClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WhereKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHERE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CurrentKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OfKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHERE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WhereClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHERE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHERE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ReturningKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RETURNING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "StarSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["*".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AliasExpressionSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("dedent"))
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RETURNING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DELETE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DelimiterGrammar'
pub static DELIMITER_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Ref {
    name: "SemicolonSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([";".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DelimiterKeywordSegment'
pub static DELIMITER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DELIMITER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DelimitersKeywordSegment'
pub static DELIMITERS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DELIMITERS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DenyKeywordSegment'
pub static DENY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DENY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DependenciesKeywordSegment'
pub static DEPENDENCIES_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DEPENDENCIES",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DependsKeywordSegment'
pub static DEPENDS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DEPENDS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DepthKeywordSegment'
pub static DEPTH_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DEPTH",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DescKeywordSegment'
pub static DESC_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DESC",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DescribeKeywordSegment'
pub static DESCRIBE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DESCRIBE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DescribeStatementSegment'
pub static DESCRIBE_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DescribeStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DescribeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DESCRIBE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NakedIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DESCRIBE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DestroyKeywordSegment'
pub static DESTROY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DESTROY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DestructorKeywordSegment'
pub static DESTRUCTOR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DESTRUCTOR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DetachKeywordSegment'
pub static DETACH_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DETACH",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DeterministicKeywordSegment'
pub static DETERMINISTIC_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DETERMINISTIC",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DictionaryKeywordSegment'
pub static DICTIONARY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DICTIONARY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DisableKeywordSegment'
pub static DISABLE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DISABLE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Disable_page_skippingKeywordSegment'
pub static DISABLE_PAGE_SKIPPING_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DISABLE_PAGE_SKIPPING",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DiscardKeywordSegment'
pub static DISCARD_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DISCARD",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DiscardStatementSegment'
pub static DISCARD_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DiscardStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DiscardKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DISCARD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AllKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PlansKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PLANS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SequencesKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SEQUENCES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TemporaryKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TEMPORARY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TempKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TEMP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string(), "PLANS".to_string(), "SEQUENCES".to_string(), "TEMP".to_string(), "TEMPORARY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DISCARD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DiskKeywordSegment'
pub static DISK_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DISK",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DistinctKeywordSegment'
pub static DISTINCT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DISTINCT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DistinctrowKeywordSegment'
pub static DISTINCTROW_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DISTINCTROW",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DistributedKeywordSegment'
pub static DISTRIBUTED_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DISTRIBUTED",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DivKeywordSegment'
pub static DIV_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DIV",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DivideSegment'
pub static DIVIDE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::StringParser {
    template: "//",
    token_type: "binary_operator",
    raw_class: "BinaryOperatorSegment",
    optional: false,
})
,
Arc::new(Grammar::StringParser {
    template: "/",
    token_type: "binary_operator",
    raw_class: "BinaryOperatorSegment",
    optional: false,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["/".to_string(), "//".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DoKeywordSegment'
pub static DO_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DO",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DoStatementSegment'
pub static DO_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DoStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DoKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LanguageClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LANGUAGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LANGUAGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LanguageClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LANGUAGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LANGUAGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DocumentKeywordSegment'
pub static DOCUMENT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DOCUMENT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DollarNumericLiteralSegment'
pub static DOLLAR_NUMERIC_LITERAL_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::TypedParser {
    template: "dollar_numeric_literal",
    token_type: "dollar_numeric_literal",
    raw_class: "LiteralSegment",
    optional: false,
})
);

// name='DomainKeywordSegment'
pub static DOMAIN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DOMAIN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DotSegment'
pub static DOT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: ".",
    token_type: "dot",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='DoubleKeywordSegment'
pub static DOUBLE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DOUBLE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DropAggregateStatementSegment'
pub static DROP_AGGREGATE_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DropAggregateStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AggregateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AGGREGATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FunctionParameterListGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Anything)
,
Arc::new(Grammar::Ref {
    name: "StarSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["*".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DropBehaviorGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string(), "RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DropBehaviorGrammar'
pub static DROP_BEHAVIOR_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RestrictKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CascadeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string(), "RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DropCastStatementSegment'
pub static DROP_CAST_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DropCastStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CastKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CAST".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DatatypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DatatypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DropBehaviorGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string(), "RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DropCollationStatementSegment'
pub static DROP_COLLATION_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DropCollationStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CollationKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLLATION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DropBehaviorGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string(), "RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DropDatabaseStatementSegment'
pub static DROP_DATABASE_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DropDatabaseStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DatabaseKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATABASE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DatabaseReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ForceKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FORCE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DropDomainStatementSegment'
pub static DROP_DOMAIN_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DropDomainStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DomainKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DOMAIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DropBehaviorGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string(), "RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DropExtensionStatementSegment'
pub static DROP_EXTENSION_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DropExtensionStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExtensionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXTENSION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExtensionReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DropBehaviorGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string(), "RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DropForeignTableStatement'
pub static DROP_FOREIGN_TABLE_STATEMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DropForeignTableStatement
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ForeignKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOREIGN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "CascadeRestrictGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string(), "RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DropFunctionStatementSegment'
pub static DROP_FUNCTION_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DropFunctionStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "MacroKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MACRO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FUNCTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FUNCTION".to_string(), "MACRO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DropBehaviorGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string(), "RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DropIndexStatementSegment'
pub static DROP_INDEX_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DropIndexStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IndexKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INDEX".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConcurrentlyKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONCURRENTLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IndexReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DropBehaviorGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string(), "RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DropKeywordSegment'
pub static DROP_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DROP",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DropMaterializedViewStatementSegment'
pub static DROP_MATERIALIZED_VIEW_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DropMaterializedViewStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MaterializedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MATERIALIZED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ViewKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VIEW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DropBehaviorGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string(), "RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DropModelStatementSegment'
pub static DROP_MODEL_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DropModelStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ModelKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MODEL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DropOwnedStatementSegment'
pub static DROP_OWNED_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DropOwnedStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OwnedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OWNED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "Current_roleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_ROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Current_userKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Session_userKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SESSION_USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RoleReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DropBehaviorGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string(), "RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DropPolicyStatementSegment'
pub static DROP_POLICY_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DropPolicyStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PolicyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["POLICY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DropBehaviorGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string(), "RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DropProcedureStatementSegment'
pub static DROP_PROCEDURE_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DropProcedureStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ProcedureKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PROCEDURE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FunctionNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "FunctionParameterListGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CascadeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RestrictKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string(), "RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DropPublicationStatementSegment'
pub static DROP_PUBLICATION_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DropPublicationStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PublicationKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PUBLICATION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PublicationReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DropBehaviorGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string(), "RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DropRoleStatementSegment'
pub static DROP_ROLE_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DropRoleStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RoleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DropSchemaStatementSegment'
pub static DROP_SCHEMA_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DropSchemaStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DropBehaviorGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string(), "RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DropSequenceStatementSegment'
pub static DROP_SEQUENCE_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DropSequenceStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SequenceKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SEQUENCE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SequenceReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DropBehaviorGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string(), "RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DropStatisticsStatementSegment'
pub static DROP_STATISTICS_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DropStatisticsStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StatisticsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STATISTICS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "StatisticsReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CascadeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RestrictKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string(), "RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DropSubscriptionStatementSegment'
pub static DROP_SUBSCRIPTION_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DropSubscriptionStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SubscriptionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SUBSCRIPTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SubscriptionReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CascadeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RestrictKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string(), "RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DropTableStatementSegment'
pub static DROP_TABLE_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DropTableStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TemporaryGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TEMP".to_string(), "TEMPORARY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DropBehaviorGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string(), "RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DropTextSearchConfigurationStatementSegment'
pub static DROP_TEXT_SEARCH_CONFIGURATION_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DropTextSearchConfigurationStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TextKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TEXT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SearchKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SEARCH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConfigurationKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONFIGURATION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DropBehaviorGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string(), "RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DropTriggerStatementSegment'
pub static DROP_TRIGGER_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DropTriggerStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TriggerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TRIGGER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TriggerReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DropBehaviorGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string(), "RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DropTypeStatementSegment'
pub static DROP_TYPE_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DropTypeStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TypeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TYPE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DatatypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DropBehaviorGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string(), "RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DropUserStatementSegment'
pub static DROP_USER_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DropUserStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UserKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RoleReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DropViewStatementSegment'
pub static DROP_VIEW_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// DropViewStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DropKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ViewKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VIEW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DropBehaviorGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string(), "RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='DummyKeywordSegment'
pub static DUMMY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DUMMY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='DumpKeywordSegment'
pub static DUMP_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "DUMP",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='EachKeywordSegment'
pub static EACH_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "EACH",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ElseClauseSegment'
pub static ELSE_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ElseClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ElseKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ELSE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("dedent"))
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ELSE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ElseKeywordSegment'
pub static ELSE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ELSE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ElseifKeywordSegment'
pub static ELSEIF_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ELSEIF",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='EmptyKeywordSegment'
pub static EMPTY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "EMPTY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='EmptyStructLiteralBracketsSegment'
pub static EMPTY_STRUCT_LITERAL_BRACKETS_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// EmptyStructLiteralBracketsSegment
Arc::new(Grammar::Bracketed {
    elements: vec![
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='EmptyStructLiteralSegment'
pub static EMPTY_STRUCT_LITERAL_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// EmptyStructLiteralSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "StructTypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STRUCT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EmptyStructLiteralBracketsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STRUCT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='EnableKeywordSegment'
pub static ENABLE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ENABLE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='EnclosedKeywordSegment'
pub static ENCLOSED_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ENCLOSED",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='EncodingKeywordSegment'
pub static ENCODING_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ENCODING",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='EncryptedKeywordSegment'
pub static ENCRYPTED_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ENCRYPTED",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='EndBracketSegment'
pub static END_BRACKET_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='EndCurlyBracketSegment'
pub static END_CURLY_BRACKET_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "}",
    token_type: "end_curly_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='EndKeywordSegment'
pub static END_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "END",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='EndSquareBracketSegment'
pub static END_SQUARE_BRACKET_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "]",
    token_type: "end_square_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='EnumKeywordSegment'
pub static ENUM_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ENUM",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='EqualsSegment'
pub static EQUALS_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// EqualsSegment
Arc::new(Grammar::Ref {
    name: "RawEqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='EqualsSegment_a'
pub static EQUALS_SEGMENT_A: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "==",
    token_type: "comparison_operator",
    raw_class: "ComparisonOperatorSegment",
    optional: false,
})
);

// name='ErrlvlKeywordSegment'
pub static ERRLVL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ERRLVL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='EscapeKeywordSegment'
pub static ESCAPE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ESCAPE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='EscapedKeywordSegment'
pub static ESCAPED_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ESCAPED",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='EventKeywordSegment'
pub static EVENT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "EVENT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ExceptKeywordSegment'
pub static EXCEPT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "EXCEPT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ExcludeKeywordSegment'
pub static EXCLUDE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "EXCLUDE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ExcludingKeywordSegment'
pub static EXCLUDING_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "EXCLUDING",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ExclusionConstraintElementSegment'
pub static EXCLUSION_CONSTRAINT_ELEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ExclusionConstraintElementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IndexElementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ComparisonOperatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["!".to_string(), "<".to_string(), "=".to_string(), "==".to_string(), ">".to_string(), "IS".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["glob_operator".to_string(), "like_operator".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='ExclusiveKeywordSegment'
pub static EXCLUSIVE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "EXCLUSIVE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ExecuteKeywordSegment'
pub static EXECUTE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "EXECUTE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ExecuteStatementSegment'
pub static EXECUTE_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ExecuteStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExecuteKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXECUTE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXECUTE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ExistingKeywordSegment'
pub static EXISTING_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "EXISTING",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ExistsKeywordSegment'
pub static EXISTS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "EXISTS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ExitKeywordSegment'
pub static EXIT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "EXIT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ExplainKeywordSegment'
pub static EXPLAIN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "EXPLAIN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ExplainOptionSegment'
pub static EXPLAIN_OPTION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ExplainOptionSegment
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AnalyzeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ANALYZE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AnalyseKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ANALYSE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "VerboseKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VERBOSE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CostsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COSTS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SettingsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SETTINGS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BuffersKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BUFFERS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WalKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TimingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TIMING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SummaryKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SUMMARY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ANALYSE".to_string(), "ANALYZE".to_string(), "BUFFERS".to_string(), "COSTS".to_string(), "SETTINGS".to_string(), "SUMMARY".to_string(), "TIMING".to_string(), "VERBOSE".to_string(), "WAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BooleanLiteralGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FALSE".to_string(), "TRUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ANALYSE".to_string(), "ANALYZE".to_string(), "BUFFERS".to_string(), "COSTS".to_string(), "SETTINGS".to_string(), "SUMMARY".to_string(), "TIMING".to_string(), "VERBOSE".to_string(), "WAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FormatKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FORMAT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TextKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TEXT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "XmlKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["XML".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "JsonKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["JSON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "YamlKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["YAML".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["JSON".to_string(), "TEXT".to_string(), "XML".to_string(), "YAML".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FORMAT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ANALYSE".to_string(), "ANALYZE".to_string(), "BUFFERS".to_string(), "COSTS".to_string(), "FORMAT".to_string(), "SETTINGS".to_string(), "SUMMARY".to_string(), "TIMING".to_string(), "VERBOSE".to_string(), "WAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ExplainStatementSegment'
pub static EXPLAIN_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ExplainStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExplainKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXPLAIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AnalyzeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ANALYZE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AnalyseKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ANALYSE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ANALYSE".to_string(), "ANALYZE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "VerboseKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VERBOSE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ANALYSE".to_string(), "ANALYZE".to_string(), "VERBOSE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExplainOptionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ANALYSE".to_string(), "ANALYZE".to_string(), "BUFFERS".to_string(), "COSTS".to_string(), "FORMAT".to_string(), "SETTINGS".to_string(), "SUMMARY".to_string(), "TIMING".to_string(), "VERBOSE".to_string(), "WAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ANALYSE".to_string(), "ANALYZE".to_string(), "BUFFERS".to_string(), "COSTS".to_string(), "FORMAT".to_string(), "SETTINGS".to_string(), "SUMMARY".to_string(), "TIMING".to_string(), "VERBOSE".to_string(), "WAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "ANALYSE".to_string(), "ANALYZE".to_string(), "VERBOSE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SelectableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "DELETE".to_string(), "FROM".to_string(), "INSERT".to_string(), "PIVOT".to_string(), "PIVOT_LONGER".to_string(), "PIVOT_WIDER".to_string(), "SELECT".to_string(), "UNPIVOT".to_string(), "UPDATE".to_string(), "VALUES".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "InsertStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INSERT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UpdateStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UPDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DeleteStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DELETE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "DELETE".to_string(), "FROM".to_string(), "INSERT".to_string(), "PIVOT".to_string(), "PIVOT_LONGER".to_string(), "PIVOT_WIDER".to_string(), "SELECT".to_string(), "UNPIVOT".to_string(), "UPDATE".to_string(), "VALUES".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXPLAIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ExpressionKeywordSegment'
pub static EXPRESSION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "EXPRESSION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ExpressionSegment'
pub static EXPRESSION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ExpressionSegment
Arc::new(Grammar::Ref {
    name: "Expression_A_Grammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
);

// name='Expression_A_Grammar'
pub static EXPRESSION_A_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "Tail_Recurse_Expression_A_Grammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LikeExpressionGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GLOB".to_string(), "ILIKE".to_string(), "LIKE".to_string(), "NOT".to_string(), "SIMILAR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "BinaryOperatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["!".to_string(), "%".to_string(), "&".to_string(), "*".to_string(), "+".to_string(), "-".to_string(), "/".to_string(), "//".to_string(), "<".to_string(), "=".to_string(), "==".to_string(), ">".to_string(), "AND".to_string(), "COLLATE".to_string(), "IS".to_string(), "OR".to_string(), "^".to_string(), "|".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["glob_operator".to_string(), "json_operator".to_string(), "like_operator".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Tail_Recurse_Expression_A_Grammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["!".to_string(), "%".to_string(), "&".to_string(), "*".to_string(), "+".to_string(), "-".to_string(), "/".to_string(), "//".to_string(), "<".to_string(), "=".to_string(), "==".to_string(), ">".to_string(), "AND".to_string(), "COLLATE".to_string(), "IS".to_string(), "OR".to_string(), "^".to_string(), "|".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["glob_operator".to_string(), "json_operator".to_string(), "like_operator".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "InOperatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IN".to_string(), "NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NotKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IsClauseGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FALSE".to_string(), "JSON".to_string(), "NAN".to_string(), "NFC".to_string(), "NFD".to_string(), "NFKC".to_string(), "NFKD".to_string(), "NORMALIZED".to_string(), "NULL".to_string(), "TRUE".to_string(), "UNKNOWN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IsNullGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ISNULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NotNullGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOTNULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CollateGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NotKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BetweenKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BETWEEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Expression_B_Grammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AndKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AND".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Tail_Recurse_Expression_A_Grammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BETWEEN".to_string(), "NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PatternMatchingGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "Expression_A_Grammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='Expression_A_Unary_Operator_Grammar'
pub static EXPRESSION_A_UNARY_OPERATOR_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SignedSegmentGrammar",
    optional: false,
    allow_gaps: true,
    exclude: Some(Box::new(
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "QualifiedNumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["+".to_string(), "-".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["+".to_string(), "-".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    )),
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["+".to_string(), "-".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TildeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["~".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NotOperatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PriorKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PRIOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["+".to_string(), "-".to_string(), "NOT".to_string(), "PRIOR".to_string(), "~".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='Expression_B_Grammar'
pub static EXPRESSION_B_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "Tail_Recurse_Expression_B_Grammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ArithmeticBinaryOperatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["%".to_string(), "&".to_string(), "*".to_string(), "+".to_string(), "-".to_string(), "/".to_string(), "//".to_string(), "<".to_string(), ">".to_string(), "^".to_string(), "|".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StringBinaryOperatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLLATE".to_string(), "|".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ComparisonOperatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["!".to_string(), "<".to_string(), "=".to_string(), "==".to_string(), ">".to_string(), "IS".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["glob_operator".to_string(), "like_operator".to_string()]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["!".to_string(), "%".to_string(), "&".to_string(), "*".to_string(), "+".to_string(), "-".to_string(), "/".to_string(), "//".to_string(), "<".to_string(), "=".to_string(), "==".to_string(), ">".to_string(), "COLLATE".to_string(), "IS".to_string(), "^".to_string(), "|".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["glob_operator".to_string(), "like_operator".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Tail_Recurse_Expression_B_Grammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["!".to_string(), "%".to_string(), "&".to_string(), "*".to_string(), "+".to_string(), "-".to_string(), "/".to_string(), "//".to_string(), "<".to_string(), "=".to_string(), "==".to_string(), ">".to_string(), "COLLATE".to_string(), "IS".to_string(), "^".to_string(), "|".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["glob_operator".to_string(), "like_operator".to_string()]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["!".to_string(), "%".to_string(), "&".to_string(), "*".to_string(), "+".to_string(), "-".to_string(), "/".to_string(), "//".to_string(), "<".to_string(), "=".to_string(), "==".to_string(), ">".to_string(), "COLLATE".to_string(), "IS".to_string(), "^".to_string(), "|".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["glob_operator".to_string(), "like_operator".to_string()]),
        }),
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["!".to_string(), "%".to_string(), "&".to_string(), "*".to_string(), "+".to_string(), "-".to_string(), "/".to_string(), "//".to_string(), "<".to_string(), "=".to_string(), "==".to_string(), ">".to_string(), "COLLATE".to_string(), "IS".to_string(), "^".to_string(), "|".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["glob_operator".to_string(), "like_operator".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='Expression_B_Unary_Operator_Grammar'
pub static EXPRESSION_B_UNARY_OPERATOR_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SignedSegmentGrammar",
    optional: false,
    allow_gaps: true,
    exclude: Some(Box::new(
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "QualifiedNumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["+".to_string(), "-".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["+".to_string(), "-".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    )),
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["+".to_string(), "-".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TildeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["~".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["+".to_string(), "-".to_string(), "~".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='Expression_C_Grammar'
pub static EXPRESSION_C_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WalrusOperatorSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([":=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExistsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXISTS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SelectableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "DELETE".to_string(), "FROM".to_string(), "INSERT".to_string(), "PIVOT".to_string(), "PIVOT_LONGER".to_string(), "PIVOT_WIDER".to_string(), "SELECT".to_string(), "UNPIVOT".to_string(), "UPDATE".to_string(), "VALUES".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXISTS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "Expression_D_Grammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "CaseExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TimeZoneGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ShorthandCastSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FullTextSearchOperatorSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["full_text_search_operator".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ShorthandCastSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='Expression_D_Grammar'
pub static EXPRESSION_D_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "BareFunctionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_CATALOG".to_string(), "CURRENT_DATE".to_string(), "CURRENT_ROLE".to_string(), "CURRENT_SCHEMA".to_string(), "CURRENT_TIME".to_string(), "CURRENT_TIMESTAMP".to_string(), "CURRENT_USER".to_string(), "LOCALTIME".to_string(), "LOCALTIMESTAMP".to_string(), "SESSION_USER".to_string(), "SYSTEM_USER".to_string(), "USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "SelectableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "DELETE".to_string(), "FROM".to_string(), "INSERT".to_string(), "PIVOT".to_string(), "PIVOT_LONGER".to_string(), "PIVOT_WIDER".to_string(), "SELECT".to_string(), "UNPIVOT".to_string(), "UPDATE".to_string(), "VALUES".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "+".to_string(), "-".to_string(), ":".to_string(), "ARRAY".to_string(), "DATE".to_string(), "FALSE".to_string(), "INTERVAL".to_string(), "NULL".to_string(), "TIME".to_string(), "TIMESTAMP".to_string(), "TIMESTAMPTZ".to_string(), "TIMETZ".to_string(), "TRUE".to_string(), "VARIADIC".to_string(), "[".to_string(), "{".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_numeric_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "numeric_literal".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "FunctionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "LocalAliasSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Greedy,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Expression_D_Potential_Select_Statement_Without_Brackets",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceDelimiterGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StarSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["*".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "StructTypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STRUCT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MapTypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MAP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MAP".to_string(), "STRUCT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MAP".to_string(), "STRUCT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DatatypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BooleanLiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FALSE".to_string(), "TRUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NullLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DateTimeLiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATE".to_string(), "INTERVAL".to_string(), "TIME".to_string(), "TIMESTAMP".to_string(), "TIMESTAMPTZ".to_string(), "TIMETZ".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATE".to_string(), "FALSE".to_string(), "INTERVAL".to_string(), "NULL".to_string(), "TIME".to_string(), "TIMESTAMP".to_string(), "TIMESTAMPTZ".to_string(), "TIMETZ".to_string(), "TRUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "numeric_literal".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "LocalAliasSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ListComprehensionGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["[".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AccessorGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string(), "[".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='Expression_D_Potential_Select_Statement_Without_Brackets'
pub static EXPRESSION_D_POTENTIAL_SELECT_STATEMENT_WITHOUT_BRACKETS: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SelectStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SELECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "+".to_string(), "-".to_string(), ":".to_string(), "ARRAY".to_string(), "DATE".to_string(), "FALSE".to_string(), "INTERVAL".to_string(), "NULL".to_string(), "TIME".to_string(), "TIMESTAMP".to_string(), "TIMESTAMPTZ".to_string(), "TIMETZ".to_string(), "TRUE".to_string(), "VARIADIC".to_string(), "[".to_string(), "{".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_numeric_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "numeric_literal".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IntervalExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INTERVAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TypedStructLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STRUCT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ArrayExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "OverlapsClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='ExtendedKeywordSegment'
pub static EXTENDED_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "EXTENDED",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ExtendedNaturalJoinKeywordsGrammar'
pub static EXTENDED_NATURAL_JOIN_KEYWORDS_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Nothing())
);

// name='ExtendedTableReferenceGrammar'
pub static EXTENDED_TABLE_REFERENCE_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OnlyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ONLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ONLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "StarSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["*".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='ExtensionKeywordSegment'
pub static EXTENSION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "EXTENSION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ExtensionReferenceSegment'
pub static EXTENSION_REFERENCE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ExtensionReferenceSegment
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "ObjectReferenceDelimiterGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "ObjectReferenceTerminatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["!".to_string(), "%".to_string(), "&".to_string(), "(".to_string(), "*".to_string(), "+".to_string(), ",".to_string(), "-".to_string(), "/".to_string(), "//".to_string(), ":".to_string(), "::".to_string(), ";".to_string(), "<".to_string(), "=".to_string(), "==".to_string(), ">".to_string(), "AND".to_string(), "AS".to_string(), "COLLATE".to_string(), "IS".to_string(), "ON".to_string(), "OR".to_string(), "PIVOT".to_string(), "UNPIVOT".to_string(), "USING".to_string(), "[".to_string(), "^".to_string(), "|".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["glob_operator".to_string(), "json_operator".to_string(), "like_operator".to_string()]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: false,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='ExternalKeywordSegment'
pub static EXTERNAL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "EXTERNAL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ExtractKeywordSegment'
pub static EXTRACT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "EXTRACT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='FalseKeywordSegment'
pub static FALSE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FALSE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='FalseSegment'
pub static FALSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FALSE",
    token_type: "boolean_literal",
    raw_class: "LiteralKeywordSegment",
    optional: false,
})
);

// name='FamilyKeywordSegment'
pub static FAMILY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FAMILY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='FetchClauseSegment'
pub static FETCH_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// FetchClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FetchKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FETCH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FirstKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FIRST".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NextKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NEXT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FIRST".to_string(), "NEXT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: Some(Box::new(
Arc::new(Grammar::Ref {
    name: "RowKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    )),
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RowKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RowsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROWS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROW".to_string(), "ROWS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OnlyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ONLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TiesKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TIES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ONLY".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FETCH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='FetchKeywordSegment'
pub static FETCH_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FETCH",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='FieldsKeywordSegment'
pub static FIELDS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FIELDS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='FileKeywordSegment'
pub static FILE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FILE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='FileSegment'
pub static FILE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// FileSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DelimiterGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([";".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([";".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "StatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DelimiterGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([";".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 1,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([";".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: true,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DelimiterGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([";".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([";".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='FillfactorKeywordSegment'
pub static FILLFACTOR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FILLFACTOR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='FilterClauseGrammar'
pub static FILTER_CLAUSE_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FilterKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FILTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WhereKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHERE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHERE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FILTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='FilterKeywordSegment'
pub static FILTER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FILTER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='FinalizeKeywordSegment'
pub static FINALIZE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FINALIZE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='FirstKeywordSegment'
pub static FIRST_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FIRST",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Float4KeywordSegment'
pub static FLOAT4_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FLOAT4",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Float8KeywordSegment'
pub static FLOAT8_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FLOAT8",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='FloatKeywordSegment'
pub static FLOAT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FLOAT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='FlushKeywordSegment'
pub static FLUSH_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FLUSH",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='FollowingKeywordSegment'
pub static FOLLOWING_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FOLLOWING",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ForClauseSegment'
pub static FOR_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ForClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ForKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "UpdateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UPDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NoKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "KeyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["KEY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UpdateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UPDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ShareKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SHARE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "KeyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["KEY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ShareKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SHARE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["KEY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["KEY".to_string(), "NO".to_string(), "SHARE".to_string(), "UPDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OfKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NowaitKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOWAIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SkipKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SKIP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LockedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LOCKED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SKIP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOWAIT".to_string(), "SKIP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ForKeywordSegment'
pub static FOR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FOR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ForceKeywordSegment'
pub static FORCE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FORCE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Force_not_nullKeywordSegment'
pub static FORCE_NOT_NULL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FORCE_NOT_NULL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Force_nullKeywordSegment'
pub static FORCE_NULL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FORCE_NULL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Force_quoteKeywordSegment'
pub static FORCE_QUOTE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FORCE_QUOTE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ForeignDataWrapperGrammar'
pub static FOREIGN_DATA_WRAPPER_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ForeignKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOREIGN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DataKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WrapperKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WRAPPER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOREIGN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ForeignKeyGrammar'
pub static FOREIGN_KEY_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ForeignKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOREIGN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "KeyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["KEY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOREIGN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ForeignKeywordSegment'
pub static FOREIGN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FOREIGN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ForeignTableColumnConstraintSegment'
pub static FOREIGN_TABLE_COLUMN_CONSTRAINT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ForeignTableColumnConstraintSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ConstraintKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRAINT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRAINT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NotKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NullKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOT".to_string(), "NULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CheckKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHECK".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NoKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "InheritKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INHERIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHECK".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DefaultKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ShorthandCastSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "LiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "+".to_string(), "-".to_string(), ":".to_string(), "ARRAY".to_string(), "DATE".to_string(), "FALSE".to_string(), "INTERVAL".to_string(), "NULL".to_string(), "TIME".to_string(), "TIMESTAMP".to_string(), "TIMESTAMPTZ".to_string(), "TIMETZ".to_string(), "TRUE".to_string(), "VARIADIC".to_string(), "[".to_string(), "{".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_numeric_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "numeric_literal".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "BareFunctionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_CATALOG".to_string(), "CURRENT_DATE".to_string(), "CURRENT_ROLE".to_string(), "CURRENT_SCHEMA".to_string(), "CURRENT_TIME".to_string(), "CURRENT_TIMESTAMP".to_string(), "CURRENT_USER".to_string(), "LOCALTIME".to_string(), "LOCALTIMESTAMP".to_string(), "SESSION_USER".to_string(), "SYSTEM_USER".to_string(), "USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "GeneratedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GENERATED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AlwaysKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALWAYS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "StoredKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STORED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GENERATED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHECK".to_string(), "DEFAULT".to_string(), "GENERATED".to_string(), "NOT".to_string(), "NULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHECK".to_string(), "CONSTRAINT".to_string(), "DEFAULT".to_string(), "GENERATED".to_string(), "NOT".to_string(), "NULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ForeignTableTableConstraintSegment'
pub static FOREIGN_TABLE_TABLE_CONSTRAINT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ForeignTableTableConstraintSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ConstraintKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRAINT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRAINT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CheckKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHECK".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NoKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "InheritKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INHERIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHECK".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHECK".to_string(), "CONSTRAINT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='FormatKeywordSegment'
pub static FORMAT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FORMAT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ForwardKeywordSegment'
pub static FORWARD_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FORWARD",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='FrameClauseSegment'
pub static FRAME_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// FrameClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FrameClauseUnitGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUPS".to_string(), "RANGE".to_string(), "ROWS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CurrentKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RowKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IntervalExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INTERVAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UnboundedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UNBOUNDED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PrecedingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PRECEDING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FollowingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOLLOWING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOLLOWING".to_string(), "PRECEDING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "BetweenKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BETWEEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CurrentKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RowKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IntervalExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INTERVAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UnboundedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UNBOUNDED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PrecedingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PRECEDING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FollowingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOLLOWING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOLLOWING".to_string(), "PRECEDING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AndKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AND".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CurrentKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RowKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IntervalExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INTERVAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UnboundedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UNBOUNDED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PrecedingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PRECEDING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FollowingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOLLOWING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOLLOWING".to_string(), "PRECEDING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BETWEEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExcludeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCLUDE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CurrentKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RowKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "GroupKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TiesKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TIES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NoKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OthersKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OTHERS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT".to_string(), "GROUP".to_string(), "NO".to_string(), "TIES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCLUDE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUPS".to_string(), "RANGE".to_string(), "ROWS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='FrameClauseUnitGrammar'
pub static FRAME_CLAUSE_UNIT_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RangeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RANGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RowsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROWS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "GroupsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUPS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUPS".to_string(), "RANGE".to_string(), "ROWS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='FreetextKeywordSegment'
pub static FREETEXT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FREETEXT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='FreetexttableKeywordSegment'
pub static FREETEXTTABLE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FREETEXTTABLE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='FreezeKeywordSegment'
pub static FREEZE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FREEZE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='FromClauseSegment'
pub static FROM_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// FromClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FromKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FromExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='FromClauseTerminatorGrammar'
pub static FROM_CLAUSE_TERMINATOR_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WhereKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHERE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LimitClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LIMIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "GroupKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OrderKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "HavingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["HAVING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QualifyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["QUALIFY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WindowKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WINDOW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SetOperatorSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCEPT".to_string(), "INTERSECT".to_string(), "MINUS".to_string(), "UNION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WithNoSchemaBindingClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WithDataClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FetchKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FETCH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OffsetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OFFSET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ForClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCEPT".to_string(), "FETCH".to_string(), "FOR".to_string(), "GROUP".to_string(), "HAVING".to_string(), "INTERSECT".to_string(), "LIMIT".to_string(), "MINUS".to_string(), "OFFSET".to_string(), "ORDER".to_string(), "QUALIFY".to_string(), "UNION".to_string(), "WHERE".to_string(), "WINDOW".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='FromExpressionElementSegment'
pub static FROM_EXPRESSION_ELEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// FromExpressionElementSegment
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PreTableFunctionKeywordsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LATERAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TableExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "TemporalQuerySegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AliasExpressionSegment",
    optional: true,
    allow_gaps: true,
    exclude: Some(Box::new(
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FromClauseTerminatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCEPT".to_string(), "FETCH".to_string(), "FOR".to_string(), "GROUP".to_string(), "HAVING".to_string(), "INTERSECT".to_string(), "LIMIT".to_string(), "MINUS".to_string(), "OFFSET".to_string(), "ORDER".to_string(), "QUALIFY".to_string(), "UNION".to_string(), "WHERE".to_string(), "WINDOW".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SamplingExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLESAMPLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "JoinLikeClauseGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PIVOT".to_string(), "UNPIVOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "JoinClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
    )),
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OffsetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OFFSET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AliasExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SamplingExpressionSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLESAMPLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PostTableExpressionGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PreTableFunctionKeywordsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LATERAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TableExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "TemporalQuerySegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AliasExpressionSegment",
    optional: true,
    allow_gaps: true,
    exclude: Some(Box::new(
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FromClauseTerminatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCEPT".to_string(), "FETCH".to_string(), "FOR".to_string(), "GROUP".to_string(), "HAVING".to_string(), "INTERSECT".to_string(), "LIMIT".to_string(), "MINUS".to_string(), "OFFSET".to_string(), "ORDER".to_string(), "QUALIFY".to_string(), "UNION".to_string(), "WHERE".to_string(), "WINDOW".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SamplingExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLESAMPLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "JoinLikeClauseGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PIVOT".to_string(), "UNPIVOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "JoinClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
    )),
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OffsetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OFFSET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AliasExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SamplingExpressionSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLESAMPLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PostTableExpressionGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "JoinClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='FromExpressionSegment'
pub static FROM_EXPRESSION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// FromExpressionSegment
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "MLTableExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ML".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FromExpressionElementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FromExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OrderKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "GroupKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("dedent"))
,
Arc::new(Grammar::Meta("conditional"))
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "JoinClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "JoinLikeClauseGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PIVOT".to_string(), "UNPIVOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OrderKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "GroupKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("conditional"))
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "MLTableExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ML".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FromExpressionElementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FromExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OrderKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "GroupKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("dedent"))
,
Arc::new(Grammar::Meta("conditional"))
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "JoinClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "JoinLikeClauseGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PIVOT".to_string(), "UNPIVOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OrderKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "GroupKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("conditional"))
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='FromKeywordSegment'
pub static FROM_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FROM",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='FromPivotExpressionSegment'
pub static FROM_PIVOT_EXPRESSION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// FromPivotExpressionSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PivotKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PIVOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FunctionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AliasExpressionSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ForKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "InKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "+".to_string(), "-".to_string(), ":".to_string(), "ARRAY".to_string(), "DATE".to_string(), "FALSE".to_string(), "INTERVAL".to_string(), "NULL".to_string(), "TIME".to_string(), "TIMESTAMP".to_string(), "TIMESTAMPTZ".to_string(), "TIMETZ".to_string(), "TRUE".to_string(), "VARIADIC".to_string(), "[".to_string(), "{".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_numeric_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "numeric_literal".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "+".to_string(), "-".to_string(), ":".to_string(), "ARRAY".to_string(), "DATE".to_string(), "FALSE".to_string(), "INTERVAL".to_string(), "NULL".to_string(), "TIME".to_string(), "TIMESTAMP".to_string(), "TIMESTAMPTZ".to_string(), "TIMETZ".to_string(), "TRUE".to_string(), "VARIADIC".to_string(), "[".to_string(), "{".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_numeric_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "numeric_literal".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "GroupByClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OrderByClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LimitClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LIMIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: true,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PIVOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='FromUnpivotExpressionSegment'
pub static FROM_UNPIVOT_EXPRESSION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// FromUnpivotExpressionSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "UnpivotKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UNPIVOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IncludeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INCLUDE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NullsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NULLS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INCLUDE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ForKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "InKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AliasExpressionSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ColumnsExpressionGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLUMNS".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["star".to_string()]),
        }),
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    min_times: 1,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UNPIVOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='FullKeywordSegment'
pub static FULL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FULL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='FullTextSearchOperatorSegment'
pub static FULL_TEXT_SEARCH_OPERATOR_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::TypedParser {
    template: "full_text_search_operator",
    token_type: "full_text_search_operator",
    raw_class: "LiteralSegment",
    optional: false,
})
);

// name='FulltextKeywordSegment'
pub static FULLTEXT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FULLTEXT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='FunctionContentsExpressionGrammar'
pub static FUNCTION_CONTENTS_EXPRESSION_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LambdaExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "NamedArgumentSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='FunctionContentsGrammar'
pub static FUNCTION_CONTENTS_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "FROM".to_string(), "PIVOT".to_string(), "PIVOT_LONGER".to_string(), "PIVOT_WIDER".to_string(), "SELECT".to_string(), "UNPIVOT".to_string(), "VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SetExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "FROM".to_string(), "PIVOT".to_string(), "PIVOT_LONGER".to_string(), "PIVOT_WIDER".to_string(), "SELECT".to_string(), "UNPIVOT".to_string(), "VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "FROM".to_string(), "PIVOT".to_string(), "PIVOT_LONGER".to_string(), "PIVOT_WIDER".to_string(), "SELECT".to_string(), "UNPIVOT".to_string(), "VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DatatypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TrimParametersGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BOTH".to_string(), "LEADING".to_string(), "TRAILING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: true,
    allow_gaps: true,
    exclude: Some(Box::new(
Arc::new(Grammar::Ref {
    name: "FromKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    )),
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "FromKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BOTH".to_string(), "LEADING".to_string(), "TRAILING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DatetimeUnitSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CENTURY".to_string(), "DAY".to_string(), "DAYOFYEAR".to_string(), "DECADE".to_string(), "DOW".to_string(), "DOY".to_string(), "EPOCH".to_string(), "HOUR".to_string(), "ISODOW".to_string(), "ISOYEAR".to_string(), "MICROSECONDS".to_string(), "MILLENNIUM".to_string(), "MILLISECOND".to_string(), "MILLISECONDS".to_string(), "MINUTE".to_string(), "MONTH".to_string(), "QUARTER".to_string(), "SECOND".to_string(), "TIMEZONE".to_string(), "TIMEZONE_HOUR".to_string(), "TIMEZONE_MINUTE".to_string(), "WEEK".to_string(), "WEEKDAY".to_string(), "YEAR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::AnySetOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FromKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ForKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 0,
    max_times: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOR".to_string(), "FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DistinctKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DISTINCT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "StarSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["*".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FunctionContentsExpressionGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AggregateOrderByClause",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SeparatorKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SEPARATOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "+".to_string(), "-".to_string(), ":".to_string(), "ARRAY".to_string(), "DATE".to_string(), "FALSE".to_string(), "INTERVAL".to_string(), "NULL".to_string(), "TIME".to_string(), "TIMESTAMP".to_string(), "TIMESTAMPTZ".to_string(), "TIMETZ".to_string(), "TRUE".to_string(), "VARIADIC".to_string(), "[".to_string(), "{".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_numeric_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "numeric_literal".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SEPARATOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "InKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "IgnoreRespectNullsGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IGNORE".to_string(), "RESPECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IndexColumnDefinitionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "EmptyStructLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STRUCT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ValueKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VALUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColonSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([":".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([":".to_string(), "VALUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='FunctionContentsSegment'
pub static FUNCTION_CONTENTS_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// FunctionContentsSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FunctionContentsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='FunctionDefinitionGrammar'
pub static FUNCTION_DEFINITION_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
// FunctionDefinitionGrammar
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LanguageClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LANGUAGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TransformKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TRANSFORM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ForKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TypeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TYPE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TRANSFORM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WindowKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WINDOW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ImmutableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IMMUTABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "VolatileKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VOLATILE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IMMUTABLE".to_string(), "STABLE".to_string(), "VOLATILE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NotKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LeakproofKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LEAKPROOF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LEAKPROOF".to_string(), "NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CalledKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CALLED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NullKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "InputKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INPUT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CALLED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ReturnsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RETURNS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NullKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NullKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "InputKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INPUT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RETURNS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StrictKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CALLED".to_string(), "RETURNS".to_string(), "STRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExternalKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXTERNAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SecurityKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SECURITY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "InvokerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INVOKER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DefinerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFINER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFINER".to_string(), "INVOKER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXTERNAL".to_string(), "SECURITY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ParallelKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PARALLEL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "UnsafeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UNSAFE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RestrictedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESTRICTED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SafeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SAFE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESTRICTED".to_string(), "SAFE".to_string(), "UNSAFE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PARALLEL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CostKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COST".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COST".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RowsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROWS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROWS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SupportKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SUPPORT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SUPPORT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string(), "TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "LiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "+".to_string(), "-".to_string(), ":".to_string(), "ARRAY".to_string(), "DATE".to_string(), "FALSE".to_string(), "INTERVAL".to_string(), "NULL".to_string(), "TIME".to_string(), "TIMESTAMP".to_string(), "TIMESTAMPTZ".to_string(), "TIMETZ".to_string(), "TRUE".to_string(), "VARIADIC".to_string(), "[".to_string(), "{".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_numeric_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "numeric_literal".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string(), "TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FromKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CurrentKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string(), "FROM".to_string(), "TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ReturnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RETURN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RETURN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "BeginKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BEGIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AtomicKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ATOMIC".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "InsertStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INSERT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SemicolonSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([";".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INSERT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "UpdateStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UPDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SemicolonSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([";".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UPDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithCompoundStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SelectStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SELECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SELECT".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SemicolonSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([";".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SELECT".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ReturnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RETURN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "SemicolonSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([";".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RETURN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INSERT".to_string(), "RETURN".to_string(), "SELECT".to_string(), "UPDATE".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EndKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["END".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BEGIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string(), "BEGIN".to_string(), "CALLED".to_string(), "COST".to_string(), "EXTERNAL".to_string(), "IMMUTABLE".to_string(), "LANGUAGE".to_string(), "LEAKPROOF".to_string(), "NOT".to_string(), "PARALLEL".to_string(), "RETURN".to_string(), "RETURNS".to_string(), "ROWS".to_string(), "SECURITY".to_string(), "SET".to_string(), "STABLE".to_string(), "STRICT".to_string(), "SUPPORT".to_string(), "TRANSFORM".to_string(), "VOLATILE".to_string(), "WINDOW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string(), "BEGIN".to_string(), "CALLED".to_string(), "COST".to_string(), "EXTERNAL".to_string(), "IMMUTABLE".to_string(), "LANGUAGE".to_string(), "LEAKPROOF".to_string(), "NOT".to_string(), "PARALLEL".to_string(), "RETURN".to_string(), "RETURNS".to_string(), "ROWS".to_string(), "SECURITY".to_string(), "SET".to_string(), "STABLE".to_string(), "STRICT".to_string(), "SUPPORT".to_string(), "TRANSFORM".to_string(), "VOLATILE".to_string(), "WINDOW".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='FunctionKeywordSegment'
pub static FUNCTION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FUNCTION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='FunctionNameIdentifierSegment'
pub static FUNCTION_NAME_IDENTIFIER_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::RegexParser {
    template: RegexMode::new(r#"[A-Z_][A-Z0-9_$]*"#),
    token_type: "function_name_identifier",
    raw_class: "CodeSegment",
    optional: false,
    anti_template: Some(RegexMode::new(r#"^(STRUCT|UNION|ENUM)$"#)),
})
);

// name='FunctionNameSegment'
pub static FUNCTION_NAME_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// FunctionNameSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DotSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "BracketedSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FunctionNameIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "QuotedIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["double_quote".to_string()]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "BracketedSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: false,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='FunctionParameterGrammar'
pub static FUNCTION_PARAMETER_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "InKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OutKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OUT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "InoutKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INOUT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "VariadicKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VARIADIC".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IN".to_string(), "INOUT".to_string(), "OUT".to_string(), "VARIADIC".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DatatypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "InKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OutKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OUT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "InoutKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INOUT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "VariadicKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VARIADIC".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IN".to_string(), "INOUT".to_string(), "OUT".to_string(), "VARIADIC".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DatatypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ColumnTypeReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DefaultKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WalrusOperatorSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([":=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([":=".to_string(), "=".to_string(), "DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([":=".to_string(), "=".to_string(), "DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='FunctionParameterListGrammar'
pub static FUNCTION_PARAMETER_LIST_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
// FunctionParameterListGrammar
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FunctionParameterGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: true,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='FunctionSegment'
pub static FUNCTION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// FunctionSegment
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DatePartFunctionNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DateTimeFunctionContentsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnsExpressionGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLUMNS".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["star".to_string()]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FunctionNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: Some(Box::new(
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DatePartFunctionNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnsExpressionFunctionNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLUMNS".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["star".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ValuesClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLUMNS".to_string(), "VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["star".to_string()]),
        }),
})
    )),
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "FunctionContentsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "PostFunctionGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='FunctionsKeywordSegment'
pub static FUNCTIONS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FUNCTIONS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='FutureKeywordSegment'
pub static FUTURE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "FUTURE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='GeneratedKeywordSegment'
pub static GENERATED_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "GENERATED",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='GeographyKeywordSegment'
pub static GEOGRAPHY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "GEOGRAPHY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='GeometryKeywordSegment'
pub static GEOMETRY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "GEOMETRY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='GeometrycollectionKeywordSegment'
pub static GEOMETRYCOLLECTION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "GEOMETRYCOLLECTION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='GeometrycollectionmKeywordSegment'
pub static GEOMETRYCOLLECTIONM_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "GEOMETRYCOLLECTIONM",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='GeometrycollectionzKeywordSegment'
pub static GEOMETRYCOLLECTIONZ_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "GEOMETRYCOLLECTIONZ",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='GeometrycollectionzmKeywordSegment'
pub static GEOMETRYCOLLECTIONZM_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "GEOMETRYCOLLECTIONZM",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='GlobKeywordSegment'
pub static GLOB_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "GLOB",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='GlobOperatorSegment'
pub static GLOB_OPERATOR_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::TypedParser {
    template: "glob_operator",
    token_type: "glob_operator",
    raw_class: "ComparisonOperatorSegment",
    optional: false,
})
);

// name='GlobalKeywordSegment'
pub static GLOBAL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "GLOBAL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='GrantKeywordSegment'
pub static GRANT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "GRANT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='GrantedKeywordSegment'
pub static GRANTED_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "GRANTED",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='GrantsKeywordSegment'
pub static GRANTS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "GRANTS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='GreaterThanOrEqualToSegment'
pub static GREATER_THAN_OR_EQUAL_TO_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// GreaterThanOrEqualToSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RawGreaterThanSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([">".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RawEqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: false,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([">".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='GreaterThanSegment'
pub static GREATER_THAN_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// GreaterThanSegment
Arc::new(Grammar::Ref {
    name: "RawGreaterThanSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([">".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='GreatestKeywordSegment'
pub static GREATEST_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "GREATEST",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='GroupByClauseSegment'
pub static GROUP_BY_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// GroupByClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "GroupKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AllKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: true,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "GroupByClauseTerminatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FETCH".to_string(), "HAVING".to_string(), "LIMIT".to_string(), "ORDER".to_string(), "QUALIFY".to_string(), "WINDOW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("dedent"))
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='GroupByClauseTerminatorGrammar'
pub static GROUP_BY_CLAUSE_TERMINATOR_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OrderKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LimitClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LIMIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "HavingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["HAVING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QualifyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["QUALIFY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WindowKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WINDOW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FetchKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FETCH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FETCH".to_string(), "HAVING".to_string(), "LIMIT".to_string(), "ORDER".to_string(), "QUALIFY".to_string(), "WINDOW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='GroupKeywordSegment'
pub static GROUP_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "GROUP",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='GroupingExpressionList'
pub static GROUPING_EXPRESSION_LIST: Lazy<Arc<Grammar>> = Lazy::new(||
// GroupingExpressionList
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "GroupByClauseTerminatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FETCH".to_string(), "HAVING".to_string(), "LIMIT".to_string(), "ORDER".to_string(), "QUALIFY".to_string(), "WINDOW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='GroupingKeywordSegment'
pub static GROUPING_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "GROUPING",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='GroupingSetsClauseSegment'
pub static GROUPING_SETS_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// GroupingSetsClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "GroupingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUPING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SetsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SETS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CubeRollupClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CUBE".to_string(), "ROLLUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "GroupingExpressionList",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUPING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='GroupsKeywordSegment'
pub static GROUPS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "GROUPS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='HandlerKeywordSegment'
pub static HANDLER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "HANDLER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='HashKeywordSegment'
pub static HASH_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "HASH",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='HashesKeywordSegment'
pub static HASHES_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "HASHES",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='HavingClauseSegment'
pub static HAVING_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// HavingClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "HavingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["HAVING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("dedent"))
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["HAVING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='HavingClauseTerminatorGrammar'
pub static HAVING_CLAUSE_TERMINATOR_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OrderKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LimitClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LIMIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QualifyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["QUALIFY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WindowKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WINDOW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FetchKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FETCH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FETCH".to_string(), "LIMIT".to_string(), "ORDER".to_string(), "QUALIFY".to_string(), "WINDOW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='HavingKeywordSegment'
pub static HAVING_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "HAVING",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='HeaderKeywordSegment'
pub static HEADER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "HEADER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='HeapKeywordSegment'
pub static HEAP_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "HEAP",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='High_priorityKeywordSegment'
pub static HIGH_PRIORITY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "HIGH_PRIORITY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='HoldKeywordSegment'
pub static HOLD_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "HOLD",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='HoldlockKeywordSegment'
pub static HOLDLOCK_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "HOLDLOCK",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='HorizontalJoinKeywordsGrammar'
pub static HORIZONTAL_JOIN_KEYWORDS_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Ref {
    name: "PositionalKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["POSITIONAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='HostKeywordSegment'
pub static HOST_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "HOST",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='HostsKeywordSegment'
pub static HOSTS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "HOSTS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='HourKeywordSegment'
pub static HOUR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "HOUR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Hour_microsecondKeywordSegment'
pub static HOUR_MICROSECOND_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "HOUR_MICROSECOND",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Hour_minuteKeywordSegment'
pub static HOUR_MINUTE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "HOUR_MINUTE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Hour_secondKeywordSegment'
pub static HOUR_SECOND_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "HOUR_SECOND",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='IcuKeywordSegment'
pub static ICU_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ICU",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='IdentifiedKeywordSegment'
pub static IDENTIFIED_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "IDENTIFIED",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='IdentifierSegment'
pub static IDENTIFIER_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Token{
    token_type: "identifier",
//    token_type: "IdentifierSegment",
})
);

// name='IdentityKeywordSegment'
pub static IDENTITY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "IDENTITY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Identity_insertKeywordSegment'
pub static IDENTITY_INSERT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "IDENTITY_INSERT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='IdentitycolKeywordSegment'
pub static IDENTITYCOL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "IDENTITYCOL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='IfExistsGrammar'
pub static IF_EXISTS_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IfKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExistsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXISTS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='IfKeywordSegment'
pub static IF_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "IF",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='IfNotExistsGrammar'
pub static IF_NOT_EXISTS_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IfKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NotKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExistsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXISTS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='IgnoreKeywordSegment'
pub static IGNORE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "IGNORE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='IgnoreRespectNullsGrammar'
pub static IGNORE_RESPECT_NULLS_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IgnoreKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IGNORE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RespectKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESPECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IGNORE".to_string(), "RESPECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NullsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NULLS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IGNORE".to_string(), "RESPECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='IlikeKeywordSegment'
pub static ILIKE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ILIKE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ImmediateKeywordSegment'
pub static IMMEDIATE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "IMMEDIATE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ImmutableKeywordSegment'
pub static IMMUTABLE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "IMMUTABLE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ImplicitIndent'
pub static IMPLICIT_INDENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Meta("indent"))
);

// name='ImplicitKeywordSegment'
pub static IMPLICIT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "IMPLICIT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ImportForeignSchemaGrammar'
pub static IMPORT_FOREIGN_SCHEMA_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ImportKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IMPORT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ForeignKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOREIGN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IMPORT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ImportForeignSchemaStatementSegment'
pub static IMPORT_FOREIGN_SCHEMA_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ImportForeignSchemaStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ImportForeignSchemaGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IMPORT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LimitKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LIMIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LIMIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExceptKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCEPT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCEPT".to_string(), "LIMIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NakedIdentifierFullSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["word".to_string()]),
        }),
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["word".to_string()]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCEPT".to_string(), "LIMIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FromKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ServerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SERVER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ServerReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "IntoKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INTO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "OptionsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OPTIONS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IMPORT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ImportKeywordSegment'
pub static IMPORT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "IMPORT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ImportedKeywordSegment'
pub static IMPORTED_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "IMPORTED",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='InKeywordSegment'
pub static IN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "IN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='InOperatorGrammar'
pub static IN_OPERATOR_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NotKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "InKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "Expression_A_Grammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "SelectableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "DELETE".to_string(), "FROM".to_string(), "INSERT".to_string(), "PIVOT".to_string(), "PIVOT_LONGER".to_string(), "PIVOT_WIDER".to_string(), "SELECT".to_string(), "UNPIVOT".to_string(), "UPDATE".to_string(), "VALUES".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Greedy,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IN".to_string(), "NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='IncludeKeywordSegment'
pub static INCLUDE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "INCLUDE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='IncludingKeywordSegment'
pub static INCLUDING_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "INCLUDING",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='IncrementKeywordSegment'
pub static INCREMENT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "INCREMENT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Indent'
pub static INDENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Meta("indent"))
);

// name='IndexAccessMethodSegment'
pub static INDEX_ACCESS_METHOD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// IndexAccessMethodSegment
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
);

// name='IndexColumnDefinitionSegment'
pub static INDEX_COLUMN_DEFINITION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// IndexColumnDefinitionSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AscKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ASC".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DescKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DESC".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ASC".to_string(), "DESC".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='IndexElementOptionsSegment'
pub static INDEX_ELEMENT_OPTIONS_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// IndexElementOptionsSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CollateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLLATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CollationReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLLATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OperatorClassReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: Some(Box::new(
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NullsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NULLS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FirstKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FIRST".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LastKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LAST".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FIRST".to_string(), "LAST".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NULLS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    )),
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "RelationOptionsSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AscKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ASC".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DescKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DESC".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ASC".to_string(), "DESC".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NullsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NULLS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FirstKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FIRST".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LastKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LAST".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FIRST".to_string(), "LAST".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NULLS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='IndexElementSegment'
pub static INDEX_ELEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// IndexElementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "FunctionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "IndexElementOptionsSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='IndexKeywordSegment'
pub static INDEX_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "INDEX",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='IndexParametersSegment'
pub static INDEX_PARAMETERS_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// IndexParametersSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IncludeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INCLUDE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BracketedColumnReferenceListGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INCLUDE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DefinitionParametersSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "UsingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IndexKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INDEX".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TablespaceKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLESPACE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TablespaceReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INCLUDE".to_string(), "USING".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='IndexReferenceSegment'
pub static INDEX_REFERENCE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// IndexReferenceSegment
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "ObjectReferenceDelimiterGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "ObjectReferenceTerminatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["!".to_string(), "%".to_string(), "&".to_string(), "(".to_string(), "*".to_string(), "+".to_string(), ",".to_string(), "-".to_string(), "/".to_string(), "//".to_string(), ":".to_string(), "::".to_string(), ";".to_string(), "<".to_string(), "=".to_string(), "==".to_string(), ">".to_string(), "AND".to_string(), "AS".to_string(), "COLLATE".to_string(), "IS".to_string(), "ON".to_string(), "OR".to_string(), "PIVOT".to_string(), "UNPIVOT".to_string(), "USING".to_string(), "[".to_string(), "^".to_string(), "|".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["glob_operator".to_string(), "json_operator".to_string(), "like_operator".to_string()]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: false,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='Index_cleanupKeywordSegment'
pub static INDEX_CLEANUP_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "INDEX_CLEANUP",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='IndexesKeywordSegment'
pub static INDEXES_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "INDEXES",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='InetKeywordSegment'
pub static INET_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "INET",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='InfileKeywordSegment'
pub static INFILE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "INFILE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='InfixKeywordSegment'
pub static INFIX_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "INFIX",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='InheritKeywordSegment'
pub static INHERIT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "INHERIT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='InheritsKeywordSegment'
pub static INHERITS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "INHERITS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='InitializeKeywordSegment'
pub static INITIALIZE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "INITIALIZE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='InitiallyKeywordSegment'
pub static INITIALLY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "INITIALLY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='InlineKeywordSegment'
pub static INLINE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "INLINE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='InnerKeywordSegment'
pub static INNER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "INNER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='InoutKeywordSegment'
pub static INOUT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "INOUT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='InputKeywordSegment'
pub static INPUT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "INPUT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='InsensitiveKeywordSegment'
pub static INSENSITIVE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "INSENSITIVE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='InsertKeywordSegment'
pub static INSERT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "INSERT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='InsertStatementSegment'
pub static INSERT_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// InsertStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "InsertKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INSERT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OrReplaceGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OrIgnoreGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IntoKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INTO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AsAliasExpressionSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "BracketedColumnReferenceListGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PositionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["POSITION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NameKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DefaultKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ValuesKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SelectStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SELECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "BracketedColumnReferenceListGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ValuesClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SelectStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SELECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SelectStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SELECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "SELECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "SELECT".to_string(), "VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "SELECT".to_string(), "VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "DEFAULT".to_string(), "SELECT".to_string(), "VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConflictKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONFLICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConflictTargetSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConflictActionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ReturningKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RETURNING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "StarSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["*".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AsAliasExpressionSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RETURNING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INSERT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='Insert_idKeywordSegment'
pub static INSERT_ID_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "INSERT_ID",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='InsteadKeywordSegment'
pub static INSTEAD_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "INSTEAD",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Int1KeywordSegment'
pub static INT1_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "INT1",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Int2KeywordSegment'
pub static INT2_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "INT2",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Int3KeywordSegment'
pub static INT3_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "INT3",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Int4KeywordSegment'
pub static INT4_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "INT4",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Int4rangeKeywordSegment'
pub static INT4RANGE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "INT4RANGE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Int8KeywordSegment'
pub static INT8_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "INT8",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Int8rangeKeywordSegment'
pub static INT8RANGE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "INT8RANGE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='IntKeywordSegment'
pub static INT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "INT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='IntegerKeywordSegment'
pub static INTEGER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "INTEGER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='IntegrationKeywordSegment'
pub static INTEGRATION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "INTEGRATION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='IntegrationsKeywordSegment'
pub static INTEGRATIONS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "INTEGRATIONS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='IntersectKeywordSegment'
pub static INTERSECT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "INTERSECT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='IntervalExpressionSegment'
pub static INTERVAL_EXPRESSION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// IntervalExpressionSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IntervalKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INTERVAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DatetimeUnitSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CENTURY".to_string(), "DAY".to_string(), "DAYOFYEAR".to_string(), "DECADE".to_string(), "DOW".to_string(), "DOY".to_string(), "EPOCH".to_string(), "HOUR".to_string(), "ISODOW".to_string(), "ISOYEAR".to_string(), "MICROSECONDS".to_string(), "MILLENNIUM".to_string(), "MILLISECOND".to_string(), "MILLISECONDS".to_string(), "MINUTE".to_string(), "MONTH".to_string(), "QUARTER".to_string(), "SECOND".to_string(), "TIMEZONE".to_string(), "TIMEZONE_HOUR".to_string(), "TIMEZONE_MINUTE".to_string(), "WEEK".to_string(), "WEEKDAY".to_string(), "YEAR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CENTURY".to_string(), "DAY".to_string(), "DAYOFYEAR".to_string(), "DECADE".to_string(), "DOW".to_string(), "DOY".to_string(), "EPOCH".to_string(), "HOUR".to_string(), "ISODOW".to_string(), "ISOYEAR".to_string(), "MICROSECONDS".to_string(), "MILLENNIUM".to_string(), "MILLISECOND".to_string(), "MILLISECONDS".to_string(), "MINUTE".to_string(), "MONTH".to_string(), "QUARTER".to_string(), "SECOND".to_string(), "TIMEZONE".to_string(), "TIMEZONE_HOUR".to_string(), "TIMEZONE_MINUTE".to_string(), "WEEK".to_string(), "WEEKDAY".to_string(), "YEAR".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DatetimeUnitSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CENTURY".to_string(), "DAY".to_string(), "DAYOFYEAR".to_string(), "DECADE".to_string(), "DOW".to_string(), "DOY".to_string(), "EPOCH".to_string(), "HOUR".to_string(), "ISODOW".to_string(), "ISOYEAR".to_string(), "MICROSECONDS".to_string(), "MILLENNIUM".to_string(), "MILLISECOND".to_string(), "MILLISECONDS".to_string(), "MINUTE".to_string(), "MONTH".to_string(), "QUARTER".to_string(), "SECOND".to_string(), "TIMEZONE".to_string(), "TIMEZONE_HOUR".to_string(), "TIMEZONE_MINUTE".to_string(), "WEEK".to_string(), "WEEKDAY".to_string(), "YEAR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CENTURY".to_string(), "DAY".to_string(), "DAYOFYEAR".to_string(), "DECADE".to_string(), "DOW".to_string(), "DOY".to_string(), "EPOCH".to_string(), "HOUR".to_string(), "ISODOW".to_string(), "ISOYEAR".to_string(), "MICROSECONDS".to_string(), "MILLENNIUM".to_string(), "MILLISECOND".to_string(), "MILLISECONDS".to_string(), "MINUTE".to_string(), "MONTH".to_string(), "QUARTER".to_string(), "SECOND".to_string(), "TIMEZONE".to_string(), "TIMEZONE_HOUR".to_string(), "TIMEZONE_MINUTE".to_string(), "WEEK".to_string(), "WEEKDAY".to_string(), "YEAR".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "numeric_literal".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INTERVAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='IntervalKeywordSegment'
pub static INTERVAL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "INTERVAL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='IntervalUnitsGrammar'
pub static INTERVAL_UNITS_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "YearKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["YEAR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MonthKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MONTH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DayKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DAY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "HourKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["HOUR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MinuteKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MINUTE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SecondKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SECOND".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DAY".to_string(), "HOUR".to_string(), "MINUTE".to_string(), "MONTH".to_string(), "SECOND".to_string(), "YEAR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='IntoClauseSegment'
pub static INTO_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// IntoClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IntoKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INTO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TemporaryKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TEMPORARY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TempKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TEMP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UnloggedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UNLOGGED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TEMP".to_string(), "TEMPORARY".to_string(), "UNLOGGED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INTO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='IntoKeywordSegment'
pub static INTO_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "INTO",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='InvokerKeywordSegment'
pub static INVOKER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "INVOKER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='IsClauseGrammar'
pub static IS_CLAUSE_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NullLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NanLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NAN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UnknownLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UNKNOWN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BooleanLiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FALSE".to_string(), "TRUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NormalizedGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NFC".to_string(), "NFD".to_string(), "NFKC".to_string(), "NFKD".to_string(), "NORMALIZED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "JsonTestGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["JSON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FALSE".to_string(), "JSON".to_string(), "NAN".to_string(), "NFC".to_string(), "NFD".to_string(), "NFKC".to_string(), "NFKD".to_string(), "NORMALIZED".to_string(), "NULL".to_string(), "TRUE".to_string(), "UNKNOWN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='IsDistinctFromGrammar'
pub static IS_DISTINCT_FROM_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NotKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DistinctKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DISTINCT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FromKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='IsKeywordSegment'
pub static IS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "IS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='IsNullGrammar'
pub static IS_NULL_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Ref {
    name: "IsnullKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ISNULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='Is_superuserKeywordSegment'
pub static IS_SUPERUSER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "IS_SUPERUSER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Is_templateKeywordSegment'
pub static IS_TEMPLATE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "IS_TEMPLATE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='IsamKeywordSegment'
pub static ISAM_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ISAM",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='IsnullKeywordSegment'
pub static ISNULL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ISNULL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='IsolationKeywordSegment'
pub static ISOLATION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ISOLATION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='IterateKeywordSegment'
pub static ITERATE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ITERATE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='JoinClauseSegment'
pub static JOIN_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// JoinClauseSegment
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ConditionalJoinKeywordsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "JoinKeywordsGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["JOIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::Ref {
    name: "FromExpressionElementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NestedJoinGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("dedent"))
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Meta("conditional"))
,
Arc::new(Grammar::Ref {
    name: "MatchConditionSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "JoinOnConditionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "JoinUsingConditionGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string(), "USING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("conditional"))
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "UnconditionalJoinKeywordsGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CROSS".to_string(), "NATURAL".to_string(), "POSITIONAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "JoinKeywordsGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["JOIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::Ref {
    name: "FromExpressionElementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "MatchConditionSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("dedent"))
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CROSS".to_string(), "NATURAL".to_string(), "POSITIONAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExtendedNaturalJoinKeywordsGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::Ref {
    name: "FromExpressionElementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("dedent"))
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='JoinKeywordSegment'
pub static JOIN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "JOIN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='JoinKeywordsGrammar'
pub static JOIN_KEYWORDS_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "JoinKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["JOIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["JOIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='JoinLikeClauseGrammar'
pub static JOIN_LIKE_CLAUSE_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FromPivotExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PIVOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FromUnpivotExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UNPIVOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 1,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PIVOT".to_string(), "UNPIVOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AliasExpressionSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PIVOT".to_string(), "UNPIVOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='JoinOnConditionSegment'
pub static JOIN_ON_CONDITION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// JoinOnConditionSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("conditional"))
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("conditional"))
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='JoinTypeKeywordsGrammar'
pub static JOIN_TYPE_KEYWORDS_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "InnerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INNER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FullKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LeftKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LEFT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RightKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RIGHT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FULL".to_string(), "LEFT".to_string(), "RIGHT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OuterKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OUTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FULL".to_string(), "LEFT".to_string(), "RIGHT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FULL".to_string(), "INNER".to_string(), "LEFT".to_string(), "RIGHT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='JoinUsingConditionGrammar'
pub static JOIN_USING_CONDITION_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "UsingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Greedy,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("dedent"))
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='JsonKeywordSegment'
pub static JSON_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "JSON",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='JsonOperatorSegment'
pub static JSON_OPERATOR_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::TypedParser {
    template: "json_operator",
    token_type: "binary_operator",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='JsonTestGrammar'
pub static JSON_TEST_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "JsonKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["JSON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "JsonTypeGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ARRAY".to_string(), "OBJECT".to_string(), "SCALAR".to_string(), "VALUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "JsonUniqueKeysGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string(), "WITHOUT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["JSON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='JsonTypeGrammar'
pub static JSON_TYPE_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ValueKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VALUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ScalarKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCALAR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ArrayKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ARRAY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OBJECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ARRAY".to_string(), "OBJECT".to_string(), "SCALAR".to_string(), "VALUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='JsonUniqueKeysGrammar'
pub static JSON_UNIQUE_KEYS_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WithoutKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITHOUT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string(), "WITHOUT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UniqueKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UNIQUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "KeysKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["KEYS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["KEYS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string(), "WITHOUT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='JsonbKeywordSegment'
pub static JSONB_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "JSONB",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='KeyKeywordSegment'
pub static KEY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "KEY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='KeysKeywordSegment'
pub static KEYS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "KEYS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='KeywordSegment'
pub static KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Token{
    token_type: "keyword",
//    token_type: "KeywordSegment",
})
);

// name='KillKeywordSegment'
pub static KILL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "KILL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LabelKeywordSegment'
pub static LABEL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LABEL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LambdaArrowSegment'
pub static LAMBDA_ARROW_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "->",
    token_type: "lambda_arrow",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='LambdaExpressionSegment'
pub static LAMBDA_EXPRESSION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// LambdaExpressionSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "LambdaArrowSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["->".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='LancompilerKeywordSegment'
pub static LANCOMPILER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LANCOMPILER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LanguageClauseSegment'
pub static LANGUAGE_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// LanguageClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LanguageKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LANGUAGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NakedIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "SingleQuotedIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["single_quote".to_string()]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LANGUAGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='LanguageKeywordSegment'
pub static LANGUAGE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LANGUAGE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LargeKeywordSegment'
pub static LARGE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LARGE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LastKeywordSegment'
pub static LAST_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LAST",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Last_insert_idKeywordSegment'
pub static LAST_INSERT_ID_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LAST_INSERT_ID",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LateralKeywordSegment'
pub static LATERAL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LATERAL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Lc_collateKeywordSegment'
pub static LC_COLLATE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LC_COLLATE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Lc_ctypeKeywordSegment'
pub static LC_CTYPE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LC_CTYPE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LeadingKeywordSegment'
pub static LEADING_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LEADING",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LeakproofKeywordSegment'
pub static LEAKPROOF_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LEAKPROOF",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LeastKeywordSegment'
pub static LEAST_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LEAST",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LeaveKeywordSegment'
pub static LEAVE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LEAVE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LeftKeywordSegment'
pub static LEFT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LEFT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LeftargKeywordSegment'
pub static LEFTARG_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LEFTARG",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LessKeywordSegment'
pub static LESS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LESS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LessThanOrEqualToSegment'
pub static LESS_THAN_OR_EQUAL_TO_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// LessThanOrEqualToSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RawLessThanSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["<".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RawEqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: false,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["<".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='LessThanSegment'
pub static LESS_THAN_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// LessThanSegment
Arc::new(Grammar::Ref {
    name: "RawLessThanSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["<".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='LevelKeywordSegment'
pub static LEVEL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LEVEL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LibcKeywordSegment'
pub static LIBC_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LIBC",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LikeExpressionGrammar'
pub static LIKE_EXPRESSION_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NotKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LikeGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GLOB".to_string(), "ILIKE".to_string(), "LIKE".to_string(), "SIMILAR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GLOB".to_string(), "ILIKE".to_string(), "LIKE".to_string(), "NOT".to_string(), "SIMILAR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Expression_A_Grammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "EscapeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ESCAPE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Tail_Recurse_Expression_A_Grammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ESCAPE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GLOB".to_string(), "ILIKE".to_string(), "LIKE".to_string(), "NOT".to_string(), "SIMILAR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='LikeGrammar'
pub static LIKE_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LikeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LIKE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IlikeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ILIKE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SimilarKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SIMILAR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SIMILAR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "GlobKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GLOB".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GLOB".to_string(), "ILIKE".to_string(), "LIKE".to_string(), "SIMILAR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='LikeKeywordSegment'
pub static LIKE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LIKE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LikeOperatorSegment'
pub static LIKE_OPERATOR_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::TypedParser {
    template: "like_operator",
    token_type: "like_operator",
    raw_class: "ComparisonOperatorSegment",
    optional: false,
})
);

// name='LikeOptionSegment'
pub static LIKE_OPTION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// LikeOptionSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IncludingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INCLUDING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExcludingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCLUDING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCLUDING".to_string(), "INCLUDING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CommentsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COMMENTS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConstraintsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRAINTS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DefaultsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULTS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "GeneratedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GENERATED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IdentityKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IDENTITY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IndexesKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INDEXES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StatisticsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STATISTICS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StorageKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STORAGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AllKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string(), "COMMENTS".to_string(), "CONSTRAINTS".to_string(), "DEFAULTS".to_string(), "GENERATED".to_string(), "IDENTITY".to_string(), "INDEXES".to_string(), "STATISTICS".to_string(), "STORAGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCLUDING".to_string(), "INCLUDING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='LimitClauseSegment'
pub static LIMIT_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// LimitClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LimitKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LIMIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AllKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AllKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OffsetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OFFSET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OFFSET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string(), "OFFSET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("dedent"))
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LIMIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='LimitKeywordSegment'
pub static LIMIT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LIMIT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LineKeywordSegment'
pub static LINE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LINE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LinenoKeywordSegment'
pub static LINENO_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LINENO",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LinesKeywordSegment'
pub static LINES_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LINES",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LinestringKeywordSegment'
pub static LINESTRING_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LINESTRING",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LinestringmKeywordSegment'
pub static LINESTRINGM_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LINESTRINGM",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LinestringzKeywordSegment'
pub static LINESTRINGZ_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LINESTRINGZ",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LinestringzmKeywordSegment'
pub static LINESTRINGZM_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LINESTRINGZM",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ListComprehensionExpressionSegment'
pub static LIST_COMPREHENSION_EXPRESSION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ListComprehensionExpressionSegment
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ForKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "InKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IfKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "[",
    token_type: "start_square_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: "]",
    token_type: "end_square_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["[".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ListComprehensionGrammar'
pub static LIST_COMPREHENSION_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Ref {
    name: "ListComprehensionExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["[".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ListKeywordSegment'
pub static LIST_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LIST",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ListenKeywordSegment'
pub static LISTEN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LISTEN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ListenStatementSegment'
pub static LISTEN_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ListenStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ListenKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LISTEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LISTEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='LiteralGrammar'
pub static LITERAL_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BooleanLiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FALSE".to_string(), "TRUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QualifiedNumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["+".to_string(), "-".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NullLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DateTimeLiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATE".to_string(), "INTERVAL".to_string(), "TIME".to_string(), "TIMESTAMP".to_string(), "TIMESTAMPTZ".to_string(), "TIMETZ".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DollarNumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["dollar_numeric_literal".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PsqlVariableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), ":".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ArrayLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["[".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TypedArrayLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ARRAY".to_string(), "VARIADIC".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["{".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "+".to_string(), "-".to_string(), ":".to_string(), "ARRAY".to_string(), "DATE".to_string(), "FALSE".to_string(), "INTERVAL".to_string(), "NULL".to_string(), "TIME".to_string(), "TIMESTAMP".to_string(), "TIMESTAMPTZ".to_string(), "TIMETZ".to_string(), "TRUE".to_string(), "VARIADIC".to_string(), "[".to_string(), "{".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_numeric_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "numeric_literal".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
);

// name='LiteralKeywordSegment'
pub static LITERAL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Token{
    token_type: "literal",
//    token_type: "LiteralKeywordSegment",
})
);

// name='LiteralSegment'
pub static LITERAL_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Token{
    token_type: "literal",
//    token_type: "LiteralSegment",
})
);

// name='LoadKeywordSegment'
pub static LOAD_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LOAD",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LoadStatementSegment'
pub static LOAD_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// LoadStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LoadKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LOAD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LOAD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='LocalAliasSegment'
pub static LOCAL_ALIAS_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// LocalAliasSegment
Arc::new(Grammar::Nothing())
);

// name='LocalKeywordSegment'
pub static LOCAL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LOCAL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LocaleKeywordSegment'
pub static LOCALE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LOCALE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LocaltimeKeywordSegment'
pub static LOCALTIME_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LOCALTIME",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LocaltimestampKeywordSegment'
pub static LOCALTIMESTAMP_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LOCALTIMESTAMP",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LocationKeywordSegment'
pub static LOCATION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LOCATION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LockKeywordSegment'
pub static LOCK_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LOCK",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LockTableStatementSegment'
pub static LOCK_TABLE_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// LockTableStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LockKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LOCK".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OnlyKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ONLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "StarSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["*".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "InKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AccessKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ACCESS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ShareKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SHARE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ACCESS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RowKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ShareKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SHARE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RowKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExclusiveKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCLUSIVE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ShareKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SHARE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UpdateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UPDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExclusiveKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCLUSIVE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SHARE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ShareKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SHARE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ShareKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SHARE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RowKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExclusiveKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCLUSIVE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SHARE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExclusiveKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCLUSIVE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AccessKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ACCESS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExclusiveKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCLUSIVE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ACCESS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ACCESS".to_string(), "EXCLUSIVE".to_string(), "ROW".to_string(), "SHARE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ModeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MODE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NowaitKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOWAIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LOCK".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='LockedKeywordSegment'
pub static LOCKED_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LOCKED",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LocksKeywordSegment'
pub static LOCKS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LOCKS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LoggedKeywordSegment'
pub static LOGGED_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LOGGED",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LoginKeywordSegment'
pub static LOGIN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LOGIN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LogsKeywordSegment'
pub static LOGS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LOGS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LongKeywordSegment'
pub static LONG_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LONG",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LongblobKeywordSegment'
pub static LONGBLOB_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LONGBLOB",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LongtextKeywordSegment'
pub static LONGTEXT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LONGTEXT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LoopKeywordSegment'
pub static LOOP_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LOOP",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Low_priorityKeywordSegment'
pub static LOW_PRIORITY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LOW_PRIORITY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='LsegKeywordSegment'
pub static LSEG_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "LSEG",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MLTableExpressionSegment'
pub static M_L_TABLE_EXPRESSION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// MLTableExpressionSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "MlKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ML".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DotSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ModelKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MODEL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MODEL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SelectableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "DELETE".to_string(), "FROM".to_string(), "INSERT".to_string(), "PIVOT".to_string(), "PIVOT_LONGER".to_string(), "PIVOT_WIDER".to_string(), "SELECT".to_string(), "UNPIVOT".to_string(), "UPDATE".to_string(), "VALUES".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ML".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='Macaddr8KeywordSegment'
pub static MACADDR8_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MACADDR8",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MacaddrKeywordSegment'
pub static MACADDR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MACADDR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MacroKeywordSegment'
pub static MACRO_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MACRO",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MainKeywordSegment'
pub static MAIN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MAIN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ManageKeywordSegment'
pub static MANAGE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MANAGE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MapKeywordSegment'
pub static MAP_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MAP",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MapTypeSchemaSegment'
pub static MAP_TYPE_SCHEMA_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// MapTypeSchemaSegment
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DatatypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='MapTypeSegment'
pub static MAP_TYPE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// MapTypeSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "MapKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MAP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MapTypeSchemaSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MAP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='MappingKeywordSegment'
pub static MAPPING_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MAPPING",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MaskingKeywordSegment'
pub static MASKING_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MASKING",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MatchConditionSegment'
pub static MATCH_CONDITION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// MatchConditionSegment
Arc::new(Grammar::Nothing())
);

// name='MatchKeywordSegment'
pub static MATCH_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MATCH",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MatchedKeywordSegment'
pub static MATCHED_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MATCHED",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MaterializedKeywordSegment'
pub static MATERIALIZED_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MATERIALIZED",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Max_rowsKeywordSegment'
pub static MAX_ROWS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MAX_ROWS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MaxextentsKeywordSegment'
pub static MAXEXTENTS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MAXEXTENTS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MaxvalueKeywordSegment'
pub static MAXVALUE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MAXVALUE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='McvKeywordSegment'
pub static MCV_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MCV",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MediumblobKeywordSegment'
pub static MEDIUMBLOB_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MEDIUMBLOB",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MediumintKeywordSegment'
pub static MEDIUMINT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MEDIUMINT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MediumtextKeywordSegment'
pub static MEDIUMTEXT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MEDIUMTEXT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MergeDeleteClauseSegment'
pub static MERGE_DELETE_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// MergeDeleteClauseSegment
Arc::new(Grammar::Ref {
    name: "DeleteKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DELETE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='MergeInsertClauseSegment'
pub static MERGE_INSERT_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// MergeInsertClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "InsertKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INSERT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::Ref {
    name: "BracketedColumnReferenceListGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("dedent"))
,
Arc::new(Grammar::Ref {
    name: "ValuesClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INSERT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='MergeIntoLiteralGrammar'
pub static MERGE_INTO_LITERAL_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "MergeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MERGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IntoKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INTO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MERGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='MergeKeywordSegment'
pub static MERGE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MERGE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MergeMatchSegment'
pub static MERGE_MATCH_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// MergeMatchSegment
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "MergeMatchedClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MergeNotMatchedClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 1,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='MergeMatchedClauseSegment'
pub static MERGE_MATCHED_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// MergeMatchedClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WhenKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MatchedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MATCHED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AndKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AND".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AND".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ThenKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["THEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "MergeUpdateClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UPDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MergeDeleteClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DELETE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DELETE".to_string(), "UPDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("dedent"))
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='MergeNotMatchedClauseSegment'
pub static MERGE_NOT_MATCHED_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// MergeNotMatchedClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WhenKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NotKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MatchedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MATCHED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AndKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AND".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AND".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ThenKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["THEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::Ref {
    name: "MergeInsertClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INSERT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("dedent"))
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='MergeStatementSegment'
pub static MERGE_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// MergeStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "MergeIntoLiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MERGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AliasedTableReferenceGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("dedent"))
,
Arc::new(Grammar::Ref {
    name: "UsingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AliasedTableReferenceGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SelectableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "DELETE".to_string(), "FROM".to_string(), "INSERT".to_string(), "PIVOT".to_string(), "PIVOT_LONGER".to_string(), "PIVOT_WIDER".to_string(), "SELECT".to_string(), "UNPIVOT".to_string(), "UPDATE".to_string(), "VALUES".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AliasExpressionSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("dedent"))
,
Arc::new(Grammar::Meta("conditional"))
,
Arc::new(Grammar::Ref {
    name: "JoinOnConditionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("conditional"))
,
Arc::new(Grammar::Ref {
    name: "MergeMatchSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MERGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='MergeUpdateClauseSegment'
pub static MERGE_UPDATE_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// MergeUpdateClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "UpdateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UPDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::Ref {
    name: "SetClauseListSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("dedent"))
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UPDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='MergesKeywordSegment'
pub static MERGES_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MERGES",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MetaCommandQueryBufferSegment'
pub static META_COMMAND_QUERY_BUFFER_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::TypedParser {
    template: "meta_command_query_buffer",
    token_type: "meta_command",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='MetaCommandQueryBufferStatement'
pub static META_COMMAND_QUERY_BUFFER_STATEMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// MetaCommandQueryBufferStatement
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SelectStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SELECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MetaCommandQueryBufferSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["meta_command_query_buffer".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SELECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SELECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SELECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='MethodKeywordSegment'
pub static METHOD_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "METHOD",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MiddleintKeywordSegment'
pub static MIDDLEINT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MIDDLEINT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MillisecondKeywordSegment'
pub static MILLISECOND_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MILLISECOND",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Min_rowsKeywordSegment'
pub static MIN_ROWS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MIN_ROWS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MinusKeywordSegment'
pub static MINUS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MINUS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MinusSegment'
pub static MINUS_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "-",
    token_type: "binary_operator",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='MinuteKeywordSegment'
pub static MINUTE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MINUTE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Minute_microsecondKeywordSegment'
pub static MINUTE_MICROSECOND_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MINUTE_MICROSECOND",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Minute_secondKeywordSegment'
pub static MINUTE_SECOND_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MINUTE_SECOND",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MinvalueKeywordSegment'
pub static MINVALUE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MINVALUE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MlKeywordSegment'
pub static ML_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ML",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MlslabelKeywordSegment'
pub static MLSLABEL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MLSLABEL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ModeKeywordSegment'
pub static MODE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MODE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ModelKeywordSegment'
pub static MODEL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MODEL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ModifyKeywordSegment'
pub static MODIFY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MODIFY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ModuloSegment'
pub static MODULO_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "%",
    token_type: "binary_operator",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='ModulusKeywordSegment'
pub static MODULUS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MODULUS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MoneyKeywordSegment'
pub static MONEY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MONEY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MonitorKeywordSegment'
pub static MONITOR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MONITOR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MonthKeywordSegment'
pub static MONTH_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MONTH",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MonthnameKeywordSegment'
pub static MONTHNAME_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MONTHNAME",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MoveKeywordSegment'
pub static MOVE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MOVE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MulticurveKeywordSegment'
pub static MULTICURVE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MULTICURVE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MultilineConcatenateDelimiterGrammar'
pub static MULTILINE_CONCATENATE_DELIMITER_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "MultilineConcatenateNewline",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["newline".to_string()]),
        }),
})
,
    ],
    min_times: 1,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: false,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["newline".to_string()]),
        }),
})
);

// name='MultilineConcatenateNewline'
pub static MULTILINE_CONCATENATE_NEWLINE: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::TypedParser {
    template: "newline",
    token_type: "newline",
    raw_class: "NewlineSegment",
    optional: false,
})
);

// name='MultilinestringKeywordSegment'
pub static MULTILINESTRING_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MULTILINESTRING",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MultilinestringmKeywordSegment'
pub static MULTILINESTRINGM_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MULTILINESTRINGM",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MultilinestringzKeywordSegment'
pub static MULTILINESTRINGZ_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MULTILINESTRINGZ",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MultilinestringzmKeywordSegment'
pub static MULTILINESTRINGZM_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MULTILINESTRINGZM",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MultiplySegment'
pub static MULTIPLY_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "*",
    token_type: "binary_operator",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='MultipointKeywordSegment'
pub static MULTIPOINT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MULTIPOINT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MultipointmKeywordSegment'
pub static MULTIPOINTM_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MULTIPOINTM",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MultipointzKeywordSegment'
pub static MULTIPOINTZ_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MULTIPOINTZ",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MultipointzmKeywordSegment'
pub static MULTIPOINTZM_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MULTIPOINTZM",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MultipolygonKeywordSegment'
pub static MULTIPOLYGON_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MULTIPOLYGON",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MultipolygonmKeywordSegment'
pub static MULTIPOLYGONM_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MULTIPOLYGONM",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MultipolygonzKeywordSegment'
pub static MULTIPOLYGONZ_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MULTIPOLYGONZ",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MultipolygonzmKeywordSegment'
pub static MULTIPOLYGONZM_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MULTIPOLYGONZM",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MultisurfaceKeywordSegment'
pub static MULTISURFACE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MULTISURFACE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='MyisamKeywordSegment'
pub static MYISAM_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "MYISAM",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NakedIdentifierFullSegment'
pub static NAKED_IDENTIFIER_FULL_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::TypedParser {
    template: "word",
    token_type: "naked_identifier_all",
    raw_class: "IdentifierSegment",
    optional: false,
})
);

// name='NakedIdentifierSegment'
pub static NAKED_IDENTIFIER_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::RegexParser {
    template: RegexMode::new(r#"[\p{L}_][\p{L}\p{N}_$]*"#),
    token_type: "naked_identifier",
    raw_class: "IdentifierSegment",
    optional: false,
    anti_template: Some(RegexMode::new(r#"^(CURRENT_DATE|IS|DEFAULT|TRAILING|CONSTRAINT|CASE|ALL|WHEN|OR|HASHES|CURRENT_TIMESTAMP|ANALYZE|JOIN|NEGATOR|BOTH|CURRENT_SCHEMA|LOCALTIMESTAMP|TABLESAMPLE|TO|SYMMETRIC|FULL|NATURAL|ASYMMETRIC|CURRENT_CATALOG|LEADING|SIMILAR|INNER|ASC|FREEZE|ELSE|COLLATE|EXCEPT|NULL|LIKE|PLACING|FETCH|CONNECT|UNION|COLUMN|USING|CURRENT_TIME|CURRENT_ROLE|ARRAY|RETURNING|FOR|CREATE|SESSION_USER|DISTINCT|ILIKE|CHECK|GRANT|SOME|ONLY|CROSS|COMMUTATOR|LATERAL|MERGES|ON|LEFT|RIGHTARG|INTO|WINDOW|UNPIVOT|VARIADIC|CONCURRENTLY|ISNULL|ORDER|LIMIT|CAST|FOREIGN|NOT|OUTER|PIVOT_WIDER|GROUP|OFFSET|THEN|VERBOSE|ANY|UNIQUE|INITIALLY|SELECT|DESC|DEFERRABLE|FROM|OVERLAPS|DO|END|PIVOT|INTERSECT|PIVOT_LONGER|WHERE|FALSE|LOCALTIME|AS|IN|PRIMARY|REFERENCES|BINARY|RIGHT|HAVING|TRUE|ANALYSE|NOTNULL|WITH|AUTHORIZATION|AND)$"#)),
})
);

// name='NameKeywordSegment'
pub static NAME_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NAME",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NamedArgumentSegment'
pub static NAMED_ARGUMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// NamedArgumentSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NakedIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RightArrowSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=>".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WalrusOperatorSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([":=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([":=".to_string(), "=".to_string(), "=>".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='NamedWindowExpressionSegment'
pub static NAMED_WINDOW_EXPRESSION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// NamedWindowExpressionSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WindowSpecificationSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Greedy,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='NamedWindowSegment'
pub static NAMED_WINDOW_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// NamedWindowSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WindowKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WINDOW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NamedWindowExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("dedent"))
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WINDOW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='NamesKeywordSegment'
pub static NAMES_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NAMES",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NanKeywordSegment'
pub static NAN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NAN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NanLiteralSegment'
pub static NAN_LITERAL_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NAN",
    token_type: "null_literal",
    raw_class: "LiteralKeywordSegment",
    optional: false,
})
);

// name='NationalKeywordSegment'
pub static NATIONAL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NATIONAL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NaturalJoinKeywordsGrammar'
pub static NATURAL_JOIN_KEYWORDS_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NaturalKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NATURAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "JoinTypeKeywordsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FULL".to_string(), "INNER".to_string(), "LEFT".to_string(), "RIGHT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NATURAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='NaturalKeywordSegment'
pub static NATURAL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NATURAL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NcharKeywordSegment'
pub static NCHAR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NCHAR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NdistinctKeywordSegment'
pub static NDISTINCT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NDISTINCT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NegativeSegment'
pub static NEGATIVE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "-",
    token_type: "sign_indicator",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='NegatorKeywordSegment'
pub static NEGATOR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NEGATOR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NestedJoinGrammar'
pub static NESTED_JOIN_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Nothing())
);

// name='NewKeywordSegment'
pub static NEW_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NEW",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NewlineSegment'
pub static NEWLINE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Token{
    token_type: "newline",
//    token_type: "NewlineSegment",
})
);

// name='NextKeywordSegment'
pub static NEXT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NEXT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NfcKeywordSegment'
pub static NFC_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NFC",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NfdKeywordSegment'
pub static NFD_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NFD",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NfkcKeywordSegment'
pub static NFKC_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NFKC",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NfkdKeywordSegment'
pub static NFKD_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NFKD",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NoKeywordSegment'
pub static NO_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NO",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='No_write_to_binlogKeywordSegment'
pub static NO_WRITE_TO_BINLOG_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NO_WRITE_TO_BINLOG",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NoauditKeywordSegment'
pub static NOAUDIT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NOAUDIT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NobypassrlsKeywordSegment'
pub static NOBYPASSRLS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NOBYPASSRLS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NocacheKeywordSegment'
pub static NOCACHE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NOCACHE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NocheckKeywordSegment'
pub static NOCHECK_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NOCHECK",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NocompressKeywordSegment'
pub static NOCOMPRESS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NOCOMPRESS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NocreatedbKeywordSegment'
pub static NOCREATEDB_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NOCREATEDB",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NocreateroleKeywordSegment'
pub static NOCREATEROLE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NOCREATEROLE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NocreateuserKeywordSegment'
pub static NOCREATEUSER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NOCREATEUSER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NocycleKeywordSegment'
pub static NOCYCLE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NOCYCLE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NoinheritKeywordSegment'
pub static NOINHERIT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NOINHERIT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NologinKeywordSegment'
pub static NOLOGIN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NOLOGIN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NonSetSelectableGrammar'
pub static NON_SET_SELECTABLE_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ValuesClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UnorderedSelectStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string(), "SELECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SelectStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SELECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithCompoundStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NonSetSelectableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "FROM".to_string(), "PIVOT".to_string(), "PIVOT_LONGER".to_string(), "PIVOT_WIDER".to_string(), "SELECT".to_string(), "UNPIVOT".to_string(), "VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BracketedSetExpressionGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SimplifiedPivotExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PIVOT".to_string(), "PIVOT_WIDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SimplifiedUnpivotExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PIVOT_LONGER".to_string(), "UNPIVOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "FROM".to_string(), "PIVOT".to_string(), "PIVOT_LONGER".to_string(), "PIVOT_WIDER".to_string(), "SELECT".to_string(), "UNPIVOT".to_string(), "VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='NonStandardJoinTypeKeywordsGrammar'
pub static NON_STANDARD_JOIN_TYPE_KEYWORDS_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AntiKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ANTI".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SemiKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SEMI".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AsofKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ASOF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "JoinTypeKeywordsGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FULL".to_string(), "INNER".to_string(), "LEFT".to_string(), "RIGHT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AntiKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ANTI".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SemiKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SEMI".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ANTI".to_string(), "FULL".to_string(), "INNER".to_string(), "LEFT".to_string(), "RIGHT".to_string(), "SEMI".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ASOF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ANTI".to_string(), "ASOF".to_string(), "SEMI".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='NonWithNonSelectableGrammar'
pub static NON_WITH_NON_SELECTABLE_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='NonWithSelectableGrammar'
pub static NON_WITH_SELECTABLE_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "FROM".to_string(), "PIVOT".to_string(), "PIVOT_LONGER".to_string(), "PIVOT_WIDER".to_string(), "SELECT".to_string(), "UNPIVOT".to_string(), "VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SelectStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SELECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SelectStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SELECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "SELECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NonSetSelectableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "FROM".to_string(), "PIVOT".to_string(), "PIVOT_LONGER".to_string(), "PIVOT_WIDER".to_string(), "SELECT".to_string(), "UNPIVOT".to_string(), "VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UpdateStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UPDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "InsertStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INSERT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DeleteStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DELETE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "DELETE".to_string(), "FROM".to_string(), "INSERT".to_string(), "PIVOT".to_string(), "PIVOT_LONGER".to_string(), "PIVOT_WIDER".to_string(), "SELECT".to_string(), "UNPIVOT".to_string(), "UPDATE".to_string(), "VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='NonclusteredKeywordSegment'
pub static NONCLUSTERED_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NONCLUSTERED",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NoneKeywordSegment'
pub static NONE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NONE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NoorderKeywordSegment'
pub static NOORDER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NOORDER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NoreplicationKeywordSegment'
pub static NOREPLICATION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NOREPLICATION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NormalizeKeywordSegment'
pub static NORMALIZE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NORMALIZE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NormalizedGrammar'
pub static NORMALIZED_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NfcKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NFC".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NfdKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NFD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NfkcKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NFKC".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NfkdKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NFKD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NFC".to_string(), "NFD".to_string(), "NFKC".to_string(), "NFKD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NormalizedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NORMALIZED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NFC".to_string(), "NFD".to_string(), "NFKC".to_string(), "NFKD".to_string(), "NORMALIZED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='NormalizedKeywordSegment'
pub static NORMALIZED_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NORMALIZED",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NosuperuserKeywordSegment'
pub static NOSUPERUSER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NOSUPERUSER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NotEnforcedGrammar'
pub static NOT_ENFORCED_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Nothing())
);

// name='NotEqualToSegment'
pub static NOT_EQUAL_TO_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// NotEqualToSegment
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RawNotSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["!".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RawEqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: false,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["!".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RawLessThanSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["<".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RawGreaterThanSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([">".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: false,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["<".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["!".to_string(), "<".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='NotExtendLeftSegment'
pub static NOT_EXTEND_LEFT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// NotExtendLeftSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AmpersandSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["&".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RawLessThanSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["<".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: false,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["&".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='NotExtendRightSegment'
pub static NOT_EXTEND_RIGHT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// NotExtendRightSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AmpersandSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["&".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RawGreaterThanSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([">".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: false,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["&".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='NotKeywordSegment'
pub static NOT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NOT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NotNullGrammar'
pub static NOT_NULL_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Ref {
    name: "NotnullKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOTNULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='NotOperatorGrammar'
pub static NOT_OPERATOR_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NOT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NothingKeywordSegment'
pub static NOTHING_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NOTHING",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NotifyKeywordSegment'
pub static NOTIFY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NOTIFY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NotifyStatementSegment'
pub static NOTIFY_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// NotifyStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NotifyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOTIFY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOTIFY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='NotnullKeywordSegment'
pub static NOTNULL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NOTNULL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NowaitKeywordSegment'
pub static NOWAIT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NOWAIT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NullKeywordSegment'
pub static NULL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NULL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NullLiteralSegment'
pub static NULL_LITERAL_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NULL",
    token_type: "null_literal",
    raw_class: "LiteralKeywordSegment",
    optional: false,
})
);

// name='NullifKeywordSegment'
pub static NULLIF_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NULLIF",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NullsKeywordSegment'
pub static NULLS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NULLS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NumericKeywordSegment'
pub static NUMERIC_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NUMERIC",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='NumericLiteralSegment'
pub static NUMERIC_LITERAL_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::TypedParser {
    template: "numeric_literal",
    token_type: "numeric_literal",
    raw_class: "LiteralSegment",
    optional: false,
})
);

// name='NumrangeKeywordSegment'
pub static NUMRANGE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "NUMRANGE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ObjectKeywordSegment'
pub static OBJECT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OBJECT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ObjectLiteralElementSegment'
pub static OBJECT_LITERAL_ELEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ObjectLiteralElementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NakedIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ColonSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([":".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BaseExpressionElementGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='ObjectLiteralSegment'
pub static OBJECT_LITERAL_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ObjectLiteralSegment
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ObjectLiteralElementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: true,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "{",
    token_type: "start_curly_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: "}",
    token_type: "end_curly_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["{".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ObjectReferenceDelimiterGrammar'
pub static OBJECT_REFERENCE_DELIMITER_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DotSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DotSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DotSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ObjectReferenceSegment'
pub static OBJECT_REFERENCE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ObjectReferenceSegment
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "ObjectReferenceDelimiterGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "ObjectReferenceTerminatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["!".to_string(), "%".to_string(), "&".to_string(), "(".to_string(), "*".to_string(), "+".to_string(), ",".to_string(), "-".to_string(), "/".to_string(), "//".to_string(), ":".to_string(), "::".to_string(), ";".to_string(), "<".to_string(), "=".to_string(), "==".to_string(), ">".to_string(), "AND".to_string(), "AS".to_string(), "COLLATE".to_string(), "IS".to_string(), "ON".to_string(), "OR".to_string(), "PIVOT".to_string(), "UNPIVOT".to_string(), "USING".to_string(), "[".to_string(), "^".to_string(), "|".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["glob_operator".to_string(), "json_operator".to_string(), "like_operator".to_string()]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: false,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='ObjectReferenceTerminatorGrammar'
pub static OBJECT_REFERENCE_TERMINATOR_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UsingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CastOperatorSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["::".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StartSquareBracketSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["[".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StartBracketSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BinaryOperatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["!".to_string(), "%".to_string(), "&".to_string(), "*".to_string(), "+".to_string(), "-".to_string(), "/".to_string(), "//".to_string(), "<".to_string(), "=".to_string(), "==".to_string(), ">".to_string(), "AND".to_string(), "COLLATE".to_string(), "IS".to_string(), "OR".to_string(), "^".to_string(), "|".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["glob_operator".to_string(), "json_operator".to_string(), "like_operator".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColonSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([":".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DelimiterGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([";".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "JoinLikeClauseGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PIVOT".to_string(), "UNPIVOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Token{
    token_type: "bracketed",
//    token_type: "BracketedSegment",
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["!".to_string(), "%".to_string(), "&".to_string(), "(".to_string(), "*".to_string(), "+".to_string(), ",".to_string(), "-".to_string(), "/".to_string(), "//".to_string(), ":".to_string(), "::".to_string(), ";".to_string(), "<".to_string(), "=".to_string(), "==".to_string(), ">".to_string(), "AND".to_string(), "AS".to_string(), "COLLATE".to_string(), "IS".to_string(), "ON".to_string(), "OR".to_string(), "PIVOT".to_string(), "UNPIVOT".to_string(), "USING".to_string(), "[".to_string(), "^".to_string(), "|".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["glob_operator".to_string(), "json_operator".to_string(), "like_operator".to_string()]),
        }),
})
);

// name='ObjectsKeywordSegment'
pub static OBJECTS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OBJECTS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OfKeywordSegment'
pub static OF_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OF",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OffKeywordSegment'
pub static OFF_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OFF",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OfflineKeywordSegment'
pub static OFFLINE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OFFLINE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OffsetClauseSegment'
pub static OFFSET_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// OffsetClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OffsetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OFFSET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("dedent"))
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OFFSET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='OffsetKeywordSegment'
pub static OFFSET_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OFFSET",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OffsetsKeywordSegment'
pub static OFFSETS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OFFSETS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OidsKeywordSegment'
pub static OIDS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OIDS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OldKeywordSegment'
pub static OLD_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OLD",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OnKeywordAsIdentifierSegment'
pub static ON_KEYWORD_AS_IDENTIFIER_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ON",
    token_type: "naked_identifier",
    raw_class: "IdentifierSegment",
    optional: false,
})
);

// name='OnKeywordSegment'
pub static ON_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ON",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OnlineKeywordSegment'
pub static ONLINE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ONLINE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OnlyKeywordSegment'
pub static ONLY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ONLY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OpendatasourceKeywordSegment'
pub static OPENDATASOURCE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OPENDATASOURCE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OpenqueryKeywordSegment'
pub static OPENQUERY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OPENQUERY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OpenrowsetKeywordSegment'
pub static OPENROWSET_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OPENROWSET",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OpenxmlKeywordSegment'
pub static OPENXML_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OPENXML",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OperateKeywordSegment'
pub static OPERATE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OPERATE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OperationClassReferenceSegment'
pub static OPERATION_CLASS_REFERENCE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// OperationClassReferenceSegment
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "ObjectReferenceDelimiterGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "ObjectReferenceTerminatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["!".to_string(), "%".to_string(), "&".to_string(), "(".to_string(), "*".to_string(), "+".to_string(), ",".to_string(), "-".to_string(), "/".to_string(), "//".to_string(), ":".to_string(), "::".to_string(), ";".to_string(), "<".to_string(), "=".to_string(), "==".to_string(), ">".to_string(), "AND".to_string(), "AS".to_string(), "COLLATE".to_string(), "IS".to_string(), "ON".to_string(), "OR".to_string(), "PIVOT".to_string(), "UNPIVOT".to_string(), "USING".to_string(), "[".to_string(), "^".to_string(), "|".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["glob_operator".to_string(), "json_operator".to_string(), "like_operator".to_string()]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: false,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='OperationKeywordSegment'
pub static OPERATION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OPERATION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OperatorClassReferenceSegment'
pub static OPERATOR_CLASS_REFERENCE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// OperatorClassReferenceSegment
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "ObjectReferenceDelimiterGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "ObjectReferenceTerminatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["!".to_string(), "%".to_string(), "&".to_string(), "(".to_string(), "*".to_string(), "+".to_string(), ",".to_string(), "-".to_string(), "/".to_string(), "//".to_string(), ":".to_string(), "::".to_string(), ";".to_string(), "<".to_string(), "=".to_string(), "==".to_string(), ">".to_string(), "AND".to_string(), "AS".to_string(), "COLLATE".to_string(), "IS".to_string(), "ON".to_string(), "OR".to_string(), "PIVOT".to_string(), "UNPIVOT".to_string(), "USING".to_string(), "[".to_string(), "^".to_string(), "|".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["glob_operator".to_string(), "json_operator".to_string(), "like_operator".to_string()]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: false,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='OperatorKeywordSegment'
pub static OPERATOR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OPERATOR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OptimizeKeywordSegment'
pub static OPTIMIZE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OPTIMIZE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OptionKeywordSegment'
pub static OPTION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OPTION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OptionallyKeywordSegment'
pub static OPTIONALLY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OPTIONALLY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OptionsGrammar'
pub static OPTIONS_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OptionsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OPTIONS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OptionsListGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string(), "word".to_string()]),
        }),
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string(), "word".to_string()]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OPTIONS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='OptionsKeywordSegment'
pub static OPTIONS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OPTIONS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OptionsListGrammar'
pub static OPTIONS_LIST_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NakedIdentifierFullSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["word".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string(), "word".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string(), "word".to_string()]),
        }),
})
);

// name='OrIgnoreGrammar'
pub static OR_IGNORE_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OrKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IgnoreKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IGNORE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='OrKeywordSegment'
pub static OR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OrOperatorGrammar'
pub static OR_OPERATOR_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OR",
    token_type: "binary_operator",
    raw_class: "BinaryOperatorSegment",
    optional: false,
})
);

// name='OrReplaceGrammar'
pub static OR_REPLACE_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OrKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ReplaceKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REPLACE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='OrderByClauseSegment'
pub static ORDER_BY_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// OrderByClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OrderKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AllKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AscKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ASC".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DescKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DESC".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ASC".to_string(), "DESC".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NullsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NULLS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FirstKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FIRST".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LastKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LAST".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FIRST".to_string(), "LAST".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NULLS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: true,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "OrderByClauseTerminators",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOR".to_string(), "GROUPS".to_string(), "HAVING".to_string(), "LIMIT".to_string(), "QUALIFY".to_string(), "RANGE".to_string(), "ROWS".to_string(), "SEPARATOR".to_string(), "WINDOW".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("dedent"))
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='OrderByClauseTerminators'
pub static ORDER_BY_CLAUSE_TERMINATORS: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LimitKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LIMIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "HavingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["HAVING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QualifyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["QUALIFY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WindowKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WINDOW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FrameClauseUnitGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUPS".to_string(), "RANGE".to_string(), "ROWS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SeparatorKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SEPARATOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DataKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ForClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOR".to_string(), "GROUPS".to_string(), "HAVING".to_string(), "LIMIT".to_string(), "QUALIFY".to_string(), "RANGE".to_string(), "ROWS".to_string(), "SEPARATOR".to_string(), "WINDOW".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='OrderKeywordSegment'
pub static ORDER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ORDER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OrderNoOrderGrammar'
pub static ORDER_NO_ORDER_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OrderKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NoorderKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOORDER".to_string(), "ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='OrdinalityKeywordSegment'
pub static ORDINALITY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ORDINALITY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OthersKeywordSegment'
pub static OTHERS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OTHERS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OutKeywordSegment'
pub static OUT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OUT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OuterKeywordSegment'
pub static OUTER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OUTER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OutfileKeywordSegment'
pub static OUTFILE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OUTFILE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OverClauseSegment'
pub static OVER_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// OverClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::Ref {
    name: "IgnoreRespectNullsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IGNORE".to_string(), "RESPECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OverKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OVER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WindowSpecificationSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Greedy,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("dedent"))
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='OverKeywordSegment'
pub static OVER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OVER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OverlapSegment'
pub static OVERLAP_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// OverlapSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AmpersandSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["&".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AmpersandSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["&".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: false,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["&".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='OverlapsClauseSegment'
pub static OVERLAPS_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// OverlapsClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DateTimeLiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATE".to_string(), "INTERVAL".to_string(), "TIME".to_string(), "TIMESTAMP".to_string(), "TIMESTAMPTZ".to_string(), "TIMETZ".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ShorthandCastSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "FunctionContentsExpressionGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DateTimeLiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATE".to_string(), "INTERVAL".to_string(), "TIME".to_string(), "TIMESTAMP".to_string(), "TIMESTAMPTZ".to_string(), "TIMETZ".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ShorthandCastSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "FunctionContentsExpressionGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "OverlapsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OVERLAPS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DateTimeLiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATE".to_string(), "INTERVAL".to_string(), "TIME".to_string(), "TIMESTAMP".to_string(), "TIMESTAMPTZ".to_string(), "TIMETZ".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ShorthandCastSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "FunctionContentsExpressionGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DateTimeLiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATE".to_string(), "INTERVAL".to_string(), "TIME".to_string(), "TIMESTAMP".to_string(), "TIMESTAMPTZ".to_string(), "TIMETZ".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ShorthandCastSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "FunctionContentsExpressionGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='OverlapsKeywordSegment'
pub static OVERLAPS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OVERLAPS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OverlayKeywordSegment'
pub static OVERLAY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OVERLAY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OverridingKeywordSegment'
pub static OVERRIDING_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OVERRIDING",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OverwriteKeywordSegment'
pub static OVERWRITE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OVERWRITE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Overwrite_or_ignoreKeywordSegment'
pub static OVERWRITE_OR_IGNORE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OVERWRITE_OR_IGNORE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OwnedKeywordSegment'
pub static OWNED_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OWNED",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OwnerKeywordSegment'
pub static OWNER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OWNER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='OwnershipKeywordSegment'
pub static OWNERSHIP_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "OWNERSHIP",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Pack_keysKeywordSegment'
pub static PACK_KEYS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PACK_KEYS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ParallelKeywordSegment'
pub static PARALLEL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PARALLEL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ParameterNameSegment'
pub static PARAMETER_NAME_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::RegexParser {
    template: RegexMode::new(r#"[A-Z_][A-Z0-9_$]*|"[^"]*""#),
    token_type: "parameter",
    raw_class: "CodeSegment",
    optional: false,
    anti_template: None,
})
);

// name='ParameterSegment'
pub static PARAMETER_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "?",
    token_type: "parameter",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='ParametersKeywordSegment'
pub static PARAMETERS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PARAMETERS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Parquet_versionKeywordSegment'
pub static PARQUET_VERSION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PARQUET_VERSION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ParserKeywordSegment'
pub static PARSER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PARSER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PartialKeywordSegment'
pub static PARTIAL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PARTIAL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PartitionBoundSpecSegment'
pub static PARTITION_BOUND_SPEC_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// PartitionBoundSpecSegment
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "InKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FromKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "MinvalueKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MINVALUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MaxvalueKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MAXVALUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "MinvalueKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MINVALUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MaxvalueKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MAXVALUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ModulusKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MODULUS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RemainderKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REMAINDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MODULUS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string(), "IN".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='PartitionClauseSegment'
pub static PARTITION_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// PartitionClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PartitionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PARTITION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("dedent"))
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PARTITION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='PartitionKeywordSegment'
pub static PARTITION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PARTITION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Partition_byKeywordSegment'
pub static PARTITION_BY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PARTITION_BY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PassingKeywordSegment'
pub static PASSING_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PASSING",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PasswordKeywordSegment'
pub static PASSWORD_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PASSWORD",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PathKeywordSegment'
pub static PATH_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PATH",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PathSegment'
pub static PATH_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// PathSegment
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SlashSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["/".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::TypedParser {
    template: "word",
    token_type: "path_segment",
    raw_class: "WordSegment",
    optional: false,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "SlashSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["/".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: false,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["word".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["/".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["/".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
);

// name='PatternMatchingGrammar'
pub static PATTERN_MATCHING_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Nothing())
);

// name='PctfreeKeywordSegment'
pub static PCTFREE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PCTFREE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PermissiveKeywordSegment'
pub static PERMISSIVE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PERMISSIVE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PgTrgmOperatorSegment'
pub static PG_TRGM_OPERATOR_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::TypedParser {
    template: "pg_trgm_operator",
    token_type: "binary_operator",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='Pg_lsnKeywordSegment'
pub static PG_LSN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PG_LSN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PgvectorOperatorSegment'
pub static PGVECTOR_OPERATOR_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::TypedParser {
    template: "pgvector_operator",
    token_type: "binary_operator",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='PipeKeywordSegment'
pub static PIPE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PIPE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PipeSegment'
pub static PIPE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "|",
    token_type: "pipe",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='PivotKeywordSegment'
pub static PIVOT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PIVOT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Pivot_longerKeywordSegment'
pub static PIVOT_LONGER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PIVOT_LONGER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Pivot_widerKeywordSegment'
pub static PIVOT_WIDER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PIVOT_WIDER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PlacingKeywordSegment'
pub static PLACING_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PLACING",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PlainKeywordSegment'
pub static PLAIN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PLAIN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PlansKeywordSegment'
pub static PLANS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PLANS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PlusSegment'
pub static PLUS_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "+",
    token_type: "binary_operator",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='PointKeywordSegment'
pub static POINT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "POINT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PointmKeywordSegment'
pub static POINTM_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "POINTM",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PointzKeywordSegment'
pub static POINTZ_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "POINTZ",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PointzmKeywordSegment'
pub static POINTZM_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "POINTZM",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PolicyKeywordSegment'
pub static POLICY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "POLICY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PolygonKeywordSegment'
pub static POLYGON_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "POLYGON",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PolygonmKeywordSegment'
pub static POLYGONM_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "POLYGONM",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PolygonzKeywordSegment'
pub static POLYGONZ_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "POLYGONZ",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PolygonzmKeywordSegment'
pub static POLYGONZM_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "POLYGONZM",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PolyhedralsurfaceKeywordSegment'
pub static POLYHEDRALSURFACE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "POLYHEDRALSURFACE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PositionKeywordSegment'
pub static POSITION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "POSITION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PositionalKeywordSegment'
pub static POSITIONAL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "POSITIONAL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PositiveSegment'
pub static POSITIVE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "+",
    token_type: "sign_indicator",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='PostFunctionGrammar'
pub static POST_FUNCTION_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithinGroupClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITHIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OverClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "FilterClauseGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FILTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='PostTableExpressionGrammar'
pub static POST_TABLE_EXPRESSION_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Nothing())
);

// name='PostfixKeywordSegment'
pub static POSTFIX_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "POSTFIX",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PostgisOperatorSegment'
pub static POSTGIS_OPERATOR_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::TypedParser {
    template: "postgis_operator",
    token_type: "binary_operator",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='PreTableFunctionKeywordsGrammar'
pub static PRE_TABLE_FUNCTION_KEYWORDS_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LateralKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LATERAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LATERAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='PrecedingKeywordSegment'
pub static PRECEDING_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PRECEDING",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PrecisionKeywordSegment'
pub static PRECISION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PRECISION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PrefixKeywordSegment'
pub static PREFIX_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PREFIX",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PreorderKeywordSegment'
pub static PREORDER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PREORDER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PrepareKeywordSegment'
pub static PREPARE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PREPARE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PrepareStatementSegment'
pub static PREPARE_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// PrepareStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PrepareKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PREPARE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DatatypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SelectableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "DELETE".to_string(), "FROM".to_string(), "INSERT".to_string(), "PIVOT".to_string(), "PIVOT_LONGER".to_string(), "PIVOT_WIDER".to_string(), "SELECT".to_string(), "UNPIVOT".to_string(), "UPDATE".to_string(), "VALUES".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MergeStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MERGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "DELETE".to_string(), "FROM".to_string(), "INSERT".to_string(), "MERGE".to_string(), "PIVOT".to_string(), "PIVOT_LONGER".to_string(), "PIVOT_WIDER".to_string(), "SELECT".to_string(), "UNPIVOT".to_string(), "UPDATE".to_string(), "VALUES".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PREPARE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='PreparedKeywordSegment'
pub static PREPARED_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PREPARED",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PreserveKeywordSegment'
pub static PRESERVE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PRESERVE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PrimaryKeyGrammar'
pub static PRIMARY_KEY_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PrimaryKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PRIMARY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "KeyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["KEY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PRIMARY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='PrimaryKeywordSegment'
pub static PRIMARY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PRIMARY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PrintKeywordSegment'
pub static PRINT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PRINT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PriorKeywordSegment'
pub static PRIOR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PRIOR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PrivilegesKeywordSegment'
pub static PRIVILEGES_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PRIVILEGES",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ProcKeywordSegment'
pub static PROC_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PROC",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ProceduralKeywordSegment'
pub static PROCEDURAL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PROCEDURAL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ProcedureKeywordSegment'
pub static PROCEDURE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PROCEDURE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ProceduresKeywordSegment'
pub static PROCEDURES_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PROCEDURES",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ProcessKeywordSegment'
pub static PROCESS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PROCESS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Process_toastKeywordSegment'
pub static PROCESS_TOAST_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PROCESS_TOAST",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ProcesslistKeywordSegment'
pub static PROCESSLIST_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PROCESSLIST",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ProgramKeywordSegment'
pub static PROGRAM_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PROGRAM",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PropertiesNakedIdentifierSegment'
pub static PROPERTIES_NAKED_IDENTIFIER_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::TypedParser {
    template: "word",
    token_type: "properties_naked_identifier",
    raw_class: "CodeSegment",
    optional: false,
})
);

// name='ProviderKeywordSegment'
pub static PROVIDER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PROVIDER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PsqlVariableGrammar'
pub static PSQL_VARIABLE_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
// PsqlVariableGrammar
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColonSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([":".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColonSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([":".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([":".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), ":".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), ":".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='PublicKeywordSegment'
pub static PUBLIC_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PUBLIC",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PublicationKeywordSegment'
pub static PUBLICATION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PUBLICATION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='PublicationObjectsSegment'
pub static PUBLICATION_OBJECTS_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// PublicationObjectsSegment
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PublicationTableSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TablesKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string(), "TABLES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TablesKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "InKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SchemaReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "Current_schemaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TablesKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string(), "TABLES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string(), "TABLES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='PublicationReferenceSegment'
pub static PUBLICATION_REFERENCE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// PublicationReferenceSegment
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
);

// name='PublicationTableSegment'
pub static PUBLICATION_TABLE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// PublicationTableSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExtendedTableReferenceGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "BracketedColumnReferenceListGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WhereKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHERE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHERE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='PurgeKeywordSegment'
pub static PURGE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "PURGE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='QualifiedNumericLiteralSegment'
pub static QUALIFIED_NUMERIC_LITERAL_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// QualifiedNumericLiteralSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SignedSegmentGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["+".to_string(), "-".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["+".to_string(), "-".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='QualifiedOperatorSegment'
pub static QUALIFIED_OPERATOR_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// QualifiedOperatorSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OperatorKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OPERATOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NakedIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DotSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::RegexParser {
    template: RegexMode::new(r#"[!<>=~@#%^&|`?+\-*/]+"#),
    token_type: "operator",
    raw_class: "SymbolSegment",
    optional: false,
    anti_template: None,
})
,
    ],
    min_times: 1,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OPERATOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='QualifyClauseSegment'
pub static QUALIFY_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// QualifyClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "QualifyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["QUALIFY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("dedent"))
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["QUALIFY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='QualifyKeywordSegment'
pub static QUALIFY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "QUALIFY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='QuarterKeywordSegment'
pub static QUARTER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "QUARTER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='QuoteKeywordSegment'
pub static QUOTE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "QUOTE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='QuotedIdentifierSegment'
pub static QUOTED_IDENTIFIER_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::TypedParser {
    template: "double_quote",
    token_type: "quoted_identifier",
    raw_class: "IdentifierSegment",
    optional: false,
})
);

// name='QuotedLiteralSegment'
pub static QUOTED_LITERAL_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::TypedParser {
    template: "single_quote",
    token_type: "quoted_literal",
    raw_class: "LiteralSegment",
    optional: false,
})
,
Arc::new(Grammar::TypedParser {
    template: "escaped_single_quote",
    token_type: "quoted_literal",
    raw_class: "LiteralSegment",
    optional: false,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["escaped_single_quote".to_string(), "single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "MultilineConcatenateDelimiterGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["newline".to_string()]),
        }),
})
,
Arc::new(Grammar::TypedParser {
    template: "single_quote",
    token_type: "quoted_literal",
    raw_class: "LiteralSegment",
    optional: false,
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["newline".to_string(), "single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["escaped_single_quote".to_string(), "single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::TypedParser {
    template: "bit_string_literal",
    token_type: "quoted_literal",
    raw_class: "LiteralSegment",
    optional: false,
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "MultilineConcatenateDelimiterGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["newline".to_string()]),
        }),
})
,
Arc::new(Grammar::RegexParser {
    template: RegexMode::new(r#"(?i)'[0-9a-f]*'"#),
    token_type: "quoted_literal",
    raw_class: "LiteralSegment",
    optional: false,
    anti_template: None,
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string()]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::TypedParser {
    template: "unicode_single_quote",
    token_type: "quoted_literal",
    raw_class: "LiteralSegment",
    optional: false,
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "MultilineConcatenateDelimiterGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["newline".to_string()]),
        }),
})
,
Arc::new(Grammar::RegexParser {
    template: RegexMode::new(r#"'([^']|'')*'"#),
    token_type: "quoted_literal",
    raw_class: "LiteralSegment",
    optional: false,
    anti_template: None,
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "UescapeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UESCAPE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::RegexParser {
    template: RegexMode::new(r#"'[^0-9A-Fa-f'+\-\s)]'"#),
    token_type: "unicode_escape_value",
    raw_class: "CodeSegment",
    optional: false,
    anti_template: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UESCAPE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["unicode_single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::TypedParser {
    template: "dollar_quote",
    token_type: "quoted_literal",
    raw_class: "LiteralSegment",
    optional: false,
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "MultilineConcatenateDelimiterGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["newline".to_string()]),
        }),
})
,
Arc::new(Grammar::TypedParser {
    template: "dollar_quote",
    token_type: "quoted_literal",
    raw_class: "LiteralSegment",
    optional: false,
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["dollar_quote".to_string(), "newline".to_string()]),
        }),
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["dollar_quote".to_string(), "newline".to_string()]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
);

// name='Raid0KeywordSegment'
pub static RAID0_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "RAID0",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RaiserrorKeywordSegment'
pub static RAISERROR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "RAISERROR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RangeKeywordSegment'
pub static RANGE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "RANGE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RawEqualsSegment'
pub static RAW_EQUALS_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "=",
    token_type: "raw_comparison_operator",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='RawGreaterThanSegment'
pub static RAW_GREATER_THAN_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: ">",
    token_type: "raw_comparison_operator",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='RawKeywordSegment'
pub static RAW_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "RAW",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RawLessThanSegment'
pub static RAW_LESS_THAN_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "<",
    token_type: "raw_comparison_operator",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='RawNotSegment'
pub static RAW_NOT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "!",
    token_type: "raw_comparison_operator",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='RawSegment'
pub static RAW_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Token{
    token_type: "raw",
//    token_type: "RawSegment",
})
);

// name='ReadKeywordSegment'
pub static READ_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "READ",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ReadtextKeywordSegment'
pub static READTEXT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "READTEXT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RealKeywordSegment'
pub static REAL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "REAL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ReassignKeywordSegment'
pub static REASSIGN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "REASSIGN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ReassignOwnedStatementSegment'
pub static REASSIGN_OWNED_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ReassignOwnedStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ReassignKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REASSIGN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OwnedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OWNED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "Current_roleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_ROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Current_userKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Session_userKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SESSION_USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RoleReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "Current_roleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_ROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Current_userKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Session_userKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SESSION_USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RoleReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REASSIGN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='RecheckKeywordSegment'
pub static RECHECK_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "RECHECK",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ReconfigureKeywordSegment'
pub static RECONFIGURE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "RECONFIGURE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RecursiveKeywordSegment'
pub static RECURSIVE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "RECURSIVE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RefKeywordSegment'
pub static REF_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "REF",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ReferenceDefinitionGrammar'
pub static REFERENCE_DEFINITION_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ReferencesKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REFERENCES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "BracketedColumnReferenceListGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ReferenceMatchGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MATCH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::AnySetOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DeleteKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DELETE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ReferentialActionGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string(), "NO".to_string(), "RESTRICT".to_string(), "SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UpdateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UPDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ReferentialActionGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string(), "NO".to_string(), "RESTRICT".to_string(), "SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 0,
    max_times: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REFERENCES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ReferenceMatchGrammar'
pub static REFERENCE_MATCH_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "MatchKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MATCH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FullKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PartialKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PARTIAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SimpleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SIMPLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FULL".to_string(), "PARTIAL".to_string(), "SIMPLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MATCH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='Reference_usageKeywordSegment'
pub static REFERENCE_USAGE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "REFERENCE_USAGE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ReferencesKeywordSegment'
pub static REFERENCES_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "REFERENCES",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ReferencingKeywordSegment'
pub static REFERENCING_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "REFERENCING",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ReferentialActionGrammar'
pub static REFERENTIAL_ACTION_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CascadeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DefaultKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NullKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string(), "NULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RestrictKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NoKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ActionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ACTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string(), "NO".to_string(), "RESTRICT".to_string(), "SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='RefreshKeywordSegment'
pub static REFRESH_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "REFRESH",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RefreshMaterializedViewStatementSegment'
pub static REFRESH_MATERIALIZED_VIEW_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// RefreshMaterializedViewStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RefreshKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REFRESH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MaterializedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MATERIALIZED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ViewKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VIEW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConcurrentlyKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONCURRENTLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "WithDataClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REFRESH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='RegexpKeywordSegment'
pub static REGEXP_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "REGEXP",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ReindexKeywordSegment'
pub static REINDEX_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "REINDEX",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ReindexStatementSegment'
pub static REINDEX_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ReindexStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ReindexKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REINDEX".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ConcurrentlyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONCURRENTLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BooleanLiteralGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FALSE".to_string(), "TRUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONCURRENTLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TablespaceKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLESPACE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TablespaceReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLESPACE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "VerboseKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VERBOSE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BooleanLiteralGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FALSE".to_string(), "TRUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VERBOSE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONCURRENTLY".to_string(), "TABLESPACE".to_string(), "VERBOSE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IndexKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INDEX".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConcurrentlyKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONCURRENTLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IndexReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INDEX".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConcurrentlyKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONCURRENTLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SchemaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConcurrentlyKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONCURRENTLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DatabaseKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATABASE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SystemKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SYSTEM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATABASE".to_string(), "SYSTEM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConcurrentlyKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONCURRENTLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DatabaseReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATABASE".to_string(), "SYSTEM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATABASE".to_string(), "INDEX".to_string(), "SCHEMA".to_string(), "SYSTEM".to_string(), "TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REINDEX".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='RelationOptionSegment'
pub static RELATION_OPTION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// RelationOptionSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PropertiesNakedIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["word".to_string()]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DotSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PropertiesNakedIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["word".to_string()]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DefinitionArgumentValueGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "+".to_string(), "-".to_string(), ":".to_string(), "ARRAY".to_string(), "DATE".to_string(), "FALSE".to_string(), "INTERVAL".to_string(), "NULL".to_string(), "TIME".to_string(), "TIMESTAMP".to_string(), "TIMESTAMPTZ".to_string(), "TIMETZ".to_string(), "TRUE".to_string(), "VARIADIC".to_string(), "[".to_string(), "{".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_numeric_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "numeric_literal".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string(), "word".to_string()]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["word".to_string()]),
        }),
})
);

// name='RelationOptionsSegment'
pub static RELATION_OPTIONS_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// RelationOptionsSegment
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RelationOptionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["word".to_string()]),
        }),
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["word".to_string()]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='RelativeKeywordSegment'
pub static RELATIVE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "RELATIVE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ReleaseKeywordSegment'
pub static RELEASE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "RELEASE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ReloadKeywordSegment'
pub static RELOAD_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "RELOAD",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RemainderKeywordSegment'
pub static REMAINDER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "REMAINDER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RenameKeywordSegment'
pub static RENAME_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "RENAME",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RepeatKeywordSegment'
pub static REPEAT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "REPEAT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RepeatableKeywordSegment'
pub static REPEATABLE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "REPEATABLE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ReplaceKeywordSegment'
pub static REPLACE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "REPLACE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ReplicaKeywordSegment'
pub static REPLICA_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "REPLICA",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ReplicationKeywordSegment'
pub static REPLICATION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "REPLICATION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RequireKeywordSegment'
pub static REQUIRE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "REQUIRE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ResetKeywordSegment'
pub static RESET_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "RESET",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ResetSessionAuthorizationStatementSegment'
pub static RESET_SESSION_AUTHORIZATION_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ResetSessionAuthorizationStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ResetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SessionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SESSION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AuthorizationKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AUTHORIZATION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ResetStatementSegment'
pub static RESET_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ResetStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ResetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AllKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RoleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ResignalKeywordSegment'
pub static RESIGNAL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "RESIGNAL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ResourceKeywordSegment'
pub static RESOURCE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "RESOURCE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RespectKeywordSegment'
pub static RESPECT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "RESPECT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RestartKeywordSegment'
pub static RESTART_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "RESTART",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RestrictKeywordSegment'
pub static RESTRICT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "RESTRICT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RestrictedKeywordSegment'
pub static RESTRICTED_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "RESTRICTED",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RestrictiveKeywordSegment'
pub static RESTRICTIVE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "RESTRICTIVE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RetrieveKeywordSegment'
pub static RETRIEVE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "RETRIEVE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ReturnKeywordSegment'
pub static RETURN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "RETURN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ReturningKeywordSegment'
pub static RETURNING_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "RETURNING",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ReturnsKeywordSegment'
pub static RETURNS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "RETURNS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RevokeKeywordSegment'
pub static REVOKE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "REVOKE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RightArrowSegment'
pub static RIGHT_ARROW_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "=>",
    token_type: "right_arrow",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='RightKeywordSegment'
pub static RIGHT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "RIGHT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RightargKeywordSegment'
pub static RIGHTARG_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "RIGHTARG",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RlikeKeywordSegment'
pub static RLIKE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "RLIKE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RoleKeywordSegment'
pub static ROLE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ROLE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RoleReferenceSegment'
pub static ROLE_REFERENCE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// RoleReferenceSegment
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
);

// name='RolesKeywordSegment'
pub static ROLES_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ROLES",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RollbackKeywordSegment'
pub static ROLLBACK_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ROLLBACK",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RollupFunctionNameSegment'
pub static ROLLUP_FUNCTION_NAME_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// RollupFunctionNameSegment
Arc::new(Grammar::StringParser {
    template: "ROLLUP",
    token_type: "function_name_identifier",
    raw_class: "CodeSegment",
    optional: false,
})
);

// name='RollupKeywordSegment'
pub static ROLLUP_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ROLLUP",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RoutineKeywordSegment'
pub static ROUTINE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ROUTINE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RoutinesKeywordSegment'
pub static ROUTINES_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ROUTINES",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RowKeywordSegment'
pub static ROW_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ROW",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Row_group_sizeKeywordSegment'
pub static ROW_GROUP_SIZE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ROW_GROUP_SIZE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Row_group_size_bytesKeywordSegment'
pub static ROW_GROUP_SIZE_BYTES_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ROW_GROUP_SIZE_BYTES",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RowcountKeywordSegment'
pub static ROWCOUNT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ROWCOUNT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RowguidcolKeywordSegment'
pub static ROWGUIDCOL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ROWGUIDCOL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RowidKeywordSegment'
pub static ROWID_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ROWID",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RownumKeywordSegment'
pub static ROWNUM_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ROWNUM",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RowsKeywordSegment'
pub static ROWS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ROWS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='RuleKeywordSegment'
pub static RULE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "RULE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SafeKeywordSegment'
pub static SAFE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SAFE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SamplingExpressionSegment'
pub static SAMPLING_EXPRESSION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// SamplingExpressionSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TablesampleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLESAMPLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "BernoulliKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BERNOULLI".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SystemKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SYSTEM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BERNOULLI".to_string(), "SYSTEM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RepeatableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REPEATABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REPEATABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REPEATABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLESAMPLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='SaveKeywordSegment'
pub static SAVE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SAVE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SavepointKeywordSegment'
pub static SAVEPOINT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SAVEPOINT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ScalarKeywordSegment'
pub static SCALAR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SCALAR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SchemaKeywordSegment'
pub static SCHEMA_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SCHEMA",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SchemaReferenceSegment'
pub static SCHEMA_REFERENCE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// SchemaReferenceSegment
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "ObjectReferenceDelimiterGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "ObjectReferenceTerminatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["!".to_string(), "%".to_string(), "&".to_string(), "(".to_string(), "*".to_string(), "+".to_string(), ",".to_string(), "-".to_string(), "/".to_string(), "//".to_string(), ":".to_string(), "::".to_string(), ";".to_string(), "<".to_string(), "=".to_string(), "==".to_string(), ">".to_string(), "AND".to_string(), "AS".to_string(), "COLLATE".to_string(), "IS".to_string(), "ON".to_string(), "OR".to_string(), "PIVOT".to_string(), "UNPIVOT".to_string(), "USING".to_string(), "[".to_string(), "^".to_string(), "|".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["glob_operator".to_string(), "json_operator".to_string(), "like_operator".to_string()]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: false,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='SchemasKeywordSegment'
pub static SCHEMAS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SCHEMAS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ScrollKeywordSegment'
pub static SCROLL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SCROLL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SearchKeywordSegment'
pub static SEARCH_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SEARCH",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SecondKeywordSegment'
pub static SECOND_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SECOND",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Second_microsecondKeywordSegment'
pub static SECOND_MICROSECOND_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SECOND_MICROSECOND",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SecurityKeywordSegment'
pub static SECURITY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SECURITY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SecurityLabelStatementSegment'
pub static SECURITY_LABEL_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// SecurityLabelStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SecurityKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SECURITY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LabelKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LABEL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ForKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColumnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLUMN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLUMN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AggregateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AGGREGATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FunctionParameterListGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AGGREGATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DatabaseKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATABASE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DatabaseReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATABASE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DomainKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DOMAIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DOMAIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "EventKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EVENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TriggerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TRIGGER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EVENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ForeignKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOREIGN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOREIGN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FunctionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FUNCTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FunctionParameterGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionParameterGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FUNCTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LargeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LARGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OBJECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LARGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "MaterializedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MATERIALIZED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ViewKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VIEW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MATERIALIZED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ProceduralKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PROCEDURAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LanguageKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LANGUAGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LANGUAGE".to_string(), "PROCEDURAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ProcedureKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PROCEDURE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FunctionParameterGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionParameterGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PROCEDURE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PublicationKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PUBLICATION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PUBLICATION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RoleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RoleReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RoutineKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROUTINE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FunctionParameterGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionParameterGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROUTINE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SchemaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SequenceKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SEQUENCE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SEQUENCE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SubscriptionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SUBSCRIPTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SUBSCRIPTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TablespaceKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLESPACE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLESPACE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TypeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TYPE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TYPE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ViewKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VIEW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VIEW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AGGREGATE".to_string(), "COLUMN".to_string(), "DATABASE".to_string(), "DOMAIN".to_string(), "EVENT".to_string(), "FOREIGN".to_string(), "FUNCTION".to_string(), "LANGUAGE".to_string(), "LARGE".to_string(), "MATERIALIZED".to_string(), "PROCEDURAL".to_string(), "PROCEDURE".to_string(), "PUBLICATION".to_string(), "ROLE".to_string(), "ROUTINE".to_string(), "SCHEMA".to_string(), "SEQUENCE".to_string(), "SUBSCRIPTION".to_string(), "TABLE".to_string(), "TABLESPACE".to_string(), "TYPE".to_string(), "VIEW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NullKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SECURITY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='SelectClauseElementSegment'
pub static SELECT_CLAUSE_ELEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// SelectClauseElementSegment
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WildcardExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "BaseExpressionElementGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AliasExpressionSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='SelectClauseModifierSegment'
pub static SELECT_CLAUSE_MODIFIER_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// SelectClauseModifierSegment
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DistinctKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DISTINCT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DISTINCT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AllKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string(), "DISTINCT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='SelectClauseSegment'
pub static SELECT_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// SelectClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SelectKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SELECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SelectClauseModifierSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string(), "DISTINCT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SelectClauseElementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: true,
    optional: true,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("dedent"))
,
    ],
    optional: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "IntoKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INTO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FromKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WhereKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHERE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OrderKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConflictKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONFLICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LimitKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LIMIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ReturningKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RETURNING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OverlapsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OVERLAPS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SetOperatorSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCEPT".to_string(), "INTERSECT".to_string(), "MINUS".to_string(), "UNION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NoKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DataKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WithCheckOptionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MetaCommandQueryBufferSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["meta_command_query_buffer".to_string()]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::GreedyOnceStarted,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SELECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='SelectClauseTerminatorGrammar'
pub static SELECT_CLAUSE_TERMINATOR_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IntoKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INTO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FromKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WhereKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHERE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OrderKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LimitKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LIMIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ReturningKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RETURNING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SetOperatorSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCEPT".to_string(), "INTERSECT".to_string(), "MINUS".to_string(), "UNION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MetaCommandQueryBufferSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["meta_command_query_buffer".to_string()]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string(), "EXCEPT".to_string(), "FROM".to_string(), "INTERSECT".to_string(), "INTO".to_string(), "LIMIT".to_string(), "MINUS".to_string(), "ORDER".to_string(), "RETURNING".to_string(), "UNION".to_string(), "WHERE".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["meta_command_query_buffer".to_string()]),
        }),
})
);

// name='SelectKeywordSegment'
pub static SELECT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SELECT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SelectStatementSegment'
pub static SELECT_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// SelectStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SelectClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SELECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FromClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WhereClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHERE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "GroupByClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "HavingClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["HAVING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OverlapsClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "NamedWindowSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WINDOW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QualifyClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["QUALIFY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OrderByClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OffsetClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OFFSET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FetchClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FETCH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LimitClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LIMIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NamedWindowSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WINDOW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "SetOperatorSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCEPT".to_string(), "INTERSECT".to_string(), "MINUS".to_string(), "UNION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WithNoSchemaBindingClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WithDataClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConflictKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONFLICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ReturningKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RETURNING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WithCheckOptionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MetaCommandQueryBufferSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["meta_command_query_buffer".to_string()]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::GreedyOnceStarted,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SELECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='SelectableGrammar'
pub static SELECTABLE_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithCompoundStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WithCompoundStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithCompoundNonSelectStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WithCompoundNonSelectStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NonWithSelectableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "DELETE".to_string(), "FROM".to_string(), "INSERT".to_string(), "PIVOT".to_string(), "PIVOT_LONGER".to_string(), "PIVOT_WIDER".to_string(), "SELECT".to_string(), "UNPIVOT".to_string(), "UPDATE".to_string(), "VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SelectableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "DELETE".to_string(), "FROM".to_string(), "INSERT".to_string(), "PIVOT".to_string(), "PIVOT_LONGER".to_string(), "PIVOT_WIDER".to_string(), "SELECT".to_string(), "UNPIVOT".to_string(), "UPDATE".to_string(), "VALUES".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "DELETE".to_string(), "FROM".to_string(), "INSERT".to_string(), "PIVOT".to_string(), "PIVOT_LONGER".to_string(), "PIVOT_WIDER".to_string(), "SELECT".to_string(), "UNPIVOT".to_string(), "UPDATE".to_string(), "VALUES".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='SemiKeywordSegment'
pub static SEMI_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SEMI",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SemiStructuredAccessorSegment'
pub static SEMI_STRUCTURED_ACCESSOR_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// SemiStructuredAccessorSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DotSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ArrayAccessorSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["[".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DotSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ArrayAccessorSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["[".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string(), "[".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='SemicolonSegment'
pub static SEMICOLON_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: ";",
    token_type: "statement_terminator",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='SeparatorKeywordSegment'
pub static SEPARATOR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SEPARATOR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SequenceKeywordSegment'
pub static SEQUENCE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SEQUENCE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SequenceMaxValueGrammar'
pub static SEQUENCE_MAX_VALUE_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "MaxvalueKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MAXVALUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MAXVALUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NoKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MaxvalueKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MAXVALUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MAXVALUE".to_string(), "NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='SequenceMinValueGrammar'
pub static SEQUENCE_MIN_VALUE_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "MinvalueKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MINVALUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MINVALUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NoKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MinvalueKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MINVALUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MINVALUE".to_string(), "NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='SequenceReferenceSegment'
pub static SEQUENCE_REFERENCE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// SequenceReferenceSegment
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "ObjectReferenceDelimiterGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "ObjectReferenceTerminatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["!".to_string(), "%".to_string(), "&".to_string(), "(".to_string(), "*".to_string(), "+".to_string(), ",".to_string(), "-".to_string(), "/".to_string(), "//".to_string(), ":".to_string(), "::".to_string(), ";".to_string(), "<".to_string(), "=".to_string(), "==".to_string(), ">".to_string(), "AND".to_string(), "AS".to_string(), "COLLATE".to_string(), "IS".to_string(), "ON".to_string(), "OR".to_string(), "PIVOT".to_string(), "UNPIVOT".to_string(), "USING".to_string(), "[".to_string(), "^".to_string(), "|".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["glob_operator".to_string(), "json_operator".to_string(), "like_operator".to_string()]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: false,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='SequencesKeywordSegment'
pub static SEQUENCES_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SEQUENCES",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Serial2KeywordSegment'
pub static SERIAL2_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SERIAL2",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Serial4KeywordSegment'
pub static SERIAL4_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SERIAL4",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Serial8KeywordSegment'
pub static SERIAL8_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SERIAL8",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SerialKeywordSegment'
pub static SERIAL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SERIAL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SerializableKeywordSegment'
pub static SERIALIZABLE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SERIALIZABLE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ServerKeywordSegment'
pub static SERVER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SERVER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ServerReferenceSegment'
pub static SERVER_REFERENCE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ServerReferenceSegment
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "ObjectReferenceDelimiterGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "ObjectReferenceTerminatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["!".to_string(), "%".to_string(), "&".to_string(), "(".to_string(), "*".to_string(), "+".to_string(), ",".to_string(), "-".to_string(), "/".to_string(), "//".to_string(), ":".to_string(), "::".to_string(), ";".to_string(), "<".to_string(), "=".to_string(), "==".to_string(), ">".to_string(), "AND".to_string(), "AS".to_string(), "COLLATE".to_string(), "IS".to_string(), "ON".to_string(), "OR".to_string(), "PIVOT".to_string(), "UNPIVOT".to_string(), "USING".to_string(), "[".to_string(), "^".to_string(), "|".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["glob_operator".to_string(), "json_operator".to_string(), "like_operator".to_string()]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: false,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='Server_encodingKeywordSegment'
pub static SERVER_ENCODING_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SERVER_ENCODING",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Server_versionKeywordSegment'
pub static SERVER_VERSION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SERVER_VERSION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SessionInformationUserFunctionsGrammar'
pub static SESSION_INFORMATION_USER_FUNCTIONS_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "UserKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Current_roleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_ROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Current_userKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Session_userKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SESSION_USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_ROLE".to_string(), "CURRENT_USER".to_string(), "SESSION_USER".to_string(), "USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='SessionKeywordSegment'
pub static SESSION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SESSION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Session_userKeywordSegment'
pub static SESSION_USER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SESSION_USER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SetClauseListSegment'
pub static SET_CLAUSE_LIST_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// SetClauseListSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("dedent"))
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='SetClauseSegment'
pub static SET_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// SetClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ArrayAccessorSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["[".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "+".to_string(), "-".to_string(), ":".to_string(), "ARRAY".to_string(), "DATE".to_string(), "FALSE".to_string(), "INTERVAL".to_string(), "NULL".to_string(), "TIME".to_string(), "TIMESTAMP".to_string(), "TIMESTAMPTZ".to_string(), "TIMETZ".to_string(), "TRUE".to_string(), "VARIADIC".to_string(), "[".to_string(), "{".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_numeric_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "numeric_literal".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BareFunctionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_CATALOG".to_string(), "CURRENT_DATE".to_string(), "CURRENT_ROLE".to_string(), "CURRENT_SCHEMA".to_string(), "CURRENT_TIME".to_string(), "CURRENT_TIMESTAMP".to_string(), "CURRENT_USER".to_string(), "LOCALTIME".to_string(), "LOCALTIMESTAMP".to_string(), "SESSION_USER".to_string(), "SYSTEM_USER".to_string(), "USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DefaultKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ShorthandCastSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SelectableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "DELETE".to_string(), "FROM".to_string(), "INSERT".to_string(), "PIVOT".to_string(), "PIVOT_LONGER".to_string(), "PIVOT_WIDER".to_string(), "SELECT".to_string(), "UNPIVOT".to_string(), "UPDATE".to_string(), "VALUES".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "+".to_string(), "-".to_string(), ":".to_string(), "ARRAY".to_string(), "DATE".to_string(), "FALSE".to_string(), "INTERVAL".to_string(), "NULL".to_string(), "TIME".to_string(), "TIMESTAMP".to_string(), "TIMESTAMPTZ".to_string(), "TIMETZ".to_string(), "TRUE".to_string(), "VARIADIC".to_string(), "[".to_string(), "{".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_numeric_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "numeric_literal".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BareFunctionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_CATALOG".to_string(), "CURRENT_DATE".to_string(), "CURRENT_ROLE".to_string(), "CURRENT_SCHEMA".to_string(), "CURRENT_TIME".to_string(), "CURRENT_TIMESTAMP".to_string(), "CURRENT_USER".to_string(), "LOCALTIME".to_string(), "LOCALTIMESTAMP".to_string(), "SESSION_USER".to_string(), "SYSTEM_USER".to_string(), "USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FunctionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DefaultKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ShorthandCastSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='SetConstraintsStatementSegment'
pub static SET_CONSTRAINTS_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// SetConstraintsStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConstraintsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRAINTS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AllKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DeferredKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFERRED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ImmediateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IMMEDIATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFERRED".to_string(), "IMMEDIATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='SetExpressionSegment'
pub static SET_EXPRESSION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// SetExpressionSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NonSetSelectableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "FROM".to_string(), "PIVOT".to_string(), "PIVOT_LONGER".to_string(), "PIVOT_WIDER".to_string(), "SELECT".to_string(), "UNPIVOT".to_string(), "VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetOperatorSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCEPT".to_string(), "INTERSECT".to_string(), "MINUS".to_string(), "UNION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NonSetSelectableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "FROM".to_string(), "PIVOT".to_string(), "PIVOT_LONGER".to_string(), "PIVOT_WIDER".to_string(), "SELECT".to_string(), "UNPIVOT".to_string(), "VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCEPT".to_string(), "INTERSECT".to_string(), "MINUS".to_string(), "UNION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 1,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCEPT".to_string(), "INTERSECT".to_string(), "MINUS".to_string(), "UNION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OrderByClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LimitClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LIMIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NamedWindowSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WINDOW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "FROM".to_string(), "PIVOT".to_string(), "PIVOT_LONGER".to_string(), "PIVOT_WIDER".to_string(), "SELECT".to_string(), "UNPIVOT".to_string(), "VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='SetKeywordSegment'
pub static SET_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SET",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SetOperatorSegment'
pub static SET_OPERATOR_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// SetOperatorSegment
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "UnionGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UNION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "IntersectKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INTERSECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExceptKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCEPT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCEPT".to_string(), "INTERSECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AllKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCEPT".to_string(), "INTERSECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MinusKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MINUS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: Some(Box::new(
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExceptKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCEPT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Anything)
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCEPT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    )),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCEPT".to_string(), "INTERSECT".to_string(), "MINUS".to_string(), "UNION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='SetSchemaStatementSegment'
pub static SET_SCHEMA_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// SetSchemaStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IfNotExistsGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='SetSessionAuthorizationStatementSegment'
pub static SET_SESSION_AUTHORIZATION_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// SetSessionAuthorizationStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LocalKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LOCAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SessionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SESSION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LOCAL".to_string(), "SESSION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SessionKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SESSION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SessionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SESSION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SESSION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LOCAL".to_string(), "SESSION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AuthorizationKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AUTHORIZATION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RoleReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DefaultKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='SetStatementSegment'
pub static SET_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// SetStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SessionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SESSION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LocalKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LOCAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LOCAL".to_string(), "SESSION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ToKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EqualsSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["=".to_string(), "TO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DefaultKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "+".to_string(), "-".to_string(), ":".to_string(), "ARRAY".to_string(), "DATE".to_string(), "FALSE".to_string(), "INTERVAL".to_string(), "NULL".to_string(), "TIME".to_string(), "TIMESTAMP".to_string(), "TIMESTAMPTZ".to_string(), "TIMETZ".to_string(), "TRUE".to_string(), "VARIADIC".to_string(), "[".to_string(), "{".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_numeric_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "numeric_literal".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NakedIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "QuotedIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["double_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OnKeywordAsIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TimeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TIME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ZoneKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ZONE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LocalKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LOCAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DefaultKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string(), "LOCAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TIME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SchemaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RoleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NoneKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NONE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RoleReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='SetofKeywordSegment'
pub static SETOF_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SETOF",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SetsKeywordSegment'
pub static SETS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SETS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SettingsKeywordSegment'
pub static SETTINGS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SETTINGS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SetuserKeywordSegment'
pub static SETUSER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SETUSER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ShareKeywordSegment'
pub static SHARE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SHARE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SharesKeywordSegment'
pub static SHARES_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SHARES",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ShorthandCastSegment'
pub static SHORTHAND_CAST_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ShorthandCastSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "Expression_D_Grammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "CaseExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CastOperatorSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["::".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DatatypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "TimeZoneGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["::".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 1,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["::".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='ShowKeywordSegment'
pub static SHOW_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SHOW",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ShowStatementSegment'
pub static SHOW_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ShowStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ShowKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SHOW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AllKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Is_superuserKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IS_SUPERUSER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Lc_collateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LC_COLLATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Lc_ctypeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LC_CTYPE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Server_encodingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SERVER_ENCODING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Server_versionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SERVER_VERSION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SHOW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ShutdownKeywordSegment'
pub static SHUTDOWN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SHUTDOWN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SignalKeywordSegment'
pub static SIGNAL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SIGNAL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SignedSegmentGrammar'
pub static SIGNED_SEGMENT_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PositiveSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["+".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NegativeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["-".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["+".to_string(), "-".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='SimilarKeywordSegment'
pub static SIMILAR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SIMILAR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SimpleGeometryGrammar'
pub static SIMPLE_GEOMETRY_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
);

// name='SimpleKeywordSegment'
pub static SIMPLE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SIMPLE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SimplifiedPivotExpressionSegment'
pub static SIMPLIFIED_PIVOT_EXPRESSION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// SimplifiedPivotExpressionSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PivotKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PIVOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Pivot_widerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PIVOT_WIDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PIVOT".to_string(), "PIVOT_WIDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "InKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "+".to_string(), "-".to_string(), ":".to_string(), "ARRAY".to_string(), "DATE".to_string(), "FALSE".to_string(), "INTERVAL".to_string(), "NULL".to_string(), "TIME".to_string(), "TIMESTAMP".to_string(), "TIMESTAMPTZ".to_string(), "TIMETZ".to_string(), "TRUE".to_string(), "VARIADIC".to_string(), "[".to_string(), "{".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_numeric_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "numeric_literal".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "+".to_string(), "-".to_string(), ":".to_string(), "ARRAY".to_string(), "DATE".to_string(), "FALSE".to_string(), "INTERVAL".to_string(), "NULL".to_string(), "TIME".to_string(), "TIMESTAMP".to_string(), "TIMESTAMPTZ".to_string(), "TIMETZ".to_string(), "TRUE".to_string(), "VARIADIC".to_string(), "[".to_string(), "{".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_numeric_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "numeric_literal".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "UsingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FunctionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AliasExpressionSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "GroupByClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OrderByClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LimitClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LIMIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PIVOT".to_string(), "PIVOT_WIDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='SimplifiedUnpivotExpressionSegment'
pub static SIMPLIFIED_UNPIVOT_EXPRESSION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// SimplifiedUnpivotExpressionSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "UnpivotKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UNPIVOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Pivot_longerKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PIVOT_LONGER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PIVOT_LONGER".to_string(), "UNPIVOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AliasExpressionSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ColumnsExpressionGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLUMNS".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["star".to_string()]),
        }),
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "IntoKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INTO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NameKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ValueKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VALUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "OrderByClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LimitClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LIMIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PIVOT_LONGER".to_string(), "UNPIVOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='SingleIdentifierFullGrammar'
pub static SINGLE_IDENTIFIER_FULL_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NakedIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "QuotedIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["double_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NakedIdentifierFullSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["word".to_string()]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='SingleIdentifierGrammar'
pub static SINGLE_IDENTIFIER_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NakedIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "QuotedIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["double_quote".to_string()]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "DotSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='SingleIdentifierListSegment'
pub static SINGLE_IDENTIFIER_LIST_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// SingleIdentifierListSegment
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='SingleQuotedIdentifierSegment'
pub static SINGLE_QUOTED_IDENTIFIER_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::TypedParser {
    template: "single_quote",
    token_type: "quoted_identifier",
    raw_class: "IdentifierSegment",
    optional: false,
})
);

// name='SizedArrayTypeSegment'
pub static SIZED_ARRAY_TYPE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// SizedArrayTypeSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ArrayTypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ARRAY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ArrayAccessorSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["[".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ARRAY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='SkipKeywordSegment'
pub static SKIP_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SKIP",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Skip_lockedKeywordSegment'
pub static SKIP_LOCKED_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SKIP_LOCKED",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SlashSegment'
pub static SLASH_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "/",
    token_type: "slash",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='SliceSegment'
pub static SLICE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: ":",
    token_type: "slice",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='SmallintKeywordSegment'
pub static SMALLINT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SMALLINT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SmallserialKeywordSegment'
pub static SMALLSERIAL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SMALLSERIAL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SnapshotKeywordSegment'
pub static SNAPSHOT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SNAPSHOT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SomeKeywordSegment'
pub static SOME_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SOME",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SonameKeywordSegment'
pub static SONAME_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SONAME",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SpatialKeywordSegment'
pub static SPATIAL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SPATIAL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SqlKeywordSegment'
pub static SQL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SQL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Sql_big_resultKeywordSegment'
pub static SQL_BIG_RESULT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SQL_BIG_RESULT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Sql_big_selectsKeywordSegment'
pub static SQL_BIG_SELECTS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SQL_BIG_SELECTS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Sql_big_tablesKeywordSegment'
pub static SQL_BIG_TABLES_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SQL_BIG_TABLES",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Sql_calc_found_rowsKeywordSegment'
pub static SQL_CALC_FOUND_ROWS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SQL_CALC_FOUND_ROWS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Sql_log_offKeywordSegment'
pub static SQL_LOG_OFF_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SQL_LOG_OFF",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Sql_log_updateKeywordSegment'
pub static SQL_LOG_UPDATE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SQL_LOG_UPDATE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Sql_low_priority_updatesKeywordSegment'
pub static SQL_LOW_PRIORITY_UPDATES_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SQL_LOW_PRIORITY_UPDATES",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Sql_select_limitKeywordSegment'
pub static SQL_SELECT_LIMIT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SQL_SELECT_LIMIT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Sql_small_resultKeywordSegment'
pub static SQL_SMALL_RESULT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SQL_SMALL_RESULT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Sql_warningsKeywordSegment'
pub static SQL_WARNINGS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SQL_WARNINGS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SqlcaKeywordSegment'
pub static SQLCA_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SQLCA",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SslKeywordSegment'
pub static SSL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SSL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='StableKeywordSegment'
pub static STABLE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "STABLE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='StageKeywordSegment'
pub static STAGE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "STAGE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='StagesKeywordSegment'
pub static STAGES_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "STAGES",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='StandaloneKeywordSegment'
pub static STANDALONE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "STANDALONE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='StarSegment'
pub static STAR_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "*",
    token_type: "star",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='StartBracketSegment'
pub static START_BRACKET_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='StartCurlyBracketSegment'
pub static START_CURLY_BRACKET_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "{",
    token_type: "start_curly_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='StartKeywordSegment'
pub static START_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "START",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='StartSquareBracketSegment'
pub static START_SQUARE_BRACKET_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "[",
    token_type: "start_square_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='StartingKeywordSegment'
pub static STARTING_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "STARTING",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='StartsKeywordSegment'
pub static STARTS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "STARTS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='StatementKeywordSegment'
pub static STATEMENT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "STATEMENT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='StatementSegment'
pub static STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// StatementSegment
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SelectableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "DELETE".to_string(), "FROM".to_string(), "INSERT".to_string(), "PIVOT".to_string(), "PIVOT_LONGER".to_string(), "PIVOT_WIDER".to_string(), "SELECT".to_string(), "UNPIVOT".to_string(), "UPDATE".to_string(), "VALUES".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MergeStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MERGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "InsertStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INSERT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TransactionStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BEGIN".to_string(), "COMMIT".to_string(), "END".to_string(), "ROLLBACK".to_string(), "START".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DropTableStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DropViewStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CreateUserStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DropUserStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TruncateStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TRUNCATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AccessStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GRANT".to_string(), "REVOKE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CreateTableStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CreateRoleStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DropRoleStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AlterTableStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CreateSchemaStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SetSchemaStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DropSchemaStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DropTypeStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CreateDatabaseStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DropDatabaseStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CreateIndexStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DropIndexStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CreateViewStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DeleteStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DELETE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UpdateStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UPDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CreateCastStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DropCastStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CreateFunctionStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DropFunctionStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CreateModelStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DropModelStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DescribeStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DESCRIBE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UseStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExplainStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXPLAIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CreateSequenceStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AlterSequenceStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DropSequenceStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CreateTriggerStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DropTriggerStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AlterDefaultPrivilegesStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DropOwnedStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ReassignOwnedStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REASSIGN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CommentOnStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COMMENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AnalyzeStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ANALYSE".to_string(), "ANALYZE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CreateTableAsStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AlterTriggerStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SetStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AlterPolicyStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CreatePolicyStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DropPolicyStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CreateDomainStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AlterDomainStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DropDomainStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CreateMaterializedViewStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AlterMaterializedViewStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DropMaterializedViewStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RefreshMaterializedViewStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REFRESH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AlterDatabaseStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DropDatabaseStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "VacuumStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VACUUM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AlterFunctionStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CreateViewStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AlterViewStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ListenStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LISTEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NotifyStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOTIFY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UnlistenStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UNLISTEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LoadStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LOAD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ResetStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DiscardStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DISCARD".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AlterProcedureStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CreateProcedureStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DropProcedureStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CopyStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COPY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DoStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AlterIndexStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ReindexStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REINDEX".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AlterRoleStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CreateExtensionStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DropExtensionStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AlterExtensionStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CreateSubscriptionStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AlterSubscriptionStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DropSubscriptionStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CreatePublicationStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AlterPublicationStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DropPublicationStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CreateTypeStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AlterTypeStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CreateTextSearchConfigurationStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AlterTextSearchConfigurationStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DropTextSearchConfigurationStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AlterSchemaStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LockTableStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LOCK".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ClusterStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CLUSTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CreateCollationStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DropCollationStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CallStoredProcedureSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CALL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CreateServerStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CreateUserMappingStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ImportForeignSchemaStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IMPORT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CreateForeignTableStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DropAggregateStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CreateAggregateStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AlterAggregateStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CreateStatisticsStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AlterStatisticsStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DropStatisticsStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ShowStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SHOW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SetConstraintsStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CreateForeignDataWrapperStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MetaCommandQueryBufferStatement",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SELECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DropForeignTableStatement",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DROP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CreateOperatorStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CREATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AlterForeignTableStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALTER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SecurityLabelStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SECURITY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PrepareStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PREPARE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExecuteStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXECUTE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DeallocateStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEALLOCATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SetSessionAuthorizationStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ResetSessionAuthorizationStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SimplifiedPivotExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PIVOT".to_string(), "PIVOT_WIDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SimplifiedUnpivotExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PIVOT_LONGER".to_string(), "UNPIVOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "DelimiterGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([";".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='StatisticsKeywordSegment'
pub static STATISTICS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "STATISTICS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='StatisticsReferenceSegment'
pub static STATISTICS_REFERENCE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// StatisticsReferenceSegment
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "ObjectReferenceDelimiterGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "ObjectReferenceTerminatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["!".to_string(), "%".to_string(), "&".to_string(), "(".to_string(), "*".to_string(), "+".to_string(), ",".to_string(), "-".to_string(), "/".to_string(), "//".to_string(), ":".to_string(), "::".to_string(), ";".to_string(), "<".to_string(), "=".to_string(), "==".to_string(), ">".to_string(), "AND".to_string(), "AS".to_string(), "COLLATE".to_string(), "IS".to_string(), "ON".to_string(), "OR".to_string(), "PIVOT".to_string(), "UNPIVOT".to_string(), "USING".to_string(), "[".to_string(), "^".to_string(), "|".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["glob_operator".to_string(), "json_operator".to_string(), "like_operator".to_string()]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: false,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='StdinKeywordSegment'
pub static STDIN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "STDIN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='StdoutKeywordSegment'
pub static STDOUT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "STDOUT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='StorageKeywordSegment'
pub static STORAGE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "STORAGE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='StoredKeywordSegment'
pub static STORED_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "STORED",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Straight_joinKeywordSegment'
pub static STRAIGHT_JOIN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "STRAIGHT_JOIN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='StreamKeywordSegment'
pub static STREAM_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "STREAM",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='StreamsKeywordSegment'
pub static STREAMS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "STREAMS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='StrictKeywordSegment'
pub static STRICT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "STRICT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='StringBinaryOperatorGrammar'
pub static STRING_BINARY_OPERATOR_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ConcatSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["|".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CollateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLLATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COLLATE".to_string(), "|".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='StripKeywordSegment'
pub static STRIP_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "STRIP",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='StructKeywordSegment'
pub static STRUCT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "STRUCT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='StructLiteralSegment'
pub static STRUCT_LITERAL_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// StructLiteralSegment
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "BaseExpressionElementGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AliasExpressionSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='StructTypeSchemaSegment'
pub static STRUCT_TYPE_SCHEMA_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// StructTypeSchemaSegment
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DatatypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ParameterNameSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DatatypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='StructTypeSegment'
pub static STRUCT_TYPE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// StructTypeSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "StructKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STRUCT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StructTypeSchemaSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STRUCT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='SublistKeywordSegment'
pub static SUBLIST_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SUBLIST",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SubscriptionKeywordSegment'
pub static SUBSCRIPTION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SUBSCRIPTION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SubscriptionReferenceSegment'
pub static SUBSCRIPTION_REFERENCE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// SubscriptionReferenceSegment
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "ObjectReferenceDelimiterGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "ObjectReferenceTerminatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["!".to_string(), "%".to_string(), "&".to_string(), "(".to_string(), "*".to_string(), "+".to_string(), ",".to_string(), "-".to_string(), "/".to_string(), "//".to_string(), ":".to_string(), "::".to_string(), ";".to_string(), "<".to_string(), "=".to_string(), "==".to_string(), ">".to_string(), "AND".to_string(), "AS".to_string(), "COLLATE".to_string(), "IS".to_string(), "ON".to_string(), "OR".to_string(), "PIVOT".to_string(), "UNPIVOT".to_string(), "USING".to_string(), "[".to_string(), "^".to_string(), "|".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["glob_operator".to_string(), "json_operator".to_string(), "like_operator".to_string()]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: false,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='SubstringKeywordSegment'
pub static SUBSTRING_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SUBSTRING",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SuccessfulKeywordSegment'
pub static SUCCESSFUL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SUCCESSFUL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SummaryKeywordSegment'
pub static SUMMARY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SUMMARY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SuperuserKeywordSegment'
pub static SUPERUSER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SUPERUSER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SupportKeywordSegment'
pub static SUPPORT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SUPPORT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SymbolSegment'
pub static SYMBOL_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Token{
    token_type: "symbol",
//    token_type: "SymbolSegment",
})
);

// name='SymmetricKeywordSegment'
pub static SYMMETRIC_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SYMMETRIC",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SynonymKeywordSegment'
pub static SYNONYM_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SYNONYM",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SysdateKeywordSegment'
pub static SYSDATE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SYSDATE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SysidKeywordSegment'
pub static SYSID_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SYSID",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='SystemKeywordSegment'
pub static SYSTEM_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "SYSTEM",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TableConstraintSegment'
pub static TABLE_CONSTRAINT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// TableConstraintSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ConstraintKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRAINT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRAINT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CheckKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHECK".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NoKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "InheritKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INHERIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHECK".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "UniqueKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UNIQUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NullsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NULLS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NotKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DistinctKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DISTINCT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NULLS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BracketedColumnReferenceListGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IndexParametersSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INCLUDE".to_string(), "USING".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UNIQUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PrimaryKeyGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PRIMARY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BracketedColumnReferenceListGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IndexParametersSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INCLUDE".to_string(), "USING".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PRIMARY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExcludeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCLUDE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "UsingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IndexAccessMethodSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExclusionConstraintElementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IndexParametersSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INCLUDE".to_string(), "USING".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WhereKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHERE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHERE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCLUDE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ForeignKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOREIGN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "KeyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["KEY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BracketedColumnReferenceListGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ReferenceDefinitionGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REFERENCES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOREIGN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHECK".to_string(), "EXCLUDE".to_string(), "FOREIGN".to_string(), "PRIMARY".to_string(), "UNIQUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DeferrableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFERRABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NotKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DeferrableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFERRABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFERRABLE".to_string(), "NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "InitiallyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INITIALLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DeferredKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFERRED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INITIALLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "InitiallyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INITIALLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ImmediateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IMMEDIATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INITIALLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INITIALLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NotKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ValidKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VALID".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NoKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "InheritKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INHERIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFERRABLE".to_string(), "INITIALLY".to_string(), "NO".to_string(), "NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHECK".to_string(), "CONSTRAINT".to_string(), "EXCLUDE".to_string(), "FOREIGN".to_string(), "PRIMARY".to_string(), "UNIQUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='TableConstraintUsingIndexSegment'
pub static TABLE_CONSTRAINT_USING_INDEX_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// TableConstraintUsingIndexSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ConstraintKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRAINT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRAINT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "UniqueKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UNIQUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PrimaryKeyGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PRIMARY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PRIMARY".to_string(), "UNIQUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UsingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IndexKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INDEX".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IndexReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PRIMARY".to_string(), "UNIQUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DeferrableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFERRABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NotKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DeferrableKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFERRABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFERRABLE".to_string(), "NOT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "InitiallyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INITIALLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DeferredKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFERRED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INITIALLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "InitiallyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INITIALLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ImmediateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IMMEDIATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INITIALLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INITIALLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONSTRAINT".to_string(), "PRIMARY".to_string(), "UNIQUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='TableEndClauseSegment'
pub static TABLE_END_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// TableEndClauseSegment
Arc::new(Grammar::Nothing())
);

// name='TableExpressionSegment'
pub static TABLE_EXPRESSION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// TableExpressionSegment
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ValuesClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BareFunctionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT_CATALOG".to_string(), "CURRENT_DATE".to_string(), "CURRENT_ROLE".to_string(), "CURRENT_SCHEMA".to_string(), "CURRENT_TIME".to_string(), "CURRENT_TIMESTAMP".to_string(), "CURRENT_USER".to_string(), "LOCALTIME".to_string(), "LOCALTIMESTAMP".to_string(), "SESSION_USER".to_string(), "SYSTEM_USER".to_string(), "USER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FunctionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OrdinalityKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDINALITY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SelectableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "DELETE".to_string(), "FROM".to_string(), "INSERT".to_string(), "PIVOT".to_string(), "PIVOT_LONGER".to_string(), "PIVOT_WIDER".to_string(), "SELECT".to_string(), "UNPIVOT".to_string(), "UPDATE".to_string(), "VALUES".to_string(), "WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "MergeStatementSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MERGE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='TableKeywordSegment'
pub static TABLE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TABLE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TableReferenceSegment'
pub static TABLE_REFERENCE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// TableReferenceSegment
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "SingleQuotedIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["single_quote".to_string()]),
        }),
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "ObjectReferenceDelimiterGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "ObjectReferenceTerminatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["!".to_string(), "%".to_string(), "&".to_string(), "(".to_string(), "*".to_string(), "+".to_string(), ",".to_string(), "-".to_string(), "/".to_string(), "//".to_string(), ":".to_string(), "::".to_string(), ";".to_string(), "<".to_string(), "=".to_string(), "==".to_string(), ">".to_string(), "AND".to_string(), "AS".to_string(), "COLLATE".to_string(), "IS".to_string(), "ON".to_string(), "OR".to_string(), "PIVOT".to_string(), "UNPIVOT".to_string(), "USING".to_string(), "[".to_string(), "^".to_string(), "|".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["glob_operator".to_string(), "json_operator".to_string(), "like_operator".to_string()]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: false,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='TablesKeywordSegment'
pub static TABLES_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TABLES",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TablesampleKeywordSegment'
pub static TABLESAMPLE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TABLESAMPLE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TablespaceKeywordSegment'
pub static TABLESPACE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TABLESPACE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TablespaceReferenceSegment'
pub static TABLESPACE_REFERENCE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// TablespaceReferenceSegment
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "ObjectReferenceDelimiterGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "ObjectReferenceTerminatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["!".to_string(), "%".to_string(), "&".to_string(), "(".to_string(), "*".to_string(), "+".to_string(), ",".to_string(), "-".to_string(), "/".to_string(), "//".to_string(), ":".to_string(), "::".to_string(), ";".to_string(), "<".to_string(), "=".to_string(), "==".to_string(), ">".to_string(), "AND".to_string(), "AS".to_string(), "COLLATE".to_string(), "IS".to_string(), "ON".to_string(), "OR".to_string(), "PIVOT".to_string(), "UNPIVOT".to_string(), "USING".to_string(), "[".to_string(), "^".to_string(), "|".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["glob_operator".to_string(), "json_operator".to_string(), "like_operator".to_string()]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: false,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='TagReferenceSegment'
pub static TAG_REFERENCE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// TagReferenceSegment
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "ObjectReferenceDelimiterGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "ObjectReferenceTerminatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["!".to_string(), "%".to_string(), "&".to_string(), "(".to_string(), "*".to_string(), "+".to_string(), ",".to_string(), "-".to_string(), "/".to_string(), "//".to_string(), ":".to_string(), "::".to_string(), ";".to_string(), "<".to_string(), "=".to_string(), "==".to_string(), ">".to_string(), "AND".to_string(), "AS".to_string(), "COLLATE".to_string(), "IS".to_string(), "ON".to_string(), "OR".to_string(), "PIVOT".to_string(), "UNPIVOT".to_string(), "USING".to_string(), "[".to_string(), "^".to_string(), "|".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["glob_operator".to_string(), "json_operator".to_string(), "like_operator".to_string()]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: false,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='Tail_Recurse_Expression_A_Grammar'
pub static TAIL_RECURSE_EXPRESSION_A_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "Expression_A_Unary_Operator_Grammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["+".to_string(), "-".to_string(), "NOT".to_string(), "PRIOR".to_string(), "~".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "BinaryOperatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["!".to_string(), "%".to_string(), "&".to_string(), "*".to_string(), "+".to_string(), "-".to_string(), "/".to_string(), "//".to_string(), "<".to_string(), "=".to_string(), "==".to_string(), ">".to_string(), "AND".to_string(), "COLLATE".to_string(), "IS".to_string(), "OR".to_string(), "^".to_string(), "|".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["glob_operator".to_string(), "json_operator".to_string(), "like_operator".to_string()]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["+".to_string(), "-".to_string(), "NOT".to_string(), "PRIOR".to_string(), "~".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Expression_C_Grammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='Tail_Recurse_Expression_B_Grammar'
pub static TAIL_RECURSE_EXPRESSION_B_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "Expression_B_Unary_Operator_Grammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["+".to_string(), "-".to_string(), "~".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["+".to_string(), "-".to_string(), "~".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Expression_C_Grammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='TaskKeywordSegment'
pub static TASK_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TASK",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TasksKeywordSegment'
pub static TASKS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TASKS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TempKeywordSegment'
pub static TEMP_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TEMP",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TemplateKeywordSegment'
pub static TEMPLATE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TEMPLATE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TemporalQuerySegment'
pub static TEMPORAL_QUERY_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// TemporalQuerySegment
Arc::new(Grammar::Nothing())
);

// name='TemporaryGrammar'
pub static TEMPORARY_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TempKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TEMP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TemporaryKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TEMPORARY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TEMP".to_string(), "TEMPORARY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='TemporaryKeywordSegment'
pub static TEMPORARY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TEMPORARY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TemporaryTransientGrammar'
pub static TEMPORARY_TRANSIENT_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TransientKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TRANSIENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TemporaryGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TEMP".to_string(), "TEMPORARY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TEMP".to_string(), "TEMPORARY".to_string(), "TRANSIENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='TerminateKeywordSegment'
pub static TERMINATE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TERMINATE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TerminatedKeywordSegment'
pub static TERMINATED_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TERMINATED",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TextKeywordSegment'
pub static TEXT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TEXT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TextsizeKeywordSegment'
pub static TEXTSIZE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TEXTSIZE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ThanKeywordSegment'
pub static THAN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "THAN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ThenKeywordSegment'
pub static THEN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "THEN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TiesKeywordSegment'
pub static TIES_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TIES",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TildeSegment'
pub static TILDE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "~",
    token_type: "tilde",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='TimeKeywordSegment'
pub static TIME_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TIME",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TimeWithTZGrammar'
pub static TIME_WITH_T_Z_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TimeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TIME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TimestampKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TIMESTAMP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TIME".to_string(), "TIMESTAMP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BracketedArguments",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WithoutKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITHOUT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string(), "WITHOUT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TimeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TIME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ZoneKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ZONE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string(), "WITHOUT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TIME".to_string(), "TIMESTAMP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='TimeZoneGrammar'
pub static TIME_ZONE_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
// TimeZoneGrammar
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AtKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TimeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TIME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ZoneKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ZONE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='TimestampKeywordSegment'
pub static TIMESTAMP_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TIMESTAMP",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TimestamptzKeywordSegment'
pub static TIMESTAMPTZ_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TIMESTAMPTZ",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TimetzKeywordSegment'
pub static TIMETZ_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TIMETZ",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TimingKeywordSegment'
pub static TIMING_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TIMING",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TinKeywordSegment'
pub static TIN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TIN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TinyblobKeywordSegment'
pub static TINYBLOB_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TINYBLOB",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TinyintKeywordSegment'
pub static TINYINT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TINYINT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TinytextKeywordSegment'
pub static TINYTEXT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TINYTEXT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ToKeywordSegment'
pub static TO_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TO",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ToastKeywordSegment'
pub static TOAST_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TOAST",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TopKeywordSegment'
pub static TOP_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TOP",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TrailingKeywordSegment'
pub static TRAILING_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TRAILING",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TranKeywordSegment'
pub static TRAN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TRAN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TransactionKeywordSegment'
pub static TRANSACTION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TRANSACTION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TransactionStatementSegment'
pub static TRANSACTION_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// TransactionStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "StartKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["START".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BeginKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BEGIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CommitKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COMMIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RollbackKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ROLLBACK".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "EndKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["END".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BEGIN".to_string(), "COMMIT".to_string(), "END".to_string(), "ROLLBACK".to_string(), "START".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TransactionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TRANSACTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WorkKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WORK".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TRANSACTION".to_string(), "WORK".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NameKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AndKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AND".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NoKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ChainKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHAIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["AND".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BEGIN".to_string(), "COMMIT".to_string(), "END".to_string(), "ROLLBACK".to_string(), "START".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='TransactionsKeywordSegment'
pub static TRANSACTIONS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TRANSACTIONS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TransformKeywordSegment'
pub static TRANSFORM_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TRANSFORM",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TransientKeywordSegment'
pub static TRANSIENT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TRANSIENT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TreatKeywordSegment'
pub static TREAT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TREAT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TriangleKeywordSegment'
pub static TRIANGLE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TRIANGLE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TriggerKeywordSegment'
pub static TRIGGER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TRIGGER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TriggerReferenceSegment'
pub static TRIGGER_REFERENCE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// TriggerReferenceSegment
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "ObjectReferenceDelimiterGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "ObjectReferenceTerminatorGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["!".to_string(), "%".to_string(), "&".to_string(), "(".to_string(), "*".to_string(), "+".to_string(), ",".to_string(), "-".to_string(), "/".to_string(), "//".to_string(), ":".to_string(), "::".to_string(), ";".to_string(), "<".to_string(), "=".to_string(), "==".to_string(), ">".to_string(), "AND".to_string(), "AS".to_string(), "COLLATE".to_string(), "IS".to_string(), "ON".to_string(), "OR".to_string(), "PIVOT".to_string(), "UNPIVOT".to_string(), "USING".to_string(), "[".to_string(), "^".to_string(), "|".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["glob_operator".to_string(), "json_operator".to_string(), "like_operator".to_string()]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: false,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='TrimKeywordSegment'
pub static TRIM_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TRIM",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TrimParametersGrammar'
pub static TRIM_PARAMETERS_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "BothKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BOTH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LeadingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LEADING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TrailingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TRAILING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BOTH".to_string(), "LEADING".to_string(), "TRAILING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='TrueKeywordSegment'
pub static TRUE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TRUE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TrueSegment'
pub static TRUE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TRUE",
    token_type: "boolean_literal",
    raw_class: "LiteralKeywordSegment",
    optional: false,
})
);

// name='TruncateKeywordSegment'
pub static TRUNCATE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TRUNCATE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TruncateStatementSegment'
pub static TRUNCATE_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// TruncateStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TruncateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TRUNCATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TABLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OnlyKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ONLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "StarSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["*".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RestartKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RESTART".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ContinueKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONTINUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONTINUE".to_string(), "RESTART".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "IdentityKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["IDENTITY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONTINUE".to_string(), "RESTART".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DropBehaviorGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADE".to_string(), "RESTRICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TRUNCATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='TrustedKeywordSegment'
pub static TRUSTED_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TRUSTED",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TsequalKeywordSegment'
pub static TSEQUAL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TSEQUAL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TsqueryKeywordSegment'
pub static TSQUERY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TSQUERY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TsrangeKeywordSegment'
pub static TSRANGE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TSRANGE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TstzrangeKeywordSegment'
pub static TSTZRANGE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TSTZRANGE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TsvectorKeywordSegment'
pub static TSVECTOR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TSVECTOR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TupleSegment'
pub static TUPLE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// TupleSegment
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "BaseExpressionElementGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='TypeKeywordSegment'
pub static TYPE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TYPE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='TypedArrayLiteralSegment'
pub static TYPED_ARRAY_LITERAL_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// TypedArrayLiteralSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "VariadicKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VARIADIC".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NakedIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "WalrusOperatorSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([":=".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VARIADIC".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ArrayTypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ARRAY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ArrayLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["[".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ARRAY".to_string(), "VARIADIC".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='TypedStructLiteralSegment'
pub static TYPED_STRUCT_LITERAL_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// TypedStructLiteralSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "StructTypeSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STRUCT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "StructLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["STRUCT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='TypesKeywordSegment'
pub static TYPES_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "TYPES",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='UescapeKeywordSegment'
pub static UESCAPE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "UESCAPE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='UidKeywordSegment'
pub static UID_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "UID",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='UnboundedKeywordSegment'
pub static UNBOUNDED_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "UNBOUNDED",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='UncommittedKeywordSegment'
pub static UNCOMMITTED_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "UNCOMMITTED",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='UnconditionalCrossJoinKeywordsGrammar'
pub static UNCONDITIONAL_CROSS_JOIN_KEYWORDS_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Ref {
    name: "CrossKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CROSS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='UnconditionalJoinKeywordsGrammar'
pub static UNCONDITIONAL_JOIN_KEYWORDS_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NaturalJoinKeywordsGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NATURAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "UnconditionalCrossJoinKeywordsGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CROSS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "HorizontalJoinKeywordsGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["POSITIONAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CROSS".to_string(), "NATURAL".to_string(), "POSITIONAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='UndoKeywordSegment'
pub static UNDO_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "UNDO",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='UnencryptedKeywordSegment'
pub static UNENCRYPTED_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "UNENCRYPTED",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='UnionGrammar'
pub static UNION_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "UnionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UNION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "DistinctKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DISTINCT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AllKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ALL".to_string(), "DISTINCT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NameKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UNION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='UnionKeywordSegment'
pub static UNION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "UNION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='UniqueKeyGrammar'
pub static UNIQUE_KEY_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "UniqueKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UNIQUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UNIQUE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='UniqueKeywordSegment'
pub static UNIQUE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "UNIQUE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='UnknownKeywordSegment'
pub static UNKNOWN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "UNKNOWN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='UnknownLiteralSegment'
pub static UNKNOWN_LITERAL_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "UNKNOWN",
    token_type: "null_literal",
    raw_class: "LiteralKeywordSegment",
    optional: false,
})
);

// name='UnlistenKeywordSegment'
pub static UNLISTEN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "UNLISTEN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='UnlistenStatementSegment'
pub static UNLISTEN_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// UnlistenStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "UnlistenKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UNLISTEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "StarSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["*".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UNLISTEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='UnlockKeywordSegment'
pub static UNLOCK_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "UNLOCK",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='UnloggedKeywordSegment'
pub static UNLOGGED_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "UNLOGGED",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='UnorderedSelectStatementSegment'
pub static UNORDERED_SELECT_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// UnorderedSelectStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SelectClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SELECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FromClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SELECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FromClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SelectClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SELECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string(), "SELECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WhereClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHERE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "GroupByClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "HavingClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["HAVING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NamedWindowSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WINDOW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QualifyClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["QUALIFY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "SetOperatorSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCEPT".to_string(), "INTERSECT".to_string(), "MINUS".to_string(), "UNION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OrderByClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LimitClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LIMIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConflictKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONFLICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ReturningKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RETURNING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string(), "SELECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='UnorderedSetExpressionSegment'
pub static UNORDERED_SET_EXPRESSION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// UnorderedSetExpressionSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NonSetSelectableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "FROM".to_string(), "PIVOT".to_string(), "PIVOT_LONGER".to_string(), "PIVOT_WIDER".to_string(), "SELECT".to_string(), "UNPIVOT".to_string(), "VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SetOperatorSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCEPT".to_string(), "INTERSECT".to_string(), "MINUS".to_string(), "UNION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NonSetSelectableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "FROM".to_string(), "PIVOT".to_string(), "PIVOT_LONGER".to_string(), "PIVOT_WIDER".to_string(), "SELECT".to_string(), "UNPIVOT".to_string(), "VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCEPT".to_string(), "INTERSECT".to_string(), "MINUS".to_string(), "UNION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    min_times: 1,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCEPT".to_string(), "INTERSECT".to_string(), "MINUS".to_string(), "UNION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "FROM".to_string(), "PIVOT".to_string(), "PIVOT_LONGER".to_string(), "PIVOT_WIDER".to_string(), "SELECT".to_string(), "UNPIVOT".to_string(), "VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='UnpackingOperatorSegment'
pub static UNPACKING_OPERATOR_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::TypedParser {
    template: "star",
    token_type: "unpacking_operator",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='UnpivotKeywordSegment'
pub static UNPIVOT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "UNPIVOT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='UnsafeKeywordSegment'
pub static UNSAFE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "UNSAFE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='UnsignedKeywordSegment'
pub static UNSIGNED_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "UNSIGNED",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='UntilKeywordSegment'
pub static UNTIL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "UNTIL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='UpdateKeywordSegment'
pub static UPDATE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "UPDATE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='UpdateStatementSegment'
pub static UPDATE_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// UpdateStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "UpdateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UPDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OnlyKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ONLY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AliasExpressionSegment",
    optional: true,
    allow_gaps: true,
    exclude: Some(Box::new(
Arc::new(Grammar::Ref {
    name: "SetKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    )),
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("dedent"))
,
Arc::new(Grammar::Ref {
    name: "SetClauseListSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SET".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FromClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FROM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WhereKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHERE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CurrentKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURRENT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OfKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OF".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHERE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WhereClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHERE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHERE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ReturningKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RETURNING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "StarSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["*".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AliasExpressionSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("dedent"))
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RETURNING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["UPDATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='UpdatetextKeywordSegment'
pub static UPDATETEXT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "UPDATETEXT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='UsageKeywordSegment'
pub static USAGE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "USAGE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='UseKeywordSegment'
pub static USE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "USE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='UseStatementSegment'
pub static USE_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// UseStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "UseKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DatabaseReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["USE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='Use_any_roleKeywordSegment'
pub static USE_ANY_ROLE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "USE_ANY_ROLE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='UserKeywordSegment'
pub static USER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "USER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='UsersKeywordSegment'
pub static USERS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "USERS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='UsingKeywordSegment'
pub static USING_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "USING",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Utc_dateKeywordSegment'
pub static UTC_DATE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "UTC_DATE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Utc_timeKeywordSegment'
pub static UTC_TIME_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "UTC_TIME",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Utc_timestampKeywordSegment'
pub static UTC_TIMESTAMP_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "UTC_TIMESTAMP",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='UuidKeywordSegment'
pub static UUID_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "UUID",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='VacuumKeywordSegment'
pub static VACUUM_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "VACUUM",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='VacuumStatementSegment'
pub static VACUUM_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// VacuumStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "VacuumKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VACUUM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FullKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FreezeKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FREEZE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "VerboseKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VERBOSE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "AnalyzeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ANALYZE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AnalyseKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ANALYSE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ANALYSE".to_string(), "ANALYZE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ANALYSE".to_string(), "ANALYZE".to_string(), "FREEZE".to_string(), "FULL".to_string(), "VERBOSE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "FullKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FULL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FreezeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FREEZE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "VerboseKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VERBOSE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AnalyzeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ANALYZE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AnalyseKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ANALYSE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Disable_page_skippingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DISABLE_PAGE_SKIPPING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Skip_lockedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SKIP_LOCKED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Index_cleanupKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["INDEX_CLEANUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "Process_toastKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PROCESS_TOAST".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TruncateKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TRUNCATE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ParallelKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PARALLEL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ANALYSE".to_string(), "ANALYZE".to_string(), "DISABLE_PAGE_SKIPPING".to_string(), "FREEZE".to_string(), "FULL".to_string(), "INDEX_CLEANUP".to_string(), "PARALLEL".to_string(), "PROCESS_TOAST".to_string(), "SKIP_LOCKED".to_string(), "TRUNCATE".to_string(), "VERBOSE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LiteralGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "+".to_string(), "-".to_string(), ":".to_string(), "ARRAY".to_string(), "DATE".to_string(), "FALSE".to_string(), "INTERVAL".to_string(), "NULL".to_string(), "TIME".to_string(), "TIMESTAMP".to_string(), "TIMESTAMPTZ".to_string(), "TIMETZ".to_string(), "TRUE".to_string(), "VARIADIC".to_string(), "[".to_string(), "{".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_numeric_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "numeric_literal".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NakedIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "OnKeywordAsIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ANALYSE".to_string(), "ANALYZE".to_string(), "DISABLE_PAGE_SKIPPING".to_string(), "FREEZE".to_string(), "FULL".to_string(), "INDEX_CLEANUP".to_string(), "PARALLEL".to_string(), "PROCESS_TOAST".to_string(), "SKIP_LOCKED".to_string(), "TRUNCATE".to_string(), "VERBOSE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ANALYSE".to_string(), "ANALYZE".to_string(), "DISABLE_PAGE_SKIPPING".to_string(), "FREEZE".to_string(), "FULL".to_string(), "INDEX_CLEANUP".to_string(), "PARALLEL".to_string(), "PROCESS_TOAST".to_string(), "SKIP_LOCKED".to_string(), "TRUNCATE".to_string(), "VERBOSE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "ANALYSE".to_string(), "ANALYZE".to_string(), "FREEZE".to_string(), "FULL".to_string(), "VERBOSE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "TableReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "BracketedColumnReferenceListGrammar",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: true,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VACUUM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ValidKeywordSegment'
pub static VALID_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "VALID",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ValidateKeywordSegment'
pub static VALIDATE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "VALIDATE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ValidatorKeywordSegment'
pub static VALIDATOR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "VALIDATOR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ValueKeywordSegment'
pub static VALUE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "VALUE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ValuesClauseSegment'
pub static VALUES_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// ValuesClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ValuesKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "DefaultKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DEFAULT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Greedy,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "AliasExpressionSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "OrderByClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LimitClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LIMIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='ValuesKeywordSegment'
pub static VALUES_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "VALUES",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Varchar2KeywordSegment'
pub static VARCHAR2_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "VARCHAR2",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='VarcharKeywordSegment'
pub static VARCHAR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "VARCHAR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='VarcharacterKeywordSegment'
pub static VARCHARACTER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "VARCHARACTER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='VariableKeywordSegment'
pub static VARIABLE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "VARIABLE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='VariablesKeywordSegment'
pub static VARIABLES_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "VARIABLES",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='VariadicKeywordSegment'
pub static VARIADIC_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "VARIADIC",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='VaryingKeywordSegment'
pub static VARYING_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "VARYING",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='VectorKeywordSegment'
pub static VECTOR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "VECTOR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='VerboseKeywordSegment'
pub static VERBOSE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "VERBOSE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='VersionIdentifierSegment'
pub static VERSION_IDENTIFIER_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// VersionIdentifierSegment
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NakedIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='VersionKeywordSegment'
pub static VERSION_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "VERSION",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ViewKeywordSegment'
pub static VIEW_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "VIEW",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ViewsKeywordSegment'
pub static VIEWS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "VIEWS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='VirtualKeywordSegment'
pub static VIRTUAL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "VIRTUAL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='VolatileKeywordSegment'
pub static VOLATILE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "VOLATILE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='WaitforKeywordSegment'
pub static WAITFOR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "WAITFOR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='WalKeywordSegment'
pub static WAL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "WAL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='WalrusOperatorSegment'
pub static WALRUS_OPERATOR_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: ":=",
    token_type: "assignment_operator",
    raw_class: "SymbolSegment",
    optional: false,
})
);

// name='WarehouseKeywordSegment'
pub static WAREHOUSE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "WAREHOUSE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='WarehousesKeywordSegment'
pub static WAREHOUSES_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "WAREHOUSES",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='WeekKeywordSegment'
pub static WEEK_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "WEEK",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='WeekdayKeywordSegment'
pub static WEEKDAY_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "WEEKDAY",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='WellKnownTextGeometrySegment'
pub static WELL_KNOWN_TEXT_GEOMETRY_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// WellKnownTextGeometrySegment
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PointKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["POINT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LinestringKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LINESTRING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PolygonKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["POLYGON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MultipointKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MULTIPOINT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MultilinestringKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MULTILINESTRING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MultipolygonKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MULTIPOLYGON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "GeometrycollectionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GEOMETRYCOLLECTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PointzKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["POINTZ".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LinestringzKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LINESTRINGZ".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PolygonzKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["POLYGONZ".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MultipointzKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MULTIPOINTZ".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MultilinestringzKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MULTILINESTRINGZ".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MultipolygonzKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MULTIPOLYGONZ".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "GeometrycollectionzKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GEOMETRYCOLLECTIONZ".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PointmKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["POINTM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LinestringmKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LINESTRINGM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PolygonmKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["POLYGONM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MultipointmKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MULTIPOINTM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MultilinestringmKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MULTILINESTRINGM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MultipolygonmKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MULTIPOLYGONM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "GeometrycollectionmKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GEOMETRYCOLLECTIONM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PointzmKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["POINTZM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LinestringzmKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LINESTRINGZM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PolygonzmKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["POLYGONZM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MultipointzmKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MULTIPOINTZM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MultilinestringzmKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MULTILINESTRINGZM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MultipolygonzmKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MULTIPOLYGONZM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "GeometrycollectionzmKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GEOMETRYCOLLECTIONZM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CircularstringKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CIRCULARSTRING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CompoundcurveKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COMPOUNDCURVE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CurvepolygonKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURVEPOLYGON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MulticurveKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MULTICURVE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MultisurfaceKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MULTISURFACE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PolyhedralsurfaceKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["POLYHEDRALSURFACE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TriangleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TRIANGLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TinKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CIRCULARSTRING".to_string(), "COMPOUNDCURVE".to_string(), "CURVEPOLYGON".to_string(), "GEOMETRYCOLLECTION".to_string(), "GEOMETRYCOLLECTIONM".to_string(), "GEOMETRYCOLLECTIONZ".to_string(), "GEOMETRYCOLLECTIONZM".to_string(), "LINESTRING".to_string(), "LINESTRINGM".to_string(), "LINESTRINGZ".to_string(), "LINESTRINGZM".to_string(), "MULTICURVE".to_string(), "MULTILINESTRING".to_string(), "MULTILINESTRINGM".to_string(), "MULTILINESTRINGZ".to_string(), "MULTILINESTRINGZM".to_string(), "MULTIPOINT".to_string(), "MULTIPOINTM".to_string(), "MULTIPOINTZ".to_string(), "MULTIPOINTZM".to_string(), "MULTIPOLYGON".to_string(), "MULTIPOLYGONM".to_string(), "MULTIPOLYGONZ".to_string(), "MULTIPOLYGONZM".to_string(), "MULTISURFACE".to_string(), "POINT".to_string(), "POINTM".to_string(), "POINTZ".to_string(), "POINTZM".to_string(), "POLYGON".to_string(), "POLYGONM".to_string(), "POLYGONZ".to_string(), "POLYGONZM".to_string(), "POLYHEDRALSURFACE".to_string(), "TIN".to_string(), "TRIANGLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SimpleGeometryGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SimpleGeometryGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SimpleGeometryGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WellKnownTextGeometrySegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CIRCULARSTRING".to_string(), "COMPOUNDCURVE".to_string(), "CURVEPOLYGON".to_string(), "GEOGRAPHY".to_string(), "GEOMETRY".to_string(), "GEOMETRYCOLLECTION".to_string(), "GEOMETRYCOLLECTIONM".to_string(), "GEOMETRYCOLLECTIONZ".to_string(), "GEOMETRYCOLLECTIONZM".to_string(), "LINESTRING".to_string(), "LINESTRINGM".to_string(), "LINESTRINGZ".to_string(), "LINESTRINGZM".to_string(), "MULTICURVE".to_string(), "MULTILINESTRING".to_string(), "MULTILINESTRINGM".to_string(), "MULTILINESTRINGZ".to_string(), "MULTILINESTRINGZM".to_string(), "MULTIPOINT".to_string(), "MULTIPOINTM".to_string(), "MULTIPOINTZ".to_string(), "MULTIPOINTZM".to_string(), "MULTIPOLYGON".to_string(), "MULTIPOLYGONM".to_string(), "MULTIPOLYGONZ".to_string(), "MULTIPOLYGONZM".to_string(), "MULTISURFACE".to_string(), "POINT".to_string(), "POINTM".to_string(), "POINTZ".to_string(), "POINTZM".to_string(), "POLYGON".to_string(), "POLYGONM".to_string(), "POLYGONZ".to_string(), "POLYGONZM".to_string(), "POLYHEDRALSURFACE".to_string(), "TIN".to_string(), "TRIANGLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "CIRCULARSTRING".to_string(), "COMPOUNDCURVE".to_string(), "CURVEPOLYGON".to_string(), "GEOGRAPHY".to_string(), "GEOMETRY".to_string(), "GEOMETRYCOLLECTION".to_string(), "GEOMETRYCOLLECTIONM".to_string(), "GEOMETRYCOLLECTIONZ".to_string(), "GEOMETRYCOLLECTIONZM".to_string(), "LINESTRING".to_string(), "LINESTRINGM".to_string(), "LINESTRINGZ".to_string(), "LINESTRINGZM".to_string(), "MULTICURVE".to_string(), "MULTILINESTRING".to_string(), "MULTILINESTRINGM".to_string(), "MULTILINESTRINGZ".to_string(), "MULTILINESTRINGZM".to_string(), "MULTIPOINT".to_string(), "MULTIPOINTM".to_string(), "MULTIPOINTZ".to_string(), "MULTIPOINTZM".to_string(), "MULTIPOLYGON".to_string(), "MULTIPOLYGONM".to_string(), "MULTIPOLYGONZ".to_string(), "MULTIPOLYGONZM".to_string(), "MULTISURFACE".to_string(), "POINT".to_string(), "POINTM".to_string(), "POINTZ".to_string(), "POINTZM".to_string(), "POLYGON".to_string(), "POLYGONM".to_string(), "POLYGONZ".to_string(), "POLYGONZM".to_string(), "POLYHEDRALSURFACE".to_string(), "TIN".to_string(), "TRIANGLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CIRCULARSTRING".to_string(), "COMPOUNDCURVE".to_string(), "CURVEPOLYGON".to_string(), "GEOMETRYCOLLECTION".to_string(), "GEOMETRYCOLLECTIONM".to_string(), "GEOMETRYCOLLECTIONZ".to_string(), "GEOMETRYCOLLECTIONZM".to_string(), "LINESTRING".to_string(), "LINESTRINGM".to_string(), "LINESTRINGZ".to_string(), "LINESTRINGZM".to_string(), "MULTICURVE".to_string(), "MULTILINESTRING".to_string(), "MULTILINESTRINGM".to_string(), "MULTILINESTRINGZ".to_string(), "MULTILINESTRINGZM".to_string(), "MULTIPOINT".to_string(), "MULTIPOINTM".to_string(), "MULTIPOINTZ".to_string(), "MULTIPOINTZM".to_string(), "MULTIPOLYGON".to_string(), "MULTIPOLYGONM".to_string(), "MULTIPOLYGONZ".to_string(), "MULTIPOLYGONZM".to_string(), "MULTISURFACE".to_string(), "POINT".to_string(), "POINTM".to_string(), "POINTZ".to_string(), "POINTZM".to_string(), "POLYGON".to_string(), "POLYGONM".to_string(), "POLYGONZ".to_string(), "POLYGONZM".to_string(), "POLYHEDRALSURFACE".to_string(), "TIN".to_string(), "TRIANGLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "GeometryKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GEOMETRY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "GeographyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GEOGRAPHY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GEOGRAPHY".to_string(), "GEOMETRY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PointKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["POINT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LinestringKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LINESTRING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PolygonKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["POLYGON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MultipointKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MULTIPOINT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MultilinestringKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MULTILINESTRING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MultipolygonKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MULTIPOLYGON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "GeometrycollectionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GEOMETRYCOLLECTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PointzKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["POINTZ".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LinestringzKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LINESTRINGZ".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PolygonzKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["POLYGONZ".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MultipointzKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MULTIPOINTZ".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MultilinestringzKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MULTILINESTRINGZ".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MultipolygonzKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MULTIPOLYGONZ".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "GeometrycollectionzKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GEOMETRYCOLLECTIONZ".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PointmKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["POINTM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LinestringmKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LINESTRINGM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PolygonmKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["POLYGONM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MultipointmKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MULTIPOINTM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MultilinestringmKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MULTILINESTRINGM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MultipolygonmKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MULTIPOLYGONM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "GeometrycollectionmKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GEOMETRYCOLLECTIONM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PointzmKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["POINTZM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LinestringzmKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LINESTRINGZM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PolygonzmKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["POLYGONZM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MultipointzmKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MULTIPOINTZM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MultilinestringzmKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MULTILINESTRINGZM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MultipolygonzmKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MULTIPOLYGONZM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "GeometrycollectionzmKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GEOMETRYCOLLECTIONZM".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CircularstringKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CIRCULARSTRING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CompoundcurveKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["COMPOUNDCURVE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CurvepolygonKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CURVEPOLYGON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MulticurveKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MULTICURVE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "MultisurfaceKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["MULTISURFACE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "PolyhedralsurfaceKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["POLYHEDRALSURFACE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TriangleKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TRIANGLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "TinKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["TIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "GeometryKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GEOMETRY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "GeographyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GEOGRAPHY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CIRCULARSTRING".to_string(), "COMPOUNDCURVE".to_string(), "CURVEPOLYGON".to_string(), "GEOGRAPHY".to_string(), "GEOMETRY".to_string(), "GEOMETRYCOLLECTION".to_string(), "GEOMETRYCOLLECTIONM".to_string(), "GEOMETRYCOLLECTIONZ".to_string(), "GEOMETRYCOLLECTIONZM".to_string(), "LINESTRING".to_string(), "LINESTRINGM".to_string(), "LINESTRINGZ".to_string(), "LINESTRINGZM".to_string(), "MULTICURVE".to_string(), "MULTILINESTRING".to_string(), "MULTILINESTRINGM".to_string(), "MULTILINESTRINGZ".to_string(), "MULTILINESTRINGZM".to_string(), "MULTIPOINT".to_string(), "MULTIPOINTM".to_string(), "MULTIPOINTZ".to_string(), "MULTIPOINTZM".to_string(), "MULTIPOLYGON".to_string(), "MULTIPOLYGONM".to_string(), "MULTIPOLYGONZ".to_string(), "MULTIPOLYGONZM".to_string(), "MULTISURFACE".to_string(), "POINT".to_string(), "POINTM".to_string(), "POINTZ".to_string(), "POINTZM".to_string(), "POLYGON".to_string(), "POLYGONM".to_string(), "POLYGONZ".to_string(), "POLYGONZM".to_string(), "POLYHEDRALSURFACE".to_string(), "TIN".to_string(), "TRIANGLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NumericLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["numeric_literal".to_string()]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CIRCULARSTRING".to_string(), "COMPOUNDCURVE".to_string(), "CURVEPOLYGON".to_string(), "GEOGRAPHY".to_string(), "GEOMETRY".to_string(), "GEOMETRYCOLLECTION".to_string(), "GEOMETRYCOLLECTIONM".to_string(), "GEOMETRYCOLLECTIONZ".to_string(), "GEOMETRYCOLLECTIONZM".to_string(), "LINESTRING".to_string(), "LINESTRINGM".to_string(), "LINESTRINGZ".to_string(), "LINESTRINGZM".to_string(), "MULTICURVE".to_string(), "MULTILINESTRING".to_string(), "MULTILINESTRINGM".to_string(), "MULTILINESTRINGZ".to_string(), "MULTILINESTRINGZM".to_string(), "MULTIPOINT".to_string(), "MULTIPOINTM".to_string(), "MULTIPOINTZ".to_string(), "MULTIPOINTZM".to_string(), "MULTIPOLYGON".to_string(), "MULTIPOLYGONM".to_string(), "MULTIPOLYGONZ".to_string(), "MULTIPOLYGONZM".to_string(), "MULTISURFACE".to_string(), "POINT".to_string(), "POINTM".to_string(), "POINTZ".to_string(), "POINTZM".to_string(), "POLYGON".to_string(), "POLYGONM".to_string(), "POLYGONZ".to_string(), "POLYGONZM".to_string(), "POLYHEDRALSURFACE".to_string(), "TIN".to_string(), "TRIANGLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GEOGRAPHY".to_string(), "GEOMETRY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CIRCULARSTRING".to_string(), "COMPOUNDCURVE".to_string(), "CURVEPOLYGON".to_string(), "GEOGRAPHY".to_string(), "GEOMETRY".to_string(), "GEOMETRYCOLLECTION".to_string(), "GEOMETRYCOLLECTIONM".to_string(), "GEOMETRYCOLLECTIONZ".to_string(), "GEOMETRYCOLLECTIONZM".to_string(), "LINESTRING".to_string(), "LINESTRINGM".to_string(), "LINESTRINGZ".to_string(), "LINESTRINGZM".to_string(), "MULTICURVE".to_string(), "MULTILINESTRING".to_string(), "MULTILINESTRINGM".to_string(), "MULTILINESTRINGZ".to_string(), "MULTILINESTRINGZM".to_string(), "MULTIPOINT".to_string(), "MULTIPOINTM".to_string(), "MULTIPOINTZ".to_string(), "MULTIPOINTZM".to_string(), "MULTIPOLYGON".to_string(), "MULTIPOLYGONM".to_string(), "MULTIPOLYGONZ".to_string(), "MULTIPOLYGONZM".to_string(), "MULTISURFACE".to_string(), "POINT".to_string(), "POINTM".to_string(), "POINTZ".to_string(), "POINTZM".to_string(), "POLYGON".to_string(), "POLYGONM".to_string(), "POLYGONZ".to_string(), "POLYGONZM".to_string(), "POLYHEDRALSURFACE".to_string(), "TIN".to_string(), "TRIANGLE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='WhenClauseSegment'
pub static WHEN_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// WhenClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WhenKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("dedent"))
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("conditional"))
,
Arc::new(Grammar::Ref {
    name: "ThenKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["THEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("conditional"))
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("conditional"))
,
Arc::new(Grammar::Meta("conditional"))
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHEN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='WhenKeywordSegment'
pub static WHEN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "WHEN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='WhereClauseSegment'
pub static WHERE_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// WhereClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WhereKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHERE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("indent"))
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ExpressionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("dedent"))
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WHERE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='WhereClauseTerminatorGrammar'
pub static WHERE_CLAUSE_TERMINATOR_GRAMMAR: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LimitKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LIMIT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "GroupKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OrderKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ByKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "HavingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["HAVING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QualifyKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["QUALIFY".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WindowKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WINDOW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OverlapsKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OVERLAPS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ReturningKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RETURNING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OnKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ConflictKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CONFLICT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ON".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "ForClauseSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["FOR".to_string(), "GROUP".to_string(), "HAVING".to_string(), "LIMIT".to_string(), "ON".to_string(), "ORDER".to_string(), "OVERLAPS".to_string(), "QUALIFY".to_string(), "RETURNING".to_string(), "WINDOW".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='WhereKeywordSegment'
pub static WHERE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "WHERE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='WhileKeywordSegment'
pub static WHILE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "WHILE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='WhitespaceKeywordSegment'
pub static WHITESPACE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "WHITESPACE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='WhitespaceSegment'
pub static WHITESPACE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Token{
    token_type: "whitespace",
//    token_type: "WhitespaceSegment",
})
);

// name='WildcardExcludeExpressionSegment'
pub static WILDCARD_EXCLUDE_EXPRESSION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// WildcardExcludeExpressionSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ExcludeKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCLUDE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ColumnReferenceSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCLUDE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='WildcardExpressionSegment'
pub static WILDCARD_EXPRESSION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// WildcardExpressionSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WildcardIdentifierSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "WildcardExcludeExpressionSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["EXCLUDE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WildcardReplaceExpressionSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REPLACE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WildcardRenameExpressionSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string(), "REPLACE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "WildcardPatternMatchingSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GLOB".to_string(), "ILIKE".to_string(), "LIKE".to_string(), "NOT".to_string(), "SIMILAR".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["glob_operator".to_string(), "like_operator".to_string()]),
        }),
})
,
    ],
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GLOB".to_string(), "ILIKE".to_string(), "LIKE".to_string(), "NOT".to_string(), "RENAME".to_string(), "REPLACE".to_string(), "SIMILAR".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["glob_operator".to_string(), "like_operator".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='WildcardIdentifierSegment'
pub static WILDCARD_IDENTIFIER_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// WildcardIdentifierSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::AnyNumberOf {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "ObjectReferenceDelimiterGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "StarSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["*".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DotSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([".".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["*".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    min_times: 0,
    max_times: None,
    max_times_per_element: None,
    exclude: None,
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "StarSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["*".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: false,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='WildcardPatternMatchingSegment'
pub static WILDCARD_PATTERN_MATCHING_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// WildcardPatternMatchingSegment
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LikeExpressionGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GLOB".to_string(), "ILIKE".to_string(), "LIKE".to_string(), "NOT".to_string(), "SIMILAR".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "LikeOperatorSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["like_operator".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "GlobOperatorSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["glob_operator".to_string()]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["glob_operator".to_string(), "like_operator".to_string()]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "QuotedLiteralSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["bit_string_literal".to_string(), "dollar_quote".to_string(), "escaped_single_quote".to_string(), "newline".to_string(), "single_quote".to_string(), "unicode_single_quote".to_string()]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter(["glob_operator".to_string(), "like_operator".to_string()]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GLOB".to_string(), "ILIKE".to_string(), "LIKE".to_string(), "NOT".to_string(), "SIMILAR".to_string()]),
            token_types: hashbrown::HashSet::from_iter(["glob_operator".to_string(), "like_operator".to_string()]),
        }),
})
);

// name='WildcardRenameExpressionSegment'
pub static WILDCARD_RENAME_EXPRESSION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// WildcardRenameExpressionSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "RenameKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "BaseExpressionElementGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AliasExpressionSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "BaseExpressionElementGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AliasExpressionSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RENAME".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='WildcardReplaceExpressionSegment'
pub static WILDCARD_REPLACE_EXPRESSION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// WildcardReplaceExpressionSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "ReplaceKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REPLACE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "BaseExpressionElementGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AliasExpressionSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: false,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "BaseExpressionElementGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "AliasExpressionSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["REPLACE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='WindowKeywordSegment'
pub static WINDOW_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "WINDOW",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='WindowSpecificationSegment'
pub static WINDOW_SPECIFICATION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// WindowSpecificationSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "SingleIdentifierGrammar",
    optional: true,
    allow_gaps: true,
    exclude: Some(Box::new(
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "PartitionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PARTITION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OrderKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string(), "PARTITION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    )),
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
Arc::new(Grammar::Ref {
    name: "PartitionClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["PARTITION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OrderByClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "FrameClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUPS".to_string(), "RANGE".to_string(), "ROWS".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
);

// name='WithCheckOptionSegment'
pub static WITH_CHECK_OPTION_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// WithCheckOptionSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::OneOf {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CascadedKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADED".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "LocalKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["LOCAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    exclude: None,
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CASCADED".to_string(), "LOCAL".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "CheckKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["CHECK".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "OptionKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["OPTION".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='WithCompoundNonSelectStatementSegment'
pub static WITH_COMPOUND_NON_SELECT_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// WithCompoundNonSelectStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RecursiveKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RECURSIVE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("conditional"))
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CTEDefinitionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: true,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "SelectKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SELECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("conditional"))
,
Arc::new(Grammar::Ref {
    name: "NonWithNonSelectableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='WithCompoundStatementSegment'
pub static WITH_COMPOUND_STATEMENT_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// WithCompoundStatementSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "RecursiveKeywordSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["RECURSIVE".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Meta("conditional"))
,
Arc::new(Grammar::Delimited {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "CTEDefinitionSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: None,
})
,
    ],
    delimiter: Box::new(
Arc::new(Grammar::Ref {
    name: "CommaSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter([",".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
    ),
    allow_trailing: true,
    optional: false,
    optional_delimiter: false,
    terminators: vec![
Arc::new(Grammar::Ref {
    name: "SelectKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SELECT".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    reset_terminators: false,
    allow_gaps: true,
    min_delimiters: 0,
    parse_mode: ParseMode::Strict,
    simple_hint: None,
})
,
Arc::new(Grammar::Meta("conditional"))
,
Arc::new(Grammar::Ref {
    name: "NonWithSelectableGrammar",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string(), "DELETE".to_string(), "FROM".to_string(), "INSERT".to_string(), "PIVOT".to_string(), "PIVOT_LONGER".to_string(), "PIVOT_WIDER".to_string(), "SELECT".to_string(), "UNPIVOT".to_string(), "UPDATE".to_string(), "VALUES".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='WithDataClauseSegment'
pub static WITH_DATA_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// WithDataClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "NoKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: true,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "DataKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["DATA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='WithFillSegment'
pub static WITH_FILL_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// WithFillSegment
Arc::new(Grammar::Nothing())
);

// name='WithKeywordSegment'
pub static WITH_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "WITH",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='WithNoSchemaBindingClauseSegment'
pub static WITH_NO_SCHEMA_BINDING_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// WithNoSchemaBindingClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "NoKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["NO".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "SchemaKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["SCHEMA".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "BindingKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["BINDING".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITH".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='WithinGroupClauseSegment'
pub static WITHIN_GROUP_CLAUSE_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
// WithinGroupClauseSegment
Arc::new(Grammar::Sequence {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "WithinKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITHIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Ref {
    name: "GroupKeywordSegment",
    optional: false,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["GROUP".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
Arc::new(Grammar::Bracketed {
    elements: vec![
Arc::new(Grammar::Ref {
    name: "OrderByClauseSegment",
    optional: true,
    allow_gaps: true,
    exclude: None,
    terminators: vec![
    ],
    reset_terminators: false,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["ORDER".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    bracket_pairs: (
        Box::new(
Arc::new(Grammar::StringParser {
    template: "(",
    token_type: "start_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        ),
        Box::new(
Arc::new(Grammar::StringParser {
    template: ")",
    token_type: "end_bracket",
    raw_class: "SymbolSegment",
    optional: false,
})
        )
    ),
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["(".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
,
    ],
    optional: false,
    terminators: vec![
    ],
    reset_terminators: false,
    allow_gaps: true,
    parse_mode: ParseMode::Strict,
    simple_hint: Some(SimpleHint {
            raw_values: hashbrown::HashSet::from_iter(["WITHIN".to_string()]),
            token_types: hashbrown::HashSet::from_iter([]),
        }),
})
);

// name='WithinKeywordSegment'
pub static WITHIN_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "WITHIN",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='WithoutKeywordSegment'
pub static WITHOUT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "WITHOUT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='WordSegment'
pub static WORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::Token{
    token_type: "word",
//    token_type: "WordSegment",
})
);

// name='WorkKeywordSegment'
pub static WORK_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "WORK",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='WrapperKeywordSegment'
pub static WRAPPER_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "WRAPPER",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='WriteKeywordSegment'
pub static WRITE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "WRITE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Write_partition_columnsKeywordSegment'
pub static WRITE_PARTITION_COLUMNS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "WRITE_PARTITION_COLUMNS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='WritetextKeywordSegment'
pub static WRITETEXT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "WRITETEXT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='X509KeywordSegment'
pub static X509_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "X509",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='XmlKeywordSegment'
pub static XML_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "XML",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='XmlattributesKeywordSegment'
pub static XMLATTRIBUTES_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "XMLATTRIBUTES",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='XmlconcatKeywordSegment'
pub static XMLCONCAT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "XMLCONCAT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='XmlelementKeywordSegment'
pub static XMLELEMENT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "XMLELEMENT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='XmlexistsKeywordSegment'
pub static XMLEXISTS_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "XMLEXISTS",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='XmlforestKeywordSegment'
pub static XMLFOREST_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "XMLFOREST",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='XmlnamespacesKeywordSegment'
pub static XMLNAMESPACES_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "XMLNAMESPACES",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='XmlparseKeywordSegment'
pub static XMLPARSE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "XMLPARSE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='XmlpiKeywordSegment'
pub static XMLPI_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "XMLPI",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='XmlrootKeywordSegment'
pub static XMLROOT_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "XMLROOT",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='XmlserializeKeywordSegment'
pub static XMLSERIALIZE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "XMLSERIALIZE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='XmltableKeywordSegment'
pub static XMLTABLE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "XMLTABLE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='XorKeywordSegment'
pub static XOR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "XOR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='YamlKeywordSegment'
pub static YAML_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "YAML",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='YearKeywordSegment'
pub static YEAR_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "YEAR",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='Year_monthKeywordSegment'
pub static YEAR_MONTH_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "YEAR_MONTH",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='YesKeywordSegment'
pub static YES_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "YES",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ZerofillKeywordSegment'
pub static ZEROFILL_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ZEROFILL",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

// name='ZoneKeywordSegment'
pub static ZONE_KEYWORD_SEGMENT: Lazy<Arc<Grammar>> = Lazy::new(||
Arc::new(Grammar::StringParser {
    template: "ZONE",
    token_type: "keyword",
    raw_class: "KeywordSegment",
    optional: false,
})
);

pub fn get_duckdb_segment_grammar(name: &str) -> Option<Arc<Grammar>> {
    match name {
            "AbortKeywordSegment" => Some(ABORT_KEYWORD_SEGMENT.clone()),
            "AbsoluteKeywordSegment" => Some(ABSOLUTE_KEYWORD_SEGMENT.clone()),
            "AccessKeywordSegment" => Some(ACCESS_KEYWORD_SEGMENT.clone()),
            "AccessStatementSegment" => Some(ACCESS_STATEMENT_SEGMENT.clone()),
            "AccessorGrammar" => Some(ACCESSOR_GRAMMAR.clone()),
            "AccountKeywordSegment" => Some(ACCOUNT_KEYWORD_SEGMENT.clone()),
            "AccountsKeywordSegment" => Some(ACCOUNTS_KEYWORD_SEGMENT.clone()),
            "ActionKeywordSegment" => Some(ACTION_KEYWORD_SEGMENT.clone()),
            "AddKeywordSegment" => Some(ADD_KEYWORD_SEGMENT.clone()),
            "AdjacentSegment" => Some(ADJACENT_SEGMENT.clone()),
            "AdminKeywordSegment" => Some(ADMIN_KEYWORD_SEGMENT.clone()),
            "AfterKeywordSegment" => Some(AFTER_KEYWORD_SEGMENT.clone()),
            "AggregateKeywordSegment" => Some(AGGREGATE_KEYWORD_SEGMENT.clone()),
            "AggregateOrderByClause" => Some(AGGREGATE_ORDER_BY_CLAUSE.clone()),
            "AliasExpressionSegment" => Some(ALIAS_EXPRESSION_SEGMENT.clone()),
            "AliasKeywordSegment" => Some(ALIAS_KEYWORD_SEGMENT.clone()),
            "AliasedTableReferenceGrammar" => Some(ALIASED_TABLE_REFERENCE_GRAMMAR.clone()),
            "AllKeywordSegment" => Some(ALL_KEYWORD_SEGMENT.clone()),
            "Allow_connectionsKeywordSegment" => Some(ALLOW_CONNECTIONS_KEYWORD_SEGMENT.clone()),
            "AlsoKeywordSegment" => Some(ALSO_KEYWORD_SEGMENT.clone()),
            "AlterAggregateStatementSegment" => Some(ALTER_AGGREGATE_STATEMENT_SEGMENT.clone()),
            "AlterDatabaseStatementSegment" => Some(ALTER_DATABASE_STATEMENT_SEGMENT.clone()),
            "AlterDefaultPrivilegesGrantSegment" => Some(ALTER_DEFAULT_PRIVILEGES_GRANT_SEGMENT.clone()),
            "AlterDefaultPrivilegesObjectPrivilegesSegment" => Some(ALTER_DEFAULT_PRIVILEGES_OBJECT_PRIVILEGES_SEGMENT.clone()),
            "AlterDefaultPrivilegesRevokeSegment" => Some(ALTER_DEFAULT_PRIVILEGES_REVOKE_SEGMENT.clone()),
            "AlterDefaultPrivilegesSchemaObjectsSegment" => Some(ALTER_DEFAULT_PRIVILEGES_SCHEMA_OBJECTS_SEGMENT.clone()),
            "AlterDefaultPrivilegesStatementSegment" => Some(ALTER_DEFAULT_PRIVILEGES_STATEMENT_SEGMENT.clone()),
            "AlterDefaultPrivilegesToFromRolesSegment" => Some(ALTER_DEFAULT_PRIVILEGES_TO_FROM_ROLES_SEGMENT.clone()),
            "AlterDomainStatementSegment" => Some(ALTER_DOMAIN_STATEMENT_SEGMENT.clone()),
            "AlterExtensionStatementSegment" => Some(ALTER_EXTENSION_STATEMENT_SEGMENT.clone()),
            "AlterForeignTableActionSegment" => Some(ALTER_FOREIGN_TABLE_ACTION_SEGMENT.clone()),
            "AlterForeignTableStatementSegment" => Some(ALTER_FOREIGN_TABLE_STATEMENT_SEGMENT.clone()),
            "AlterFunctionActionSegment" => Some(ALTER_FUNCTION_ACTION_SEGMENT.clone()),
            "AlterFunctionStatementSegment" => Some(ALTER_FUNCTION_STATEMENT_SEGMENT.clone()),
            "AlterIndexStatementSegment" => Some(ALTER_INDEX_STATEMENT_SEGMENT.clone()),
            "AlterKeywordSegment" => Some(ALTER_KEYWORD_SEGMENT.clone()),
            "AlterMaterializedViewActionSegment" => Some(ALTER_MATERIALIZED_VIEW_ACTION_SEGMENT.clone()),
            "AlterMaterializedViewStatementSegment" => Some(ALTER_MATERIALIZED_VIEW_STATEMENT_SEGMENT.clone()),
            "AlterPolicyStatementSegment" => Some(ALTER_POLICY_STATEMENT_SEGMENT.clone()),
            "AlterProcedureActionSegment" => Some(ALTER_PROCEDURE_ACTION_SEGMENT.clone()),
            "AlterProcedureStatementSegment" => Some(ALTER_PROCEDURE_STATEMENT_SEGMENT.clone()),
            "AlterPublicationStatementSegment" => Some(ALTER_PUBLICATION_STATEMENT_SEGMENT.clone()),
            "AlterRoleStatementSegment" => Some(ALTER_ROLE_STATEMENT_SEGMENT.clone()),
            "AlterSchemaStatementSegment" => Some(ALTER_SCHEMA_STATEMENT_SEGMENT.clone()),
            "AlterSequenceOptionsSegment" => Some(ALTER_SEQUENCE_OPTIONS_SEGMENT.clone()),
            "AlterSequenceStatementSegment" => Some(ALTER_SEQUENCE_STATEMENT_SEGMENT.clone()),
            "AlterStatisticsStatementSegment" => Some(ALTER_STATISTICS_STATEMENT_SEGMENT.clone()),
            "AlterSubscriptionStatementSegment" => Some(ALTER_SUBSCRIPTION_STATEMENT_SEGMENT.clone()),
            "AlterTableActionSegment" => Some(ALTER_TABLE_ACTION_SEGMENT.clone()),
            "AlterTableDropColumnGrammar" => Some(ALTER_TABLE_DROP_COLUMN_GRAMMAR.clone()),
            "AlterTableOptionsGrammar" => Some(ALTER_TABLE_OPTIONS_GRAMMAR.clone()),
            "AlterTableStatementSegment" => Some(ALTER_TABLE_STATEMENT_SEGMENT.clone()),
            "AlterTextSearchConfigurationStatementSegment" => Some(ALTER_TEXT_SEARCH_CONFIGURATION_STATEMENT_SEGMENT.clone()),
            "AlterTriggerStatementSegment" => Some(ALTER_TRIGGER_STATEMENT_SEGMENT.clone()),
            "AlterTypeStatementSegment" => Some(ALTER_TYPE_STATEMENT_SEGMENT.clone()),
            "AlterViewStatementSegment" => Some(ALTER_VIEW_STATEMENT_SEGMENT.clone()),
            "AlwaysKeywordSegment" => Some(ALWAYS_KEYWORD_SEGMENT.clone()),
            "AmpersandSegment" => Some(AMPERSAND_SEGMENT.clone()),
            "AnalyseKeywordSegment" => Some(ANALYSE_KEYWORD_SEGMENT.clone()),
            "AnalyzeKeywordSegment" => Some(ANALYZE_KEYWORD_SEGMENT.clone()),
            "AnalyzeStatementSegment" => Some(ANALYZE_STATEMENT_SEGMENT.clone()),
            "AndKeywordSegment" => Some(AND_KEYWORD_SEGMENT.clone()),
            "AndOperatorGrammar" => Some(AND_OPERATOR_GRAMMAR.clone()),
            "AntiKeywordSegment" => Some(ANTI_KEYWORD_SEGMENT.clone()),
            "AnyKeywordSegment" => Some(ANY_KEYWORD_SEGMENT.clone()),
            "AppendKeywordSegment" => Some(APPEND_KEYWORD_SEGMENT.clone()),
            "ApplyKeywordSegment" => Some(APPLY_KEYWORD_SEGMENT.clone()),
            "ArithmeticBinaryOperatorGrammar" => Some(ARITHMETIC_BINARY_OPERATOR_GRAMMAR.clone()),
            "ArrayAccessorSegment" => Some(ARRAY_ACCESSOR_SEGMENT.clone()),
            "ArrayExpressionSegment" => Some(ARRAY_EXPRESSION_SEGMENT.clone()),
            "ArrayKeywordSegment" => Some(ARRAY_KEYWORD_SEGMENT.clone()),
            "ArrayLiteralSegment" => Some(ARRAY_LITERAL_SEGMENT.clone()),
            "ArrayTypeSegment" => Some(ARRAY_TYPE_SEGMENT.clone()),
            "AsAliasExpressionSegment" => Some(AS_ALIAS_EXPRESSION_SEGMENT.clone()),
            "AsAliasOperatorSegment" => Some(AS_ALIAS_OPERATOR_SEGMENT.clone()),
            "AsKeywordSegment" => Some(AS_KEYWORD_SEGMENT.clone()),
            "AscKeywordSegment" => Some(ASC_KEYWORD_SEGMENT.clone()),
            "AsofKeywordSegment" => Some(ASOF_KEYWORD_SEGMENT.clone()),
            "AssertionKeywordSegment" => Some(ASSERTION_KEYWORD_SEGMENT.clone()),
            "AssignmentKeywordSegment" => Some(ASSIGNMENT_KEYWORD_SEGMENT.clone()),
            "AsymmetricKeywordSegment" => Some(ASYMMETRIC_KEYWORD_SEGMENT.clone()),
            "AtKeywordSegment" => Some(AT_KEYWORD_SEGMENT.clone()),
            "AtomicKeywordSegment" => Some(ATOMIC_KEYWORD_SEGMENT.clone()),
            "AttachKeywordSegment" => Some(ATTACH_KEYWORD_SEGMENT.clone()),
            "AttributeKeywordSegment" => Some(ATTRIBUTE_KEYWORD_SEGMENT.clone()),
            "AuditKeywordSegment" => Some(AUDIT_KEYWORD_SEGMENT.clone()),
            "AuthorizationKeywordSegment" => Some(AUTHORIZATION_KEYWORD_SEGMENT.clone()),
            "AutoIncrementGrammar" => Some(AUTO_INCREMENT_GRAMMAR.clone()),
            "Auto_incrementKeywordSegment" => Some(AUTO_INCREMENT_KEYWORD_SEGMENT.clone()),
            "Avg_row_lengthKeywordSegment" => Some(AVG_ROW_LENGTH_KEYWORD_SEGMENT.clone()),
            "BackupKeywordSegment" => Some(BACKUP_KEYWORD_SEGMENT.clone()),
            "BackwardKeywordSegment" => Some(BACKWARD_KEYWORD_SEGMENT.clone()),
            "BareFunctionSegment" => Some(BARE_FUNCTION_SEGMENT.clone()),
            "BaseExpressionElementGrammar" => Some(BASE_EXPRESSION_ELEMENT_GRAMMAR.clone()),
            "BaseFileSegment" => Some(BASE_FILE_SEGMENT.clone()),
            "BaseSegment" => Some(BASE_SEGMENT.clone()),
            "BeforeKeywordSegment" => Some(BEFORE_KEYWORD_SEGMENT.clone()),
            "BeginKeywordSegment" => Some(BEGIN_KEYWORD_SEGMENT.clone()),
            "BernoulliKeywordSegment" => Some(BERNOULLI_KEYWORD_SEGMENT.clone()),
            "BetweenKeywordSegment" => Some(BETWEEN_KEYWORD_SEGMENT.clone()),
            "BigintKeywordSegment" => Some(BIGINT_KEYWORD_SEGMENT.clone()),
            "BigserialKeywordSegment" => Some(BIGSERIAL_KEYWORD_SEGMENT.clone()),
            "BinaryKeywordSegment" => Some(BINARY_KEYWORD_SEGMENT.clone()),
            "BinaryOperatorGrammar" => Some(BINARY_OPERATOR_GRAMMAR.clone()),
            "BinaryOperatorSegment" => Some(BINARY_OPERATOR_SEGMENT.clone()),
            "BindingKeywordSegment" => Some(BINDING_KEYWORD_SEGMENT.clone()),
            "BitKeywordSegment" => Some(BIT_KEYWORD_SEGMENT.clone()),
            "BitvarKeywordSegment" => Some(BITVAR_KEYWORD_SEGMENT.clone()),
            "BitwiseAndSegment" => Some(BITWISE_AND_SEGMENT.clone()),
            "BitwiseLShiftSegment" => Some(BITWISE_L_SHIFT_SEGMENT.clone()),
            "BitwiseOrSegment" => Some(BITWISE_OR_SEGMENT.clone()),
            "BitwiseRShiftSegment" => Some(BITWISE_R_SHIFT_SEGMENT.clone()),
            "BitwiseXorSegment" => Some(BITWISE_XOR_SEGMENT.clone()),
            "BoolKeywordSegment" => Some(BOOL_KEYWORD_SEGMENT.clone()),
            "BooleanBinaryOperatorGrammar" => Some(BOOLEAN_BINARY_OPERATOR_GRAMMAR.clone()),
            "BooleanKeywordSegment" => Some(BOOLEAN_KEYWORD_SEGMENT.clone()),
            "BooleanLiteralGrammar" => Some(BOOLEAN_LITERAL_GRAMMAR.clone()),
            "BothKeywordSegment" => Some(BOTH_KEYWORD_SEGMENT.clone()),
            "BoxKeywordSegment" => Some(BOX_KEYWORD_SEGMENT.clone()),
            "BpcharKeywordSegment" => Some(BPCHAR_KEYWORD_SEGMENT.clone()),
            "BracketedArguments" => Some(BRACKETED_ARGUMENTS.clone()),
            "BracketedColumnReferenceListGrammar" => Some(BRACKETED_COLUMN_REFERENCE_LIST_GRAMMAR.clone()),
            "BracketedSegment" => Some(BRACKETED_SEGMENT.clone()),
            "BracketedSetExpressionGrammar" => Some(BRACKETED_SET_EXPRESSION_GRAMMAR.clone()),
            "BreadthKeywordSegment" => Some(BREADTH_KEYWORD_SEGMENT.clone()),
            "BreakKeywordSegment" => Some(BREAK_KEYWORD_SEGMENT.clone()),
            "BrowseKeywordSegment" => Some(BROWSE_KEYWORD_SEGMENT.clone()),
            "BuffersKeywordSegment" => Some(BUFFERS_KEYWORD_SEGMENT.clone()),
            "BulkKeywordSegment" => Some(BULK_KEYWORD_SEGMENT.clone()),
            "ByKeywordSegment" => Some(BY_KEYWORD_SEGMENT.clone()),
            "BypassrlsKeywordSegment" => Some(BYPASSRLS_KEYWORD_SEGMENT.clone()),
            "ByteaKeywordSegment" => Some(BYTEA_KEYWORD_SEGMENT.clone()),
            "CTEColumnList" => Some(C_T_E_COLUMN_LIST.clone()),
            "CTEDefinitionSegment" => Some(C_T_E_DEFINITION_SEGMENT.clone()),
            "CacheKeywordSegment" => Some(CACHE_KEYWORD_SEGMENT.clone()),
            "CallKeywordSegment" => Some(CALL_KEYWORD_SEGMENT.clone()),
            "CallStoredProcedureSegment" => Some(CALL_STORED_PROCEDURE_SEGMENT.clone()),
            "CalledKeywordSegment" => Some(CALLED_KEYWORD_SEGMENT.clone()),
            "CascadeKeywordSegment" => Some(CASCADE_KEYWORD_SEGMENT.clone()),
            "CascadeRestrictGrammar" => Some(CASCADE_RESTRICT_GRAMMAR.clone()),
            "CascadedKeywordSegment" => Some(CASCADED_KEYWORD_SEGMENT.clone()),
            "CaseExpressionSegment" => Some(CASE_EXPRESSION_SEGMENT.clone()),
            "CaseKeywordSegment" => Some(CASE_KEYWORD_SEGMENT.clone()),
            "CastKeywordSegment" => Some(CAST_KEYWORD_SEGMENT.clone()),
            "CastOperatorSegment" => Some(CAST_OPERATOR_SEGMENT.clone()),
            "CatalogKeywordSegment" => Some(CATALOG_KEYWORD_SEGMENT.clone()),
            "ChainKeywordSegment" => Some(CHAIN_KEYWORD_SEGMENT.clone()),
            "ChangeKeywordSegment" => Some(CHANGE_KEYWORD_SEGMENT.clone()),
            "CharCharacterSetGrammar" => Some(CHAR_CHARACTER_SET_GRAMMAR.clone()),
            "CharKeywordSegment" => Some(CHAR_KEYWORD_SEGMENT.clone()),
            "CharacterKeywordSegment" => Some(CHARACTER_KEYWORD_SEGMENT.clone()),
            "CharacteristicsKeywordSegment" => Some(CHARACTERISTICS_KEYWORD_SEGMENT.clone()),
            "CheckKeywordSegment" => Some(CHECK_KEYWORD_SEGMENT.clone()),
            "CheckedKeywordSegment" => Some(CHECKED_KEYWORD_SEGMENT.clone()),
            "CheckpointKeywordSegment" => Some(CHECKPOINT_KEYWORD_SEGMENT.clone()),
            "ChecksumKeywordSegment" => Some(CHECKSUM_KEYWORD_SEGMENT.clone()),
            "CidrKeywordSegment" => Some(CIDR_KEYWORD_SEGMENT.clone()),
            "CircleKeywordSegment" => Some(CIRCLE_KEYWORD_SEGMENT.clone()),
            "CircularstringKeywordSegment" => Some(CIRCULARSTRING_KEYWORD_SEGMENT.clone()),
            "ClassKeywordSegment" => Some(CLASS_KEYWORD_SEGMENT.clone()),
            "CloseKeywordSegment" => Some(CLOSE_KEYWORD_SEGMENT.clone()),
            "ClusterKeywordSegment" => Some(CLUSTER_KEYWORD_SEGMENT.clone()),
            "ClusterStatementSegment" => Some(CLUSTER_STATEMENT_SEGMENT.clone()),
            "ClusteredKeywordSegment" => Some(CLUSTERED_KEYWORD_SEGMENT.clone()),
            "CoalesceKeywordSegment" => Some(COALESCE_KEYWORD_SEGMENT.clone()),
            "CodeSegment" => Some(CODE_SEGMENT.clone()),
            "CollateGrammar" => Some(COLLATE_GRAMMAR.clone()),
            "CollateKeywordSegment" => Some(COLLATE_KEYWORD_SEGMENT.clone()),
            "CollationKeywordSegment" => Some(COLLATION_KEYWORD_SEGMENT.clone()),
            "CollationReferenceSegment" => Some(COLLATION_REFERENCE_SEGMENT.clone()),
            "ColonDelimiterSegment" => Some(COLON_DELIMITER_SEGMENT.clone()),
            "ColonPrefixSegment" => Some(COLON_PREFIX_SEGMENT.clone()),
            "ColonSegment" => Some(COLON_SEGMENT.clone()),
            "ColumnConstraintDefaultGrammar" => Some(COLUMN_CONSTRAINT_DEFAULT_GRAMMAR.clone()),
            "ColumnConstraintSegment" => Some(COLUMN_CONSTRAINT_SEGMENT.clone()),
            "ColumnDefinitionSegment" => Some(COLUMN_DEFINITION_SEGMENT.clone()),
            "ColumnGeneratedGrammar" => Some(COLUMN_GENERATED_GRAMMAR.clone()),
            "ColumnKeywordSegment" => Some(COLUMN_KEYWORD_SEGMENT.clone()),
            "ColumnReferenceSegment" => Some(COLUMN_REFERENCE_SEGMENT.clone()),
            "ColumnTypeReferenceSegment" => Some(COLUMN_TYPE_REFERENCE_SEGMENT.clone()),
            "ColumnsExpressionFunctionContentsSegment" => Some(COLUMNS_EXPRESSION_FUNCTION_CONTENTS_SEGMENT.clone()),
            "ColumnsExpressionFunctionNameSegment" => Some(COLUMNS_EXPRESSION_FUNCTION_NAME_SEGMENT.clone()),
            "ColumnsExpressionGrammar" => Some(COLUMNS_EXPRESSION_GRAMMAR.clone()),
            "ColumnsExpressionNameGrammar" => Some(COLUMNS_EXPRESSION_NAME_GRAMMAR.clone()),
            "ColumnsKeywordSegment" => Some(COLUMNS_KEYWORD_SEGMENT.clone()),
            "CommaSegment" => Some(COMMA_SEGMENT.clone()),
            "CommentClauseSegment" => Some(COMMENT_CLAUSE_SEGMENT.clone()),
            "CommentKeywordSegment" => Some(COMMENT_KEYWORD_SEGMENT.clone()),
            "CommentOnStatementSegment" => Some(COMMENT_ON_STATEMENT_SEGMENT.clone()),
            "CommentSegment" => Some(COMMENT_SEGMENT.clone()),
            "CommentsKeywordSegment" => Some(COMMENTS_KEYWORD_SEGMENT.clone()),
            "CommitKeywordSegment" => Some(COMMIT_KEYWORD_SEGMENT.clone()),
            "CommittedKeywordSegment" => Some(COMMITTED_KEYWORD_SEGMENT.clone()),
            "CommutatorKeywordSegment" => Some(COMMUTATOR_KEYWORD_SEGMENT.clone()),
            "ComparisonOperatorGrammar" => Some(COMPARISON_OPERATOR_GRAMMAR.clone()),
            "ComparisonOperatorSegment" => Some(COMPARISON_OPERATOR_SEGMENT.clone()),
            "CompletionKeywordSegment" => Some(COMPLETION_KEYWORD_SEGMENT.clone()),
            "CompositeBinaryOperatorSegment" => Some(COMPOSITE_BINARY_OPERATOR_SEGMENT.clone()),
            "CompositeComparisonOperatorSegment" => Some(COMPOSITE_COMPARISON_OPERATOR_SEGMENT.clone()),
            "CompoundcurveKeywordSegment" => Some(COMPOUNDCURVE_KEYWORD_SEGMENT.clone()),
            "CompressKeywordSegment" => Some(COMPRESS_KEYWORD_SEGMENT.clone()),
            "CompressionKeywordSegment" => Some(COMPRESSION_KEYWORD_SEGMENT.clone()),
            "Compression_levelKeywordSegment" => Some(COMPRESSION_LEVEL_KEYWORD_SEGMENT.clone()),
            "ComputeKeywordSegment" => Some(COMPUTE_KEYWORD_SEGMENT.clone()),
            "ConcatSegment" => Some(CONCAT_SEGMENT.clone()),
            "ConcurrentlyKeywordSegment" => Some(CONCURRENTLY_KEYWORD_SEGMENT.clone()),
            "ConditionalCrossJoinKeywordsGrammar" => Some(CONDITIONAL_CROSS_JOIN_KEYWORDS_GRAMMAR.clone()),
            "ConditionalJoinKeywordsGrammar" => Some(CONDITIONAL_JOIN_KEYWORDS_GRAMMAR.clone()),
            "ConfigurationKeywordSegment" => Some(CONFIGURATION_KEYWORD_SEGMENT.clone()),
            "ConflictActionSegment" => Some(CONFLICT_ACTION_SEGMENT.clone()),
            "ConflictKeywordSegment" => Some(CONFLICT_KEYWORD_SEGMENT.clone()),
            "ConflictTargetSegment" => Some(CONFLICT_TARGET_SEGMENT.clone()),
            "ConnectKeywordSegment" => Some(CONNECT_KEYWORD_SEGMENT.clone()),
            "ConnectionKeywordSegment" => Some(CONNECTION_KEYWORD_SEGMENT.clone()),
            "ConstraintKeywordSegment" => Some(CONSTRAINT_KEYWORD_SEGMENT.clone()),
            "ConstraintsKeywordSegment" => Some(CONSTRAINTS_KEYWORD_SEGMENT.clone()),
            "ContainstableKeywordSegment" => Some(CONTAINSTABLE_KEYWORD_SEGMENT.clone()),
            "ContentKeywordSegment" => Some(CONTENT_KEYWORD_SEGMENT.clone()),
            "ContinueKeywordSegment" => Some(CONTINUE_KEYWORD_SEGMENT.clone()),
            "ConversionKeywordSegment" => Some(CONVERSION_KEYWORD_SEGMENT.clone()),
            "CopyKeywordSegment" => Some(COPY_KEYWORD_SEGMENT.clone()),
            "CopyStatementSegment" => Some(COPY_STATEMENT_SEGMENT.clone()),
            "CostKeywordSegment" => Some(COST_KEYWORD_SEGMENT.clone()),
            "CostsKeywordSegment" => Some(COSTS_KEYWORD_SEGMENT.clone()),
            "CreateAggregateStatementSegment" => Some(CREATE_AGGREGATE_STATEMENT_SEGMENT.clone()),
            "CreateCastStatementSegment" => Some(CREATE_CAST_STATEMENT_SEGMENT.clone()),
            "CreateCollationStatementSegment" => Some(CREATE_COLLATION_STATEMENT_SEGMENT.clone()),
            "CreateDatabaseStatementSegment" => Some(CREATE_DATABASE_STATEMENT_SEGMENT.clone()),
            "CreateDomainStatementSegment" => Some(CREATE_DOMAIN_STATEMENT_SEGMENT.clone()),
            "CreateExtensionStatementSegment" => Some(CREATE_EXTENSION_STATEMENT_SEGMENT.clone()),
            "CreateForeignDataWrapperStatementSegment" => Some(CREATE_FOREIGN_DATA_WRAPPER_STATEMENT_SEGMENT.clone()),
            "CreateForeignTableGrammar" => Some(CREATE_FOREIGN_TABLE_GRAMMAR.clone()),
            "CreateForeignTableStatementSegment" => Some(CREATE_FOREIGN_TABLE_STATEMENT_SEGMENT.clone()),
            "CreateFunctionStatementSegment" => Some(CREATE_FUNCTION_STATEMENT_SEGMENT.clone()),
            "CreateIndexStatementSegment" => Some(CREATE_INDEX_STATEMENT_SEGMENT.clone()),
            "CreateKeywordSegment" => Some(CREATE_KEYWORD_SEGMENT.clone()),
            "CreateMaterializedViewStatementSegment" => Some(CREATE_MATERIALIZED_VIEW_STATEMENT_SEGMENT.clone()),
            "CreateModelStatementSegment" => Some(CREATE_MODEL_STATEMENT_SEGMENT.clone()),
            "CreateOperatorStatementSegment" => Some(CREATE_OPERATOR_STATEMENT_SEGMENT.clone()),
            "CreatePolicyStatementSegment" => Some(CREATE_POLICY_STATEMENT_SEGMENT.clone()),
            "CreateProcedureStatementSegment" => Some(CREATE_PROCEDURE_STATEMENT_SEGMENT.clone()),
            "CreatePublicationStatementSegment" => Some(CREATE_PUBLICATION_STATEMENT_SEGMENT.clone()),
            "CreateRoleStatementSegment" => Some(CREATE_ROLE_STATEMENT_SEGMENT.clone()),
            "CreateSchemaStatementSegment" => Some(CREATE_SCHEMA_STATEMENT_SEGMENT.clone()),
            "CreateSequenceOptionsSegment" => Some(CREATE_SEQUENCE_OPTIONS_SEGMENT.clone()),
            "CreateSequenceStatementSegment" => Some(CREATE_SEQUENCE_STATEMENT_SEGMENT.clone()),
            "CreateServerStatementSegment" => Some(CREATE_SERVER_STATEMENT_SEGMENT.clone()),
            "CreateStatisticsStatementSegment" => Some(CREATE_STATISTICS_STATEMENT_SEGMENT.clone()),
            "CreateSubscriptionStatementSegment" => Some(CREATE_SUBSCRIPTION_STATEMENT_SEGMENT.clone()),
            "CreateTableAsStatementSegment" => Some(CREATE_TABLE_AS_STATEMENT_SEGMENT.clone()),
            "CreateTableStatementSegment" => Some(CREATE_TABLE_STATEMENT_SEGMENT.clone()),
            "CreateTextSearchConfigurationStatementSegment" => Some(CREATE_TEXT_SEARCH_CONFIGURATION_STATEMENT_SEGMENT.clone()),
            "CreateTriggerStatementSegment" => Some(CREATE_TRIGGER_STATEMENT_SEGMENT.clone()),
            "CreateTypeStatementSegment" => Some(CREATE_TYPE_STATEMENT_SEGMENT.clone()),
            "CreateUserMappingGrammar" => Some(CREATE_USER_MAPPING_GRAMMAR.clone()),
            "CreateUserMappingStatementSegment" => Some(CREATE_USER_MAPPING_STATEMENT_SEGMENT.clone()),
            "CreateUserStatementSegment" => Some(CREATE_USER_STATEMENT_SEGMENT.clone()),
            "CreateViewStatementSegment" => Some(CREATE_VIEW_STATEMENT_SEGMENT.clone()),
            "CreatedbKeywordSegment" => Some(CREATEDB_KEYWORD_SEGMENT.clone()),
            "CreateroleKeywordSegment" => Some(CREATEROLE_KEYWORD_SEGMENT.clone()),
            "CreateuserKeywordSegment" => Some(CREATEUSER_KEYWORD_SEGMENT.clone()),
            "CrossKeywordSegment" => Some(CROSS_KEYWORD_SEGMENT.clone()),
            "CsvKeywordSegment" => Some(CSV_KEYWORD_SEGMENT.clone()),
            "CubeFunctionNameSegment" => Some(CUBE_FUNCTION_NAME_SEGMENT.clone()),
            "CubeKeywordSegment" => Some(CUBE_KEYWORD_SEGMENT.clone()),
            "CubeRollupClauseSegment" => Some(CUBE_ROLLUP_CLAUSE_SEGMENT.clone()),
            "CurrentKeywordSegment" => Some(CURRENT_KEYWORD_SEGMENT.clone()),
            "Current_catalogKeywordSegment" => Some(CURRENT_CATALOG_KEYWORD_SEGMENT.clone()),
            "Current_dateKeywordSegment" => Some(CURRENT_DATE_KEYWORD_SEGMENT.clone()),
            "Current_roleKeywordSegment" => Some(CURRENT_ROLE_KEYWORD_SEGMENT.clone()),
            "Current_schemaKeywordSegment" => Some(CURRENT_SCHEMA_KEYWORD_SEGMENT.clone()),
            "Current_timeKeywordSegment" => Some(CURRENT_TIME_KEYWORD_SEGMENT.clone()),
            "Current_timestampKeywordSegment" => Some(CURRENT_TIMESTAMP_KEYWORD_SEGMENT.clone()),
            "Current_userKeywordSegment" => Some(CURRENT_USER_KEYWORD_SEGMENT.clone()),
            "CursorKeywordSegment" => Some(CURSOR_KEYWORD_SEGMENT.clone()),
            "CurvepolygonKeywordSegment" => Some(CURVEPOLYGON_KEYWORD_SEGMENT.clone()),
            "CycleKeywordSegment" => Some(CYCLE_KEYWORD_SEGMENT.clone()),
            "DataKeywordSegment" => Some(DATA_KEYWORD_SEGMENT.clone()),
            "DatabaseKeywordSegment" => Some(DATABASE_KEYWORD_SEGMENT.clone()),
            "DatabaseReferenceSegment" => Some(DATABASE_REFERENCE_SEGMENT.clone()),
            "DatabasesKeywordSegment" => Some(DATABASES_KEYWORD_SEGMENT.clone()),
            "DatatypeIdentifierSegment" => Some(DATATYPE_IDENTIFIER_SEGMENT.clone()),
            "DatatypeSegment" => Some(DATATYPE_SEGMENT.clone()),
            "DateKeywordSegment" => Some(DATE_KEYWORD_SEGMENT.clone()),
            "DatePartFunctionName" => Some(DATE_PART_FUNCTION_NAME.clone()),
            "DatePartFunctionNameSegment" => Some(DATE_PART_FUNCTION_NAME_SEGMENT.clone()),
            "DateTimeFunctionContentsSegment" => Some(DATE_TIME_FUNCTION_CONTENTS_SEGMENT.clone()),
            "DateTimeLiteralGrammar" => Some(DATE_TIME_LITERAL_GRAMMAR.clone()),
            "DateTimeTypeIdentifier" => Some(DATE_TIME_TYPE_IDENTIFIER.clone()),
            "DaterangeKeywordSegment" => Some(DATERANGE_KEYWORD_SEGMENT.clone()),
            "DatetimeKeywordSegment" => Some(DATETIME_KEYWORD_SEGMENT.clone()),
            "DatetimeUnitSegment" => Some(DATETIME_UNIT_SEGMENT.clone()),
            "DayKeywordSegment" => Some(DAY_KEYWORD_SEGMENT.clone()),
            "Day_hourKeywordSegment" => Some(DAY_HOUR_KEYWORD_SEGMENT.clone()),
            "Day_microsecondKeywordSegment" => Some(DAY_MICROSECOND_KEYWORD_SEGMENT.clone()),
            "Day_minuteKeywordSegment" => Some(DAY_MINUTE_KEYWORD_SEGMENT.clone()),
            "Day_secondKeywordSegment" => Some(DAY_SECOND_KEYWORD_SEGMENT.clone()),
            "DayofmonthKeywordSegment" => Some(DAYOFMONTH_KEYWORD_SEGMENT.clone()),
            "DayofweekKeywordSegment" => Some(DAYOFWEEK_KEYWORD_SEGMENT.clone()),
            "DayofyearKeywordSegment" => Some(DAYOFYEAR_KEYWORD_SEGMENT.clone()),
            "DaysKeywordSegment" => Some(DAYS_KEYWORD_SEGMENT.clone()),
            "DbccKeywordSegment" => Some(DBCC_KEYWORD_SEGMENT.clone()),
            "DeallocateKeywordSegment" => Some(DEALLOCATE_KEYWORD_SEGMENT.clone()),
            "DeallocateStatementSegment" => Some(DEALLOCATE_STATEMENT_SEGMENT.clone()),
            "DecKeywordSegment" => Some(DEC_KEYWORD_SEGMENT.clone()),
            "DecimalKeywordSegment" => Some(DECIMAL_KEYWORD_SEGMENT.clone()),
            "DeclareKeywordSegment" => Some(DECLARE_KEYWORD_SEGMENT.clone()),
            "Dedent" => Some(DEDENT.clone()),
            "DefaultKeywordSegment" => Some(DEFAULT_KEYWORD_SEGMENT.clone()),
            "DefaultValuesGrammar" => Some(DEFAULT_VALUES_GRAMMAR.clone()),
            "DefaultsKeywordSegment" => Some(DEFAULTS_KEYWORD_SEGMENT.clone()),
            "DeferrableKeywordSegment" => Some(DEFERRABLE_KEYWORD_SEGMENT.clone()),
            "DeferredKeywordSegment" => Some(DEFERRED_KEYWORD_SEGMENT.clone()),
            "DefinerKeywordSegment" => Some(DEFINER_KEYWORD_SEGMENT.clone()),
            "DefinitionArgumentValueGrammar" => Some(DEFINITION_ARGUMENT_VALUE_GRAMMAR.clone()),
            "DefinitionParameterSegment" => Some(DEFINITION_PARAMETER_SEGMENT.clone()),
            "DefinitionParametersSegment" => Some(DEFINITION_PARAMETERS_SEGMENT.clone()),
            "Delay_key_writeKeywordSegment" => Some(DELAY_KEY_WRITE_KEYWORD_SEGMENT.clone()),
            "DelayedKeywordSegment" => Some(DELAYED_KEYWORD_SEGMENT.clone()),
            "DeleteKeywordSegment" => Some(DELETE_KEYWORD_SEGMENT.clone()),
            "DeleteStatementSegment" => Some(DELETE_STATEMENT_SEGMENT.clone()),
            "DelimiterGrammar" => Some(DELIMITER_GRAMMAR.clone()),
            "DelimiterKeywordSegment" => Some(DELIMITER_KEYWORD_SEGMENT.clone()),
            "DelimitersKeywordSegment" => Some(DELIMITERS_KEYWORD_SEGMENT.clone()),
            "DenyKeywordSegment" => Some(DENY_KEYWORD_SEGMENT.clone()),
            "DependenciesKeywordSegment" => Some(DEPENDENCIES_KEYWORD_SEGMENT.clone()),
            "DependsKeywordSegment" => Some(DEPENDS_KEYWORD_SEGMENT.clone()),
            "DepthKeywordSegment" => Some(DEPTH_KEYWORD_SEGMENT.clone()),
            "DescKeywordSegment" => Some(DESC_KEYWORD_SEGMENT.clone()),
            "DescribeKeywordSegment" => Some(DESCRIBE_KEYWORD_SEGMENT.clone()),
            "DescribeStatementSegment" => Some(DESCRIBE_STATEMENT_SEGMENT.clone()),
            "DestroyKeywordSegment" => Some(DESTROY_KEYWORD_SEGMENT.clone()),
            "DestructorKeywordSegment" => Some(DESTRUCTOR_KEYWORD_SEGMENT.clone()),
            "DetachKeywordSegment" => Some(DETACH_KEYWORD_SEGMENT.clone()),
            "DeterministicKeywordSegment" => Some(DETERMINISTIC_KEYWORD_SEGMENT.clone()),
            "DictionaryKeywordSegment" => Some(DICTIONARY_KEYWORD_SEGMENT.clone()),
            "DisableKeywordSegment" => Some(DISABLE_KEYWORD_SEGMENT.clone()),
            "Disable_page_skippingKeywordSegment" => Some(DISABLE_PAGE_SKIPPING_KEYWORD_SEGMENT.clone()),
            "DiscardKeywordSegment" => Some(DISCARD_KEYWORD_SEGMENT.clone()),
            "DiscardStatementSegment" => Some(DISCARD_STATEMENT_SEGMENT.clone()),
            "DiskKeywordSegment" => Some(DISK_KEYWORD_SEGMENT.clone()),
            "DistinctKeywordSegment" => Some(DISTINCT_KEYWORD_SEGMENT.clone()),
            "DistinctrowKeywordSegment" => Some(DISTINCTROW_KEYWORD_SEGMENT.clone()),
            "DistributedKeywordSegment" => Some(DISTRIBUTED_KEYWORD_SEGMENT.clone()),
            "DivKeywordSegment" => Some(DIV_KEYWORD_SEGMENT.clone()),
            "DivideSegment" => Some(DIVIDE_SEGMENT.clone()),
            "DoKeywordSegment" => Some(DO_KEYWORD_SEGMENT.clone()),
            "DoStatementSegment" => Some(DO_STATEMENT_SEGMENT.clone()),
            "DocumentKeywordSegment" => Some(DOCUMENT_KEYWORD_SEGMENT.clone()),
            "DollarNumericLiteralSegment" => Some(DOLLAR_NUMERIC_LITERAL_SEGMENT.clone()),
            "DomainKeywordSegment" => Some(DOMAIN_KEYWORD_SEGMENT.clone()),
            "DotSegment" => Some(DOT_SEGMENT.clone()),
            "DoubleKeywordSegment" => Some(DOUBLE_KEYWORD_SEGMENT.clone()),
            "DropAggregateStatementSegment" => Some(DROP_AGGREGATE_STATEMENT_SEGMENT.clone()),
            "DropBehaviorGrammar" => Some(DROP_BEHAVIOR_GRAMMAR.clone()),
            "DropCastStatementSegment" => Some(DROP_CAST_STATEMENT_SEGMENT.clone()),
            "DropCollationStatementSegment" => Some(DROP_COLLATION_STATEMENT_SEGMENT.clone()),
            "DropDatabaseStatementSegment" => Some(DROP_DATABASE_STATEMENT_SEGMENT.clone()),
            "DropDomainStatementSegment" => Some(DROP_DOMAIN_STATEMENT_SEGMENT.clone()),
            "DropExtensionStatementSegment" => Some(DROP_EXTENSION_STATEMENT_SEGMENT.clone()),
            "DropForeignTableStatement" => Some(DROP_FOREIGN_TABLE_STATEMENT.clone()),
            "DropFunctionStatementSegment" => Some(DROP_FUNCTION_STATEMENT_SEGMENT.clone()),
            "DropIndexStatementSegment" => Some(DROP_INDEX_STATEMENT_SEGMENT.clone()),
            "DropKeywordSegment" => Some(DROP_KEYWORD_SEGMENT.clone()),
            "DropMaterializedViewStatementSegment" => Some(DROP_MATERIALIZED_VIEW_STATEMENT_SEGMENT.clone()),
            "DropModelStatementSegment" => Some(DROP_MODEL_STATEMENT_SEGMENT.clone()),
            "DropOwnedStatementSegment" => Some(DROP_OWNED_STATEMENT_SEGMENT.clone()),
            "DropPolicyStatementSegment" => Some(DROP_POLICY_STATEMENT_SEGMENT.clone()),
            "DropProcedureStatementSegment" => Some(DROP_PROCEDURE_STATEMENT_SEGMENT.clone()),
            "DropPublicationStatementSegment" => Some(DROP_PUBLICATION_STATEMENT_SEGMENT.clone()),
            "DropRoleStatementSegment" => Some(DROP_ROLE_STATEMENT_SEGMENT.clone()),
            "DropSchemaStatementSegment" => Some(DROP_SCHEMA_STATEMENT_SEGMENT.clone()),
            "DropSequenceStatementSegment" => Some(DROP_SEQUENCE_STATEMENT_SEGMENT.clone()),
            "DropStatisticsStatementSegment" => Some(DROP_STATISTICS_STATEMENT_SEGMENT.clone()),
            "DropSubscriptionStatementSegment" => Some(DROP_SUBSCRIPTION_STATEMENT_SEGMENT.clone()),
            "DropTableStatementSegment" => Some(DROP_TABLE_STATEMENT_SEGMENT.clone()),
            "DropTextSearchConfigurationStatementSegment" => Some(DROP_TEXT_SEARCH_CONFIGURATION_STATEMENT_SEGMENT.clone()),
            "DropTriggerStatementSegment" => Some(DROP_TRIGGER_STATEMENT_SEGMENT.clone()),
            "DropTypeStatementSegment" => Some(DROP_TYPE_STATEMENT_SEGMENT.clone()),
            "DropUserStatementSegment" => Some(DROP_USER_STATEMENT_SEGMENT.clone()),
            "DropViewStatementSegment" => Some(DROP_VIEW_STATEMENT_SEGMENT.clone()),
            "DummyKeywordSegment" => Some(DUMMY_KEYWORD_SEGMENT.clone()),
            "DumpKeywordSegment" => Some(DUMP_KEYWORD_SEGMENT.clone()),
            "EachKeywordSegment" => Some(EACH_KEYWORD_SEGMENT.clone()),
            "ElseClauseSegment" => Some(ELSE_CLAUSE_SEGMENT.clone()),
            "ElseKeywordSegment" => Some(ELSE_KEYWORD_SEGMENT.clone()),
            "ElseifKeywordSegment" => Some(ELSEIF_KEYWORD_SEGMENT.clone()),
            "EmptyKeywordSegment" => Some(EMPTY_KEYWORD_SEGMENT.clone()),
            "EmptyStructLiteralBracketsSegment" => Some(EMPTY_STRUCT_LITERAL_BRACKETS_SEGMENT.clone()),
            "EmptyStructLiteralSegment" => Some(EMPTY_STRUCT_LITERAL_SEGMENT.clone()),
            "EnableKeywordSegment" => Some(ENABLE_KEYWORD_SEGMENT.clone()),
            "EnclosedKeywordSegment" => Some(ENCLOSED_KEYWORD_SEGMENT.clone()),
            "EncodingKeywordSegment" => Some(ENCODING_KEYWORD_SEGMENT.clone()),
            "EncryptedKeywordSegment" => Some(ENCRYPTED_KEYWORD_SEGMENT.clone()),
            "EndBracketSegment" => Some(END_BRACKET_SEGMENT.clone()),
            "EndCurlyBracketSegment" => Some(END_CURLY_BRACKET_SEGMENT.clone()),
            "EndKeywordSegment" => Some(END_KEYWORD_SEGMENT.clone()),
            "EndSquareBracketSegment" => Some(END_SQUARE_BRACKET_SEGMENT.clone()),
            "EnumKeywordSegment" => Some(ENUM_KEYWORD_SEGMENT.clone()),
            "EqualsSegment" => Some(EQUALS_SEGMENT.clone()),
            "EqualsSegment_a" => Some(EQUALS_SEGMENT_A.clone()),
            "ErrlvlKeywordSegment" => Some(ERRLVL_KEYWORD_SEGMENT.clone()),
            "EscapeKeywordSegment" => Some(ESCAPE_KEYWORD_SEGMENT.clone()),
            "EscapedKeywordSegment" => Some(ESCAPED_KEYWORD_SEGMENT.clone()),
            "EventKeywordSegment" => Some(EVENT_KEYWORD_SEGMENT.clone()),
            "ExceptKeywordSegment" => Some(EXCEPT_KEYWORD_SEGMENT.clone()),
            "ExcludeKeywordSegment" => Some(EXCLUDE_KEYWORD_SEGMENT.clone()),
            "ExcludingKeywordSegment" => Some(EXCLUDING_KEYWORD_SEGMENT.clone()),
            "ExclusionConstraintElementSegment" => Some(EXCLUSION_CONSTRAINT_ELEMENT_SEGMENT.clone()),
            "ExclusiveKeywordSegment" => Some(EXCLUSIVE_KEYWORD_SEGMENT.clone()),
            "ExecuteKeywordSegment" => Some(EXECUTE_KEYWORD_SEGMENT.clone()),
            "ExecuteStatementSegment" => Some(EXECUTE_STATEMENT_SEGMENT.clone()),
            "ExistingKeywordSegment" => Some(EXISTING_KEYWORD_SEGMENT.clone()),
            "ExistsKeywordSegment" => Some(EXISTS_KEYWORD_SEGMENT.clone()),
            "ExitKeywordSegment" => Some(EXIT_KEYWORD_SEGMENT.clone()),
            "ExplainKeywordSegment" => Some(EXPLAIN_KEYWORD_SEGMENT.clone()),
            "ExplainOptionSegment" => Some(EXPLAIN_OPTION_SEGMENT.clone()),
            "ExplainStatementSegment" => Some(EXPLAIN_STATEMENT_SEGMENT.clone()),
            "ExpressionKeywordSegment" => Some(EXPRESSION_KEYWORD_SEGMENT.clone()),
            "ExpressionSegment" => Some(EXPRESSION_SEGMENT.clone()),
            "Expression_A_Grammar" => Some(EXPRESSION_A_GRAMMAR.clone()),
            "Expression_A_Unary_Operator_Grammar" => Some(EXPRESSION_A_UNARY_OPERATOR_GRAMMAR.clone()),
            "Expression_B_Grammar" => Some(EXPRESSION_B_GRAMMAR.clone()),
            "Expression_B_Unary_Operator_Grammar" => Some(EXPRESSION_B_UNARY_OPERATOR_GRAMMAR.clone()),
            "Expression_C_Grammar" => Some(EXPRESSION_C_GRAMMAR.clone()),
            "Expression_D_Grammar" => Some(EXPRESSION_D_GRAMMAR.clone()),
            "Expression_D_Potential_Select_Statement_Without_Brackets" => Some(EXPRESSION_D_POTENTIAL_SELECT_STATEMENT_WITHOUT_BRACKETS.clone()),
            "ExtendedKeywordSegment" => Some(EXTENDED_KEYWORD_SEGMENT.clone()),
            "ExtendedNaturalJoinKeywordsGrammar" => Some(EXTENDED_NATURAL_JOIN_KEYWORDS_GRAMMAR.clone()),
            "ExtendedTableReferenceGrammar" => Some(EXTENDED_TABLE_REFERENCE_GRAMMAR.clone()),
            "ExtensionKeywordSegment" => Some(EXTENSION_KEYWORD_SEGMENT.clone()),
            "ExtensionReferenceSegment" => Some(EXTENSION_REFERENCE_SEGMENT.clone()),
            "ExternalKeywordSegment" => Some(EXTERNAL_KEYWORD_SEGMENT.clone()),
            "ExtractKeywordSegment" => Some(EXTRACT_KEYWORD_SEGMENT.clone()),
            "FalseKeywordSegment" => Some(FALSE_KEYWORD_SEGMENT.clone()),
            "FalseSegment" => Some(FALSE_SEGMENT.clone()),
            "FamilyKeywordSegment" => Some(FAMILY_KEYWORD_SEGMENT.clone()),
            "FetchClauseSegment" => Some(FETCH_CLAUSE_SEGMENT.clone()),
            "FetchKeywordSegment" => Some(FETCH_KEYWORD_SEGMENT.clone()),
            "FieldsKeywordSegment" => Some(FIELDS_KEYWORD_SEGMENT.clone()),
            "FileKeywordSegment" => Some(FILE_KEYWORD_SEGMENT.clone()),
            "FileSegment" => Some(FILE_SEGMENT.clone()),
            "FillfactorKeywordSegment" => Some(FILLFACTOR_KEYWORD_SEGMENT.clone()),
            "FilterClauseGrammar" => Some(FILTER_CLAUSE_GRAMMAR.clone()),
            "FilterKeywordSegment" => Some(FILTER_KEYWORD_SEGMENT.clone()),
            "FinalizeKeywordSegment" => Some(FINALIZE_KEYWORD_SEGMENT.clone()),
            "FirstKeywordSegment" => Some(FIRST_KEYWORD_SEGMENT.clone()),
            "Float4KeywordSegment" => Some(FLOAT4_KEYWORD_SEGMENT.clone()),
            "Float8KeywordSegment" => Some(FLOAT8_KEYWORD_SEGMENT.clone()),
            "FloatKeywordSegment" => Some(FLOAT_KEYWORD_SEGMENT.clone()),
            "FlushKeywordSegment" => Some(FLUSH_KEYWORD_SEGMENT.clone()),
            "FollowingKeywordSegment" => Some(FOLLOWING_KEYWORD_SEGMENT.clone()),
            "ForClauseSegment" => Some(FOR_CLAUSE_SEGMENT.clone()),
            "ForKeywordSegment" => Some(FOR_KEYWORD_SEGMENT.clone()),
            "ForceKeywordSegment" => Some(FORCE_KEYWORD_SEGMENT.clone()),
            "Force_not_nullKeywordSegment" => Some(FORCE_NOT_NULL_KEYWORD_SEGMENT.clone()),
            "Force_nullKeywordSegment" => Some(FORCE_NULL_KEYWORD_SEGMENT.clone()),
            "Force_quoteKeywordSegment" => Some(FORCE_QUOTE_KEYWORD_SEGMENT.clone()),
            "ForeignDataWrapperGrammar" => Some(FOREIGN_DATA_WRAPPER_GRAMMAR.clone()),
            "ForeignKeyGrammar" => Some(FOREIGN_KEY_GRAMMAR.clone()),
            "ForeignKeywordSegment" => Some(FOREIGN_KEYWORD_SEGMENT.clone()),
            "ForeignTableColumnConstraintSegment" => Some(FOREIGN_TABLE_COLUMN_CONSTRAINT_SEGMENT.clone()),
            "ForeignTableTableConstraintSegment" => Some(FOREIGN_TABLE_TABLE_CONSTRAINT_SEGMENT.clone()),
            "FormatKeywordSegment" => Some(FORMAT_KEYWORD_SEGMENT.clone()),
            "ForwardKeywordSegment" => Some(FORWARD_KEYWORD_SEGMENT.clone()),
            "FrameClauseSegment" => Some(FRAME_CLAUSE_SEGMENT.clone()),
            "FrameClauseUnitGrammar" => Some(FRAME_CLAUSE_UNIT_GRAMMAR.clone()),
            "FreetextKeywordSegment" => Some(FREETEXT_KEYWORD_SEGMENT.clone()),
            "FreetexttableKeywordSegment" => Some(FREETEXTTABLE_KEYWORD_SEGMENT.clone()),
            "FreezeKeywordSegment" => Some(FREEZE_KEYWORD_SEGMENT.clone()),
            "FromClauseSegment" => Some(FROM_CLAUSE_SEGMENT.clone()),
            "FromClauseTerminatorGrammar" => Some(FROM_CLAUSE_TERMINATOR_GRAMMAR.clone()),
            "FromExpressionElementSegment" => Some(FROM_EXPRESSION_ELEMENT_SEGMENT.clone()),
            "FromExpressionSegment" => Some(FROM_EXPRESSION_SEGMENT.clone()),
            "FromKeywordSegment" => Some(FROM_KEYWORD_SEGMENT.clone()),
            "FromPivotExpressionSegment" => Some(FROM_PIVOT_EXPRESSION_SEGMENT.clone()),
            "FromUnpivotExpressionSegment" => Some(FROM_UNPIVOT_EXPRESSION_SEGMENT.clone()),
            "FullKeywordSegment" => Some(FULL_KEYWORD_SEGMENT.clone()),
            "FullTextSearchOperatorSegment" => Some(FULL_TEXT_SEARCH_OPERATOR_SEGMENT.clone()),
            "FulltextKeywordSegment" => Some(FULLTEXT_KEYWORD_SEGMENT.clone()),
            "FunctionContentsExpressionGrammar" => Some(FUNCTION_CONTENTS_EXPRESSION_GRAMMAR.clone()),
            "FunctionContentsGrammar" => Some(FUNCTION_CONTENTS_GRAMMAR.clone()),
            "FunctionContentsSegment" => Some(FUNCTION_CONTENTS_SEGMENT.clone()),
            "FunctionDefinitionGrammar" => Some(FUNCTION_DEFINITION_GRAMMAR.clone()),
            "FunctionKeywordSegment" => Some(FUNCTION_KEYWORD_SEGMENT.clone()),
            "FunctionNameIdentifierSegment" => Some(FUNCTION_NAME_IDENTIFIER_SEGMENT.clone()),
            "FunctionNameSegment" => Some(FUNCTION_NAME_SEGMENT.clone()),
            "FunctionParameterGrammar" => Some(FUNCTION_PARAMETER_GRAMMAR.clone()),
            "FunctionParameterListGrammar" => Some(FUNCTION_PARAMETER_LIST_GRAMMAR.clone()),
            "FunctionSegment" => Some(FUNCTION_SEGMENT.clone()),
            "FunctionsKeywordSegment" => Some(FUNCTIONS_KEYWORD_SEGMENT.clone()),
            "FutureKeywordSegment" => Some(FUTURE_KEYWORD_SEGMENT.clone()),
            "GeneratedKeywordSegment" => Some(GENERATED_KEYWORD_SEGMENT.clone()),
            "GeographyKeywordSegment" => Some(GEOGRAPHY_KEYWORD_SEGMENT.clone()),
            "GeometryKeywordSegment" => Some(GEOMETRY_KEYWORD_SEGMENT.clone()),
            "GeometrycollectionKeywordSegment" => Some(GEOMETRYCOLLECTION_KEYWORD_SEGMENT.clone()),
            "GeometrycollectionmKeywordSegment" => Some(GEOMETRYCOLLECTIONM_KEYWORD_SEGMENT.clone()),
            "GeometrycollectionzKeywordSegment" => Some(GEOMETRYCOLLECTIONZ_KEYWORD_SEGMENT.clone()),
            "GeometrycollectionzmKeywordSegment" => Some(GEOMETRYCOLLECTIONZM_KEYWORD_SEGMENT.clone()),
            "GlobKeywordSegment" => Some(GLOB_KEYWORD_SEGMENT.clone()),
            "GlobOperatorSegment" => Some(GLOB_OPERATOR_SEGMENT.clone()),
            "GlobalKeywordSegment" => Some(GLOBAL_KEYWORD_SEGMENT.clone()),
            "GrantKeywordSegment" => Some(GRANT_KEYWORD_SEGMENT.clone()),
            "GrantedKeywordSegment" => Some(GRANTED_KEYWORD_SEGMENT.clone()),
            "GrantsKeywordSegment" => Some(GRANTS_KEYWORD_SEGMENT.clone()),
            "GreaterThanOrEqualToSegment" => Some(GREATER_THAN_OR_EQUAL_TO_SEGMENT.clone()),
            "GreaterThanSegment" => Some(GREATER_THAN_SEGMENT.clone()),
            "GreatestKeywordSegment" => Some(GREATEST_KEYWORD_SEGMENT.clone()),
            "GroupByClauseSegment" => Some(GROUP_BY_CLAUSE_SEGMENT.clone()),
            "GroupByClauseTerminatorGrammar" => Some(GROUP_BY_CLAUSE_TERMINATOR_GRAMMAR.clone()),
            "GroupKeywordSegment" => Some(GROUP_KEYWORD_SEGMENT.clone()),
            "GroupingExpressionList" => Some(GROUPING_EXPRESSION_LIST.clone()),
            "GroupingKeywordSegment" => Some(GROUPING_KEYWORD_SEGMENT.clone()),
            "GroupingSetsClauseSegment" => Some(GROUPING_SETS_CLAUSE_SEGMENT.clone()),
            "GroupsKeywordSegment" => Some(GROUPS_KEYWORD_SEGMENT.clone()),
            "HandlerKeywordSegment" => Some(HANDLER_KEYWORD_SEGMENT.clone()),
            "HashKeywordSegment" => Some(HASH_KEYWORD_SEGMENT.clone()),
            "HashesKeywordSegment" => Some(HASHES_KEYWORD_SEGMENT.clone()),
            "HavingClauseSegment" => Some(HAVING_CLAUSE_SEGMENT.clone()),
            "HavingClauseTerminatorGrammar" => Some(HAVING_CLAUSE_TERMINATOR_GRAMMAR.clone()),
            "HavingKeywordSegment" => Some(HAVING_KEYWORD_SEGMENT.clone()),
            "HeaderKeywordSegment" => Some(HEADER_KEYWORD_SEGMENT.clone()),
            "HeapKeywordSegment" => Some(HEAP_KEYWORD_SEGMENT.clone()),
            "High_priorityKeywordSegment" => Some(HIGH_PRIORITY_KEYWORD_SEGMENT.clone()),
            "HoldKeywordSegment" => Some(HOLD_KEYWORD_SEGMENT.clone()),
            "HoldlockKeywordSegment" => Some(HOLDLOCK_KEYWORD_SEGMENT.clone()),
            "HorizontalJoinKeywordsGrammar" => Some(HORIZONTAL_JOIN_KEYWORDS_GRAMMAR.clone()),
            "HostKeywordSegment" => Some(HOST_KEYWORD_SEGMENT.clone()),
            "HostsKeywordSegment" => Some(HOSTS_KEYWORD_SEGMENT.clone()),
            "HourKeywordSegment" => Some(HOUR_KEYWORD_SEGMENT.clone()),
            "Hour_microsecondKeywordSegment" => Some(HOUR_MICROSECOND_KEYWORD_SEGMENT.clone()),
            "Hour_minuteKeywordSegment" => Some(HOUR_MINUTE_KEYWORD_SEGMENT.clone()),
            "Hour_secondKeywordSegment" => Some(HOUR_SECOND_KEYWORD_SEGMENT.clone()),
            "IcuKeywordSegment" => Some(ICU_KEYWORD_SEGMENT.clone()),
            "IdentifiedKeywordSegment" => Some(IDENTIFIED_KEYWORD_SEGMENT.clone()),
            "IdentifierSegment" => Some(IDENTIFIER_SEGMENT.clone()),
            "IdentityKeywordSegment" => Some(IDENTITY_KEYWORD_SEGMENT.clone()),
            "Identity_insertKeywordSegment" => Some(IDENTITY_INSERT_KEYWORD_SEGMENT.clone()),
            "IdentitycolKeywordSegment" => Some(IDENTITYCOL_KEYWORD_SEGMENT.clone()),
            "IfExistsGrammar" => Some(IF_EXISTS_GRAMMAR.clone()),
            "IfKeywordSegment" => Some(IF_KEYWORD_SEGMENT.clone()),
            "IfNotExistsGrammar" => Some(IF_NOT_EXISTS_GRAMMAR.clone()),
            "IgnoreKeywordSegment" => Some(IGNORE_KEYWORD_SEGMENT.clone()),
            "IgnoreRespectNullsGrammar" => Some(IGNORE_RESPECT_NULLS_GRAMMAR.clone()),
            "IlikeKeywordSegment" => Some(ILIKE_KEYWORD_SEGMENT.clone()),
            "ImmediateKeywordSegment" => Some(IMMEDIATE_KEYWORD_SEGMENT.clone()),
            "ImmutableKeywordSegment" => Some(IMMUTABLE_KEYWORD_SEGMENT.clone()),
            "ImplicitIndent" => Some(IMPLICIT_INDENT.clone()),
            "ImplicitKeywordSegment" => Some(IMPLICIT_KEYWORD_SEGMENT.clone()),
            "ImportForeignSchemaGrammar" => Some(IMPORT_FOREIGN_SCHEMA_GRAMMAR.clone()),
            "ImportForeignSchemaStatementSegment" => Some(IMPORT_FOREIGN_SCHEMA_STATEMENT_SEGMENT.clone()),
            "ImportKeywordSegment" => Some(IMPORT_KEYWORD_SEGMENT.clone()),
            "ImportedKeywordSegment" => Some(IMPORTED_KEYWORD_SEGMENT.clone()),
            "InKeywordSegment" => Some(IN_KEYWORD_SEGMENT.clone()),
            "InOperatorGrammar" => Some(IN_OPERATOR_GRAMMAR.clone()),
            "IncludeKeywordSegment" => Some(INCLUDE_KEYWORD_SEGMENT.clone()),
            "IncludingKeywordSegment" => Some(INCLUDING_KEYWORD_SEGMENT.clone()),
            "IncrementKeywordSegment" => Some(INCREMENT_KEYWORD_SEGMENT.clone()),
            "Indent" => Some(INDENT.clone()),
            "IndexAccessMethodSegment" => Some(INDEX_ACCESS_METHOD_SEGMENT.clone()),
            "IndexColumnDefinitionSegment" => Some(INDEX_COLUMN_DEFINITION_SEGMENT.clone()),
            "IndexElementOptionsSegment" => Some(INDEX_ELEMENT_OPTIONS_SEGMENT.clone()),
            "IndexElementSegment" => Some(INDEX_ELEMENT_SEGMENT.clone()),
            "IndexKeywordSegment" => Some(INDEX_KEYWORD_SEGMENT.clone()),
            "IndexParametersSegment" => Some(INDEX_PARAMETERS_SEGMENT.clone()),
            "IndexReferenceSegment" => Some(INDEX_REFERENCE_SEGMENT.clone()),
            "Index_cleanupKeywordSegment" => Some(INDEX_CLEANUP_KEYWORD_SEGMENT.clone()),
            "IndexesKeywordSegment" => Some(INDEXES_KEYWORD_SEGMENT.clone()),
            "InetKeywordSegment" => Some(INET_KEYWORD_SEGMENT.clone()),
            "InfileKeywordSegment" => Some(INFILE_KEYWORD_SEGMENT.clone()),
            "InfixKeywordSegment" => Some(INFIX_KEYWORD_SEGMENT.clone()),
            "InheritKeywordSegment" => Some(INHERIT_KEYWORD_SEGMENT.clone()),
            "InheritsKeywordSegment" => Some(INHERITS_KEYWORD_SEGMENT.clone()),
            "InitializeKeywordSegment" => Some(INITIALIZE_KEYWORD_SEGMENT.clone()),
            "InitiallyKeywordSegment" => Some(INITIALLY_KEYWORD_SEGMENT.clone()),
            "InlineKeywordSegment" => Some(INLINE_KEYWORD_SEGMENT.clone()),
            "InnerKeywordSegment" => Some(INNER_KEYWORD_SEGMENT.clone()),
            "InoutKeywordSegment" => Some(INOUT_KEYWORD_SEGMENT.clone()),
            "InputKeywordSegment" => Some(INPUT_KEYWORD_SEGMENT.clone()),
            "InsensitiveKeywordSegment" => Some(INSENSITIVE_KEYWORD_SEGMENT.clone()),
            "InsertKeywordSegment" => Some(INSERT_KEYWORD_SEGMENT.clone()),
            "InsertStatementSegment" => Some(INSERT_STATEMENT_SEGMENT.clone()),
            "Insert_idKeywordSegment" => Some(INSERT_ID_KEYWORD_SEGMENT.clone()),
            "InsteadKeywordSegment" => Some(INSTEAD_KEYWORD_SEGMENT.clone()),
            "Int1KeywordSegment" => Some(INT1_KEYWORD_SEGMENT.clone()),
            "Int2KeywordSegment" => Some(INT2_KEYWORD_SEGMENT.clone()),
            "Int3KeywordSegment" => Some(INT3_KEYWORD_SEGMENT.clone()),
            "Int4KeywordSegment" => Some(INT4_KEYWORD_SEGMENT.clone()),
            "Int4rangeKeywordSegment" => Some(INT4RANGE_KEYWORD_SEGMENT.clone()),
            "Int8KeywordSegment" => Some(INT8_KEYWORD_SEGMENT.clone()),
            "Int8rangeKeywordSegment" => Some(INT8RANGE_KEYWORD_SEGMENT.clone()),
            "IntKeywordSegment" => Some(INT_KEYWORD_SEGMENT.clone()),
            "IntegerKeywordSegment" => Some(INTEGER_KEYWORD_SEGMENT.clone()),
            "IntegrationKeywordSegment" => Some(INTEGRATION_KEYWORD_SEGMENT.clone()),
            "IntegrationsKeywordSegment" => Some(INTEGRATIONS_KEYWORD_SEGMENT.clone()),
            "IntersectKeywordSegment" => Some(INTERSECT_KEYWORD_SEGMENT.clone()),
            "IntervalExpressionSegment" => Some(INTERVAL_EXPRESSION_SEGMENT.clone()),
            "IntervalKeywordSegment" => Some(INTERVAL_KEYWORD_SEGMENT.clone()),
            "IntervalUnitsGrammar" => Some(INTERVAL_UNITS_GRAMMAR.clone()),
            "IntoClauseSegment" => Some(INTO_CLAUSE_SEGMENT.clone()),
            "IntoKeywordSegment" => Some(INTO_KEYWORD_SEGMENT.clone()),
            "InvokerKeywordSegment" => Some(INVOKER_KEYWORD_SEGMENT.clone()),
            "IsClauseGrammar" => Some(IS_CLAUSE_GRAMMAR.clone()),
            "IsDistinctFromGrammar" => Some(IS_DISTINCT_FROM_GRAMMAR.clone()),
            "IsKeywordSegment" => Some(IS_KEYWORD_SEGMENT.clone()),
            "IsNullGrammar" => Some(IS_NULL_GRAMMAR.clone()),
            "Is_superuserKeywordSegment" => Some(IS_SUPERUSER_KEYWORD_SEGMENT.clone()),
            "Is_templateKeywordSegment" => Some(IS_TEMPLATE_KEYWORD_SEGMENT.clone()),
            "IsamKeywordSegment" => Some(ISAM_KEYWORD_SEGMENT.clone()),
            "IsnullKeywordSegment" => Some(ISNULL_KEYWORD_SEGMENT.clone()),
            "IsolationKeywordSegment" => Some(ISOLATION_KEYWORD_SEGMENT.clone()),
            "IterateKeywordSegment" => Some(ITERATE_KEYWORD_SEGMENT.clone()),
            "JoinClauseSegment" => Some(JOIN_CLAUSE_SEGMENT.clone()),
            "JoinKeywordSegment" => Some(JOIN_KEYWORD_SEGMENT.clone()),
            "JoinKeywordsGrammar" => Some(JOIN_KEYWORDS_GRAMMAR.clone()),
            "JoinLikeClauseGrammar" => Some(JOIN_LIKE_CLAUSE_GRAMMAR.clone()),
            "JoinOnConditionSegment" => Some(JOIN_ON_CONDITION_SEGMENT.clone()),
            "JoinTypeKeywordsGrammar" => Some(JOIN_TYPE_KEYWORDS_GRAMMAR.clone()),
            "JoinUsingConditionGrammar" => Some(JOIN_USING_CONDITION_GRAMMAR.clone()),
            "JsonKeywordSegment" => Some(JSON_KEYWORD_SEGMENT.clone()),
            "JsonOperatorSegment" => Some(JSON_OPERATOR_SEGMENT.clone()),
            "JsonTestGrammar" => Some(JSON_TEST_GRAMMAR.clone()),
            "JsonTypeGrammar" => Some(JSON_TYPE_GRAMMAR.clone()),
            "JsonUniqueKeysGrammar" => Some(JSON_UNIQUE_KEYS_GRAMMAR.clone()),
            "JsonbKeywordSegment" => Some(JSONB_KEYWORD_SEGMENT.clone()),
            "KeyKeywordSegment" => Some(KEY_KEYWORD_SEGMENT.clone()),
            "KeysKeywordSegment" => Some(KEYS_KEYWORD_SEGMENT.clone()),
            "KeywordSegment" => Some(KEYWORD_SEGMENT.clone()),
            "KillKeywordSegment" => Some(KILL_KEYWORD_SEGMENT.clone()),
            "LabelKeywordSegment" => Some(LABEL_KEYWORD_SEGMENT.clone()),
            "LambdaArrowSegment" => Some(LAMBDA_ARROW_SEGMENT.clone()),
            "LambdaExpressionSegment" => Some(LAMBDA_EXPRESSION_SEGMENT.clone()),
            "LancompilerKeywordSegment" => Some(LANCOMPILER_KEYWORD_SEGMENT.clone()),
            "LanguageClauseSegment" => Some(LANGUAGE_CLAUSE_SEGMENT.clone()),
            "LanguageKeywordSegment" => Some(LANGUAGE_KEYWORD_SEGMENT.clone()),
            "LargeKeywordSegment" => Some(LARGE_KEYWORD_SEGMENT.clone()),
            "LastKeywordSegment" => Some(LAST_KEYWORD_SEGMENT.clone()),
            "Last_insert_idKeywordSegment" => Some(LAST_INSERT_ID_KEYWORD_SEGMENT.clone()),
            "LateralKeywordSegment" => Some(LATERAL_KEYWORD_SEGMENT.clone()),
            "Lc_collateKeywordSegment" => Some(LC_COLLATE_KEYWORD_SEGMENT.clone()),
            "Lc_ctypeKeywordSegment" => Some(LC_CTYPE_KEYWORD_SEGMENT.clone()),
            "LeadingKeywordSegment" => Some(LEADING_KEYWORD_SEGMENT.clone()),
            "LeakproofKeywordSegment" => Some(LEAKPROOF_KEYWORD_SEGMENT.clone()),
            "LeastKeywordSegment" => Some(LEAST_KEYWORD_SEGMENT.clone()),
            "LeaveKeywordSegment" => Some(LEAVE_KEYWORD_SEGMENT.clone()),
            "LeftKeywordSegment" => Some(LEFT_KEYWORD_SEGMENT.clone()),
            "LeftargKeywordSegment" => Some(LEFTARG_KEYWORD_SEGMENT.clone()),
            "LessKeywordSegment" => Some(LESS_KEYWORD_SEGMENT.clone()),
            "LessThanOrEqualToSegment" => Some(LESS_THAN_OR_EQUAL_TO_SEGMENT.clone()),
            "LessThanSegment" => Some(LESS_THAN_SEGMENT.clone()),
            "LevelKeywordSegment" => Some(LEVEL_KEYWORD_SEGMENT.clone()),
            "LibcKeywordSegment" => Some(LIBC_KEYWORD_SEGMENT.clone()),
            "LikeExpressionGrammar" => Some(LIKE_EXPRESSION_GRAMMAR.clone()),
            "LikeGrammar" => Some(LIKE_GRAMMAR.clone()),
            "LikeKeywordSegment" => Some(LIKE_KEYWORD_SEGMENT.clone()),
            "LikeOperatorSegment" => Some(LIKE_OPERATOR_SEGMENT.clone()),
            "LikeOptionSegment" => Some(LIKE_OPTION_SEGMENT.clone()),
            "LimitClauseSegment" => Some(LIMIT_CLAUSE_SEGMENT.clone()),
            "LimitKeywordSegment" => Some(LIMIT_KEYWORD_SEGMENT.clone()),
            "LineKeywordSegment" => Some(LINE_KEYWORD_SEGMENT.clone()),
            "LinenoKeywordSegment" => Some(LINENO_KEYWORD_SEGMENT.clone()),
            "LinesKeywordSegment" => Some(LINES_KEYWORD_SEGMENT.clone()),
            "LinestringKeywordSegment" => Some(LINESTRING_KEYWORD_SEGMENT.clone()),
            "LinestringmKeywordSegment" => Some(LINESTRINGM_KEYWORD_SEGMENT.clone()),
            "LinestringzKeywordSegment" => Some(LINESTRINGZ_KEYWORD_SEGMENT.clone()),
            "LinestringzmKeywordSegment" => Some(LINESTRINGZM_KEYWORD_SEGMENT.clone()),
            "ListComprehensionExpressionSegment" => Some(LIST_COMPREHENSION_EXPRESSION_SEGMENT.clone()),
            "ListComprehensionGrammar" => Some(LIST_COMPREHENSION_GRAMMAR.clone()),
            "ListKeywordSegment" => Some(LIST_KEYWORD_SEGMENT.clone()),
            "ListenKeywordSegment" => Some(LISTEN_KEYWORD_SEGMENT.clone()),
            "ListenStatementSegment" => Some(LISTEN_STATEMENT_SEGMENT.clone()),
            "LiteralGrammar" => Some(LITERAL_GRAMMAR.clone()),
            "LiteralKeywordSegment" => Some(LITERAL_KEYWORD_SEGMENT.clone()),
            "LiteralSegment" => Some(LITERAL_SEGMENT.clone()),
            "LoadKeywordSegment" => Some(LOAD_KEYWORD_SEGMENT.clone()),
            "LoadStatementSegment" => Some(LOAD_STATEMENT_SEGMENT.clone()),
            "LocalAliasSegment" => Some(LOCAL_ALIAS_SEGMENT.clone()),
            "LocalKeywordSegment" => Some(LOCAL_KEYWORD_SEGMENT.clone()),
            "LocaleKeywordSegment" => Some(LOCALE_KEYWORD_SEGMENT.clone()),
            "LocaltimeKeywordSegment" => Some(LOCALTIME_KEYWORD_SEGMENT.clone()),
            "LocaltimestampKeywordSegment" => Some(LOCALTIMESTAMP_KEYWORD_SEGMENT.clone()),
            "LocationKeywordSegment" => Some(LOCATION_KEYWORD_SEGMENT.clone()),
            "LockKeywordSegment" => Some(LOCK_KEYWORD_SEGMENT.clone()),
            "LockTableStatementSegment" => Some(LOCK_TABLE_STATEMENT_SEGMENT.clone()),
            "LockedKeywordSegment" => Some(LOCKED_KEYWORD_SEGMENT.clone()),
            "LocksKeywordSegment" => Some(LOCKS_KEYWORD_SEGMENT.clone()),
            "LoggedKeywordSegment" => Some(LOGGED_KEYWORD_SEGMENT.clone()),
            "LoginKeywordSegment" => Some(LOGIN_KEYWORD_SEGMENT.clone()),
            "LogsKeywordSegment" => Some(LOGS_KEYWORD_SEGMENT.clone()),
            "LongKeywordSegment" => Some(LONG_KEYWORD_SEGMENT.clone()),
            "LongblobKeywordSegment" => Some(LONGBLOB_KEYWORD_SEGMENT.clone()),
            "LongtextKeywordSegment" => Some(LONGTEXT_KEYWORD_SEGMENT.clone()),
            "LoopKeywordSegment" => Some(LOOP_KEYWORD_SEGMENT.clone()),
            "Low_priorityKeywordSegment" => Some(LOW_PRIORITY_KEYWORD_SEGMENT.clone()),
            "LsegKeywordSegment" => Some(LSEG_KEYWORD_SEGMENT.clone()),
            "MLTableExpressionSegment" => Some(M_L_TABLE_EXPRESSION_SEGMENT.clone()),
            "Macaddr8KeywordSegment" => Some(MACADDR8_KEYWORD_SEGMENT.clone()),
            "MacaddrKeywordSegment" => Some(MACADDR_KEYWORD_SEGMENT.clone()),
            "MacroKeywordSegment" => Some(MACRO_KEYWORD_SEGMENT.clone()),
            "MainKeywordSegment" => Some(MAIN_KEYWORD_SEGMENT.clone()),
            "ManageKeywordSegment" => Some(MANAGE_KEYWORD_SEGMENT.clone()),
            "MapKeywordSegment" => Some(MAP_KEYWORD_SEGMENT.clone()),
            "MapTypeSchemaSegment" => Some(MAP_TYPE_SCHEMA_SEGMENT.clone()),
            "MapTypeSegment" => Some(MAP_TYPE_SEGMENT.clone()),
            "MappingKeywordSegment" => Some(MAPPING_KEYWORD_SEGMENT.clone()),
            "MaskingKeywordSegment" => Some(MASKING_KEYWORD_SEGMENT.clone()),
            "MatchConditionSegment" => Some(MATCH_CONDITION_SEGMENT.clone()),
            "MatchKeywordSegment" => Some(MATCH_KEYWORD_SEGMENT.clone()),
            "MatchedKeywordSegment" => Some(MATCHED_KEYWORD_SEGMENT.clone()),
            "MaterializedKeywordSegment" => Some(MATERIALIZED_KEYWORD_SEGMENT.clone()),
            "Max_rowsKeywordSegment" => Some(MAX_ROWS_KEYWORD_SEGMENT.clone()),
            "MaxextentsKeywordSegment" => Some(MAXEXTENTS_KEYWORD_SEGMENT.clone()),
            "MaxvalueKeywordSegment" => Some(MAXVALUE_KEYWORD_SEGMENT.clone()),
            "McvKeywordSegment" => Some(MCV_KEYWORD_SEGMENT.clone()),
            "MediumblobKeywordSegment" => Some(MEDIUMBLOB_KEYWORD_SEGMENT.clone()),
            "MediumintKeywordSegment" => Some(MEDIUMINT_KEYWORD_SEGMENT.clone()),
            "MediumtextKeywordSegment" => Some(MEDIUMTEXT_KEYWORD_SEGMENT.clone()),
            "MergeDeleteClauseSegment" => Some(MERGE_DELETE_CLAUSE_SEGMENT.clone()),
            "MergeInsertClauseSegment" => Some(MERGE_INSERT_CLAUSE_SEGMENT.clone()),
            "MergeIntoLiteralGrammar" => Some(MERGE_INTO_LITERAL_GRAMMAR.clone()),
            "MergeKeywordSegment" => Some(MERGE_KEYWORD_SEGMENT.clone()),
            "MergeMatchSegment" => Some(MERGE_MATCH_SEGMENT.clone()),
            "MergeMatchedClauseSegment" => Some(MERGE_MATCHED_CLAUSE_SEGMENT.clone()),
            "MergeNotMatchedClauseSegment" => Some(MERGE_NOT_MATCHED_CLAUSE_SEGMENT.clone()),
            "MergeStatementSegment" => Some(MERGE_STATEMENT_SEGMENT.clone()),
            "MergeUpdateClauseSegment" => Some(MERGE_UPDATE_CLAUSE_SEGMENT.clone()),
            "MergesKeywordSegment" => Some(MERGES_KEYWORD_SEGMENT.clone()),
            "MetaCommandQueryBufferSegment" => Some(META_COMMAND_QUERY_BUFFER_SEGMENT.clone()),
            "MetaCommandQueryBufferStatement" => Some(META_COMMAND_QUERY_BUFFER_STATEMENT.clone()),
            "MethodKeywordSegment" => Some(METHOD_KEYWORD_SEGMENT.clone()),
            "MiddleintKeywordSegment" => Some(MIDDLEINT_KEYWORD_SEGMENT.clone()),
            "MillisecondKeywordSegment" => Some(MILLISECOND_KEYWORD_SEGMENT.clone()),
            "Min_rowsKeywordSegment" => Some(MIN_ROWS_KEYWORD_SEGMENT.clone()),
            "MinusKeywordSegment" => Some(MINUS_KEYWORD_SEGMENT.clone()),
            "MinusSegment" => Some(MINUS_SEGMENT.clone()),
            "MinuteKeywordSegment" => Some(MINUTE_KEYWORD_SEGMENT.clone()),
            "Minute_microsecondKeywordSegment" => Some(MINUTE_MICROSECOND_KEYWORD_SEGMENT.clone()),
            "Minute_secondKeywordSegment" => Some(MINUTE_SECOND_KEYWORD_SEGMENT.clone()),
            "MinvalueKeywordSegment" => Some(MINVALUE_KEYWORD_SEGMENT.clone()),
            "MlKeywordSegment" => Some(ML_KEYWORD_SEGMENT.clone()),
            "MlslabelKeywordSegment" => Some(MLSLABEL_KEYWORD_SEGMENT.clone()),
            "ModeKeywordSegment" => Some(MODE_KEYWORD_SEGMENT.clone()),
            "ModelKeywordSegment" => Some(MODEL_KEYWORD_SEGMENT.clone()),
            "ModifyKeywordSegment" => Some(MODIFY_KEYWORD_SEGMENT.clone()),
            "ModuloSegment" => Some(MODULO_SEGMENT.clone()),
            "ModulusKeywordSegment" => Some(MODULUS_KEYWORD_SEGMENT.clone()),
            "MoneyKeywordSegment" => Some(MONEY_KEYWORD_SEGMENT.clone()),
            "MonitorKeywordSegment" => Some(MONITOR_KEYWORD_SEGMENT.clone()),
            "MonthKeywordSegment" => Some(MONTH_KEYWORD_SEGMENT.clone()),
            "MonthnameKeywordSegment" => Some(MONTHNAME_KEYWORD_SEGMENT.clone()),
            "MoveKeywordSegment" => Some(MOVE_KEYWORD_SEGMENT.clone()),
            "MulticurveKeywordSegment" => Some(MULTICURVE_KEYWORD_SEGMENT.clone()),
            "MultilineConcatenateDelimiterGrammar" => Some(MULTILINE_CONCATENATE_DELIMITER_GRAMMAR.clone()),
            "MultilineConcatenateNewline" => Some(MULTILINE_CONCATENATE_NEWLINE.clone()),
            "MultilinestringKeywordSegment" => Some(MULTILINESTRING_KEYWORD_SEGMENT.clone()),
            "MultilinestringmKeywordSegment" => Some(MULTILINESTRINGM_KEYWORD_SEGMENT.clone()),
            "MultilinestringzKeywordSegment" => Some(MULTILINESTRINGZ_KEYWORD_SEGMENT.clone()),
            "MultilinestringzmKeywordSegment" => Some(MULTILINESTRINGZM_KEYWORD_SEGMENT.clone()),
            "MultiplySegment" => Some(MULTIPLY_SEGMENT.clone()),
            "MultipointKeywordSegment" => Some(MULTIPOINT_KEYWORD_SEGMENT.clone()),
            "MultipointmKeywordSegment" => Some(MULTIPOINTM_KEYWORD_SEGMENT.clone()),
            "MultipointzKeywordSegment" => Some(MULTIPOINTZ_KEYWORD_SEGMENT.clone()),
            "MultipointzmKeywordSegment" => Some(MULTIPOINTZM_KEYWORD_SEGMENT.clone()),
            "MultipolygonKeywordSegment" => Some(MULTIPOLYGON_KEYWORD_SEGMENT.clone()),
            "MultipolygonmKeywordSegment" => Some(MULTIPOLYGONM_KEYWORD_SEGMENT.clone()),
            "MultipolygonzKeywordSegment" => Some(MULTIPOLYGONZ_KEYWORD_SEGMENT.clone()),
            "MultipolygonzmKeywordSegment" => Some(MULTIPOLYGONZM_KEYWORD_SEGMENT.clone()),
            "MultisurfaceKeywordSegment" => Some(MULTISURFACE_KEYWORD_SEGMENT.clone()),
            "MyisamKeywordSegment" => Some(MYISAM_KEYWORD_SEGMENT.clone()),
            "NakedIdentifierFullSegment" => Some(NAKED_IDENTIFIER_FULL_SEGMENT.clone()),
            "NakedIdentifierSegment" => Some(NAKED_IDENTIFIER_SEGMENT.clone()),
            "NameKeywordSegment" => Some(NAME_KEYWORD_SEGMENT.clone()),
            "NamedArgumentSegment" => Some(NAMED_ARGUMENT_SEGMENT.clone()),
            "NamedWindowExpressionSegment" => Some(NAMED_WINDOW_EXPRESSION_SEGMENT.clone()),
            "NamedWindowSegment" => Some(NAMED_WINDOW_SEGMENT.clone()),
            "NamesKeywordSegment" => Some(NAMES_KEYWORD_SEGMENT.clone()),
            "NanKeywordSegment" => Some(NAN_KEYWORD_SEGMENT.clone()),
            "NanLiteralSegment" => Some(NAN_LITERAL_SEGMENT.clone()),
            "NationalKeywordSegment" => Some(NATIONAL_KEYWORD_SEGMENT.clone()),
            "NaturalJoinKeywordsGrammar" => Some(NATURAL_JOIN_KEYWORDS_GRAMMAR.clone()),
            "NaturalKeywordSegment" => Some(NATURAL_KEYWORD_SEGMENT.clone()),
            "NcharKeywordSegment" => Some(NCHAR_KEYWORD_SEGMENT.clone()),
            "NdistinctKeywordSegment" => Some(NDISTINCT_KEYWORD_SEGMENT.clone()),
            "NegativeSegment" => Some(NEGATIVE_SEGMENT.clone()),
            "NegatorKeywordSegment" => Some(NEGATOR_KEYWORD_SEGMENT.clone()),
            "NestedJoinGrammar" => Some(NESTED_JOIN_GRAMMAR.clone()),
            "NewKeywordSegment" => Some(NEW_KEYWORD_SEGMENT.clone()),
            "NewlineSegment" => Some(NEWLINE_SEGMENT.clone()),
            "NextKeywordSegment" => Some(NEXT_KEYWORD_SEGMENT.clone()),
            "NfcKeywordSegment" => Some(NFC_KEYWORD_SEGMENT.clone()),
            "NfdKeywordSegment" => Some(NFD_KEYWORD_SEGMENT.clone()),
            "NfkcKeywordSegment" => Some(NFKC_KEYWORD_SEGMENT.clone()),
            "NfkdKeywordSegment" => Some(NFKD_KEYWORD_SEGMENT.clone()),
            "NoKeywordSegment" => Some(NO_KEYWORD_SEGMENT.clone()),
            "No_write_to_binlogKeywordSegment" => Some(NO_WRITE_TO_BINLOG_KEYWORD_SEGMENT.clone()),
            "NoauditKeywordSegment" => Some(NOAUDIT_KEYWORD_SEGMENT.clone()),
            "NobypassrlsKeywordSegment" => Some(NOBYPASSRLS_KEYWORD_SEGMENT.clone()),
            "NocacheKeywordSegment" => Some(NOCACHE_KEYWORD_SEGMENT.clone()),
            "NocheckKeywordSegment" => Some(NOCHECK_KEYWORD_SEGMENT.clone()),
            "NocompressKeywordSegment" => Some(NOCOMPRESS_KEYWORD_SEGMENT.clone()),
            "NocreatedbKeywordSegment" => Some(NOCREATEDB_KEYWORD_SEGMENT.clone()),
            "NocreateroleKeywordSegment" => Some(NOCREATEROLE_KEYWORD_SEGMENT.clone()),
            "NocreateuserKeywordSegment" => Some(NOCREATEUSER_KEYWORD_SEGMENT.clone()),
            "NocycleKeywordSegment" => Some(NOCYCLE_KEYWORD_SEGMENT.clone()),
            "NoinheritKeywordSegment" => Some(NOINHERIT_KEYWORD_SEGMENT.clone()),
            "NologinKeywordSegment" => Some(NOLOGIN_KEYWORD_SEGMENT.clone()),
            "NonSetSelectableGrammar" => Some(NON_SET_SELECTABLE_GRAMMAR.clone()),
            "NonStandardJoinTypeKeywordsGrammar" => Some(NON_STANDARD_JOIN_TYPE_KEYWORDS_GRAMMAR.clone()),
            "NonWithNonSelectableGrammar" => Some(NON_WITH_NON_SELECTABLE_GRAMMAR.clone()),
            "NonWithSelectableGrammar" => Some(NON_WITH_SELECTABLE_GRAMMAR.clone()),
            "NonclusteredKeywordSegment" => Some(NONCLUSTERED_KEYWORD_SEGMENT.clone()),
            "NoneKeywordSegment" => Some(NONE_KEYWORD_SEGMENT.clone()),
            "NoorderKeywordSegment" => Some(NOORDER_KEYWORD_SEGMENT.clone()),
            "NoreplicationKeywordSegment" => Some(NOREPLICATION_KEYWORD_SEGMENT.clone()),
            "NormalizeKeywordSegment" => Some(NORMALIZE_KEYWORD_SEGMENT.clone()),
            "NormalizedGrammar" => Some(NORMALIZED_GRAMMAR.clone()),
            "NormalizedKeywordSegment" => Some(NORMALIZED_KEYWORD_SEGMENT.clone()),
            "NosuperuserKeywordSegment" => Some(NOSUPERUSER_KEYWORD_SEGMENT.clone()),
            "NotEnforcedGrammar" => Some(NOT_ENFORCED_GRAMMAR.clone()),
            "NotEqualToSegment" => Some(NOT_EQUAL_TO_SEGMENT.clone()),
            "NotExtendLeftSegment" => Some(NOT_EXTEND_LEFT_SEGMENT.clone()),
            "NotExtendRightSegment" => Some(NOT_EXTEND_RIGHT_SEGMENT.clone()),
            "NotKeywordSegment" => Some(NOT_KEYWORD_SEGMENT.clone()),
            "NotNullGrammar" => Some(NOT_NULL_GRAMMAR.clone()),
            "NotOperatorGrammar" => Some(NOT_OPERATOR_GRAMMAR.clone()),
            "NothingKeywordSegment" => Some(NOTHING_KEYWORD_SEGMENT.clone()),
            "NotifyKeywordSegment" => Some(NOTIFY_KEYWORD_SEGMENT.clone()),
            "NotifyStatementSegment" => Some(NOTIFY_STATEMENT_SEGMENT.clone()),
            "NotnullKeywordSegment" => Some(NOTNULL_KEYWORD_SEGMENT.clone()),
            "NowaitKeywordSegment" => Some(NOWAIT_KEYWORD_SEGMENT.clone()),
            "NullKeywordSegment" => Some(NULL_KEYWORD_SEGMENT.clone()),
            "NullLiteralSegment" => Some(NULL_LITERAL_SEGMENT.clone()),
            "NullifKeywordSegment" => Some(NULLIF_KEYWORD_SEGMENT.clone()),
            "NullsKeywordSegment" => Some(NULLS_KEYWORD_SEGMENT.clone()),
            "NumericKeywordSegment" => Some(NUMERIC_KEYWORD_SEGMENT.clone()),
            "NumericLiteralSegment" => Some(NUMERIC_LITERAL_SEGMENT.clone()),
            "NumrangeKeywordSegment" => Some(NUMRANGE_KEYWORD_SEGMENT.clone()),
            "ObjectKeywordSegment" => Some(OBJECT_KEYWORD_SEGMENT.clone()),
            "ObjectLiteralElementSegment" => Some(OBJECT_LITERAL_ELEMENT_SEGMENT.clone()),
            "ObjectLiteralSegment" => Some(OBJECT_LITERAL_SEGMENT.clone()),
            "ObjectReferenceDelimiterGrammar" => Some(OBJECT_REFERENCE_DELIMITER_GRAMMAR.clone()),
            "ObjectReferenceSegment" => Some(OBJECT_REFERENCE_SEGMENT.clone()),
            "ObjectReferenceTerminatorGrammar" => Some(OBJECT_REFERENCE_TERMINATOR_GRAMMAR.clone()),
            "ObjectsKeywordSegment" => Some(OBJECTS_KEYWORD_SEGMENT.clone()),
            "OfKeywordSegment" => Some(OF_KEYWORD_SEGMENT.clone()),
            "OffKeywordSegment" => Some(OFF_KEYWORD_SEGMENT.clone()),
            "OfflineKeywordSegment" => Some(OFFLINE_KEYWORD_SEGMENT.clone()),
            "OffsetClauseSegment" => Some(OFFSET_CLAUSE_SEGMENT.clone()),
            "OffsetKeywordSegment" => Some(OFFSET_KEYWORD_SEGMENT.clone()),
            "OffsetsKeywordSegment" => Some(OFFSETS_KEYWORD_SEGMENT.clone()),
            "OidsKeywordSegment" => Some(OIDS_KEYWORD_SEGMENT.clone()),
            "OldKeywordSegment" => Some(OLD_KEYWORD_SEGMENT.clone()),
            "OnKeywordAsIdentifierSegment" => Some(ON_KEYWORD_AS_IDENTIFIER_SEGMENT.clone()),
            "OnKeywordSegment" => Some(ON_KEYWORD_SEGMENT.clone()),
            "OnlineKeywordSegment" => Some(ONLINE_KEYWORD_SEGMENT.clone()),
            "OnlyKeywordSegment" => Some(ONLY_KEYWORD_SEGMENT.clone()),
            "OpendatasourceKeywordSegment" => Some(OPENDATASOURCE_KEYWORD_SEGMENT.clone()),
            "OpenqueryKeywordSegment" => Some(OPENQUERY_KEYWORD_SEGMENT.clone()),
            "OpenrowsetKeywordSegment" => Some(OPENROWSET_KEYWORD_SEGMENT.clone()),
            "OpenxmlKeywordSegment" => Some(OPENXML_KEYWORD_SEGMENT.clone()),
            "OperateKeywordSegment" => Some(OPERATE_KEYWORD_SEGMENT.clone()),
            "OperationClassReferenceSegment" => Some(OPERATION_CLASS_REFERENCE_SEGMENT.clone()),
            "OperationKeywordSegment" => Some(OPERATION_KEYWORD_SEGMENT.clone()),
            "OperatorClassReferenceSegment" => Some(OPERATOR_CLASS_REFERENCE_SEGMENT.clone()),
            "OperatorKeywordSegment" => Some(OPERATOR_KEYWORD_SEGMENT.clone()),
            "OptimizeKeywordSegment" => Some(OPTIMIZE_KEYWORD_SEGMENT.clone()),
            "OptionKeywordSegment" => Some(OPTION_KEYWORD_SEGMENT.clone()),
            "OptionallyKeywordSegment" => Some(OPTIONALLY_KEYWORD_SEGMENT.clone()),
            "OptionsGrammar" => Some(OPTIONS_GRAMMAR.clone()),
            "OptionsKeywordSegment" => Some(OPTIONS_KEYWORD_SEGMENT.clone()),
            "OptionsListGrammar" => Some(OPTIONS_LIST_GRAMMAR.clone()),
            "OrIgnoreGrammar" => Some(OR_IGNORE_GRAMMAR.clone()),
            "OrKeywordSegment" => Some(OR_KEYWORD_SEGMENT.clone()),
            "OrOperatorGrammar" => Some(OR_OPERATOR_GRAMMAR.clone()),
            "OrReplaceGrammar" => Some(OR_REPLACE_GRAMMAR.clone()),
            "OrderByClauseSegment" => Some(ORDER_BY_CLAUSE_SEGMENT.clone()),
            "OrderByClauseTerminators" => Some(ORDER_BY_CLAUSE_TERMINATORS.clone()),
            "OrderKeywordSegment" => Some(ORDER_KEYWORD_SEGMENT.clone()),
            "OrderNoOrderGrammar" => Some(ORDER_NO_ORDER_GRAMMAR.clone()),
            "OrdinalityKeywordSegment" => Some(ORDINALITY_KEYWORD_SEGMENT.clone()),
            "OthersKeywordSegment" => Some(OTHERS_KEYWORD_SEGMENT.clone()),
            "OutKeywordSegment" => Some(OUT_KEYWORD_SEGMENT.clone()),
            "OuterKeywordSegment" => Some(OUTER_KEYWORD_SEGMENT.clone()),
            "OutfileKeywordSegment" => Some(OUTFILE_KEYWORD_SEGMENT.clone()),
            "OverClauseSegment" => Some(OVER_CLAUSE_SEGMENT.clone()),
            "OverKeywordSegment" => Some(OVER_KEYWORD_SEGMENT.clone()),
            "OverlapSegment" => Some(OVERLAP_SEGMENT.clone()),
            "OverlapsClauseSegment" => Some(OVERLAPS_CLAUSE_SEGMENT.clone()),
            "OverlapsKeywordSegment" => Some(OVERLAPS_KEYWORD_SEGMENT.clone()),
            "OverlayKeywordSegment" => Some(OVERLAY_KEYWORD_SEGMENT.clone()),
            "OverridingKeywordSegment" => Some(OVERRIDING_KEYWORD_SEGMENT.clone()),
            "OverwriteKeywordSegment" => Some(OVERWRITE_KEYWORD_SEGMENT.clone()),
            "Overwrite_or_ignoreKeywordSegment" => Some(OVERWRITE_OR_IGNORE_KEYWORD_SEGMENT.clone()),
            "OwnedKeywordSegment" => Some(OWNED_KEYWORD_SEGMENT.clone()),
            "OwnerKeywordSegment" => Some(OWNER_KEYWORD_SEGMENT.clone()),
            "OwnershipKeywordSegment" => Some(OWNERSHIP_KEYWORD_SEGMENT.clone()),
            "Pack_keysKeywordSegment" => Some(PACK_KEYS_KEYWORD_SEGMENT.clone()),
            "ParallelKeywordSegment" => Some(PARALLEL_KEYWORD_SEGMENT.clone()),
            "ParameterNameSegment" => Some(PARAMETER_NAME_SEGMENT.clone()),
            "ParameterSegment" => Some(PARAMETER_SEGMENT.clone()),
            "ParametersKeywordSegment" => Some(PARAMETERS_KEYWORD_SEGMENT.clone()),
            "Parquet_versionKeywordSegment" => Some(PARQUET_VERSION_KEYWORD_SEGMENT.clone()),
            "ParserKeywordSegment" => Some(PARSER_KEYWORD_SEGMENT.clone()),
            "PartialKeywordSegment" => Some(PARTIAL_KEYWORD_SEGMENT.clone()),
            "PartitionBoundSpecSegment" => Some(PARTITION_BOUND_SPEC_SEGMENT.clone()),
            "PartitionClauseSegment" => Some(PARTITION_CLAUSE_SEGMENT.clone()),
            "PartitionKeywordSegment" => Some(PARTITION_KEYWORD_SEGMENT.clone()),
            "Partition_byKeywordSegment" => Some(PARTITION_BY_KEYWORD_SEGMENT.clone()),
            "PassingKeywordSegment" => Some(PASSING_KEYWORD_SEGMENT.clone()),
            "PasswordKeywordSegment" => Some(PASSWORD_KEYWORD_SEGMENT.clone()),
            "PathKeywordSegment" => Some(PATH_KEYWORD_SEGMENT.clone()),
            "PathSegment" => Some(PATH_SEGMENT.clone()),
            "PatternMatchingGrammar" => Some(PATTERN_MATCHING_GRAMMAR.clone()),
            "PctfreeKeywordSegment" => Some(PCTFREE_KEYWORD_SEGMENT.clone()),
            "PermissiveKeywordSegment" => Some(PERMISSIVE_KEYWORD_SEGMENT.clone()),
            "PgTrgmOperatorSegment" => Some(PG_TRGM_OPERATOR_SEGMENT.clone()),
            "Pg_lsnKeywordSegment" => Some(PG_LSN_KEYWORD_SEGMENT.clone()),
            "PgvectorOperatorSegment" => Some(PGVECTOR_OPERATOR_SEGMENT.clone()),
            "PipeKeywordSegment" => Some(PIPE_KEYWORD_SEGMENT.clone()),
            "PipeSegment" => Some(PIPE_SEGMENT.clone()),
            "PivotKeywordSegment" => Some(PIVOT_KEYWORD_SEGMENT.clone()),
            "Pivot_longerKeywordSegment" => Some(PIVOT_LONGER_KEYWORD_SEGMENT.clone()),
            "Pivot_widerKeywordSegment" => Some(PIVOT_WIDER_KEYWORD_SEGMENT.clone()),
            "PlacingKeywordSegment" => Some(PLACING_KEYWORD_SEGMENT.clone()),
            "PlainKeywordSegment" => Some(PLAIN_KEYWORD_SEGMENT.clone()),
            "PlansKeywordSegment" => Some(PLANS_KEYWORD_SEGMENT.clone()),
            "PlusSegment" => Some(PLUS_SEGMENT.clone()),
            "PointKeywordSegment" => Some(POINT_KEYWORD_SEGMENT.clone()),
            "PointmKeywordSegment" => Some(POINTM_KEYWORD_SEGMENT.clone()),
            "PointzKeywordSegment" => Some(POINTZ_KEYWORD_SEGMENT.clone()),
            "PointzmKeywordSegment" => Some(POINTZM_KEYWORD_SEGMENT.clone()),
            "PolicyKeywordSegment" => Some(POLICY_KEYWORD_SEGMENT.clone()),
            "PolygonKeywordSegment" => Some(POLYGON_KEYWORD_SEGMENT.clone()),
            "PolygonmKeywordSegment" => Some(POLYGONM_KEYWORD_SEGMENT.clone()),
            "PolygonzKeywordSegment" => Some(POLYGONZ_KEYWORD_SEGMENT.clone()),
            "PolygonzmKeywordSegment" => Some(POLYGONZM_KEYWORD_SEGMENT.clone()),
            "PolyhedralsurfaceKeywordSegment" => Some(POLYHEDRALSURFACE_KEYWORD_SEGMENT.clone()),
            "PositionKeywordSegment" => Some(POSITION_KEYWORD_SEGMENT.clone()),
            "PositionalKeywordSegment" => Some(POSITIONAL_KEYWORD_SEGMENT.clone()),
            "PositiveSegment" => Some(POSITIVE_SEGMENT.clone()),
            "PostFunctionGrammar" => Some(POST_FUNCTION_GRAMMAR.clone()),
            "PostTableExpressionGrammar" => Some(POST_TABLE_EXPRESSION_GRAMMAR.clone()),
            "PostfixKeywordSegment" => Some(POSTFIX_KEYWORD_SEGMENT.clone()),
            "PostgisOperatorSegment" => Some(POSTGIS_OPERATOR_SEGMENT.clone()),
            "PreTableFunctionKeywordsGrammar" => Some(PRE_TABLE_FUNCTION_KEYWORDS_GRAMMAR.clone()),
            "PrecedingKeywordSegment" => Some(PRECEDING_KEYWORD_SEGMENT.clone()),
            "PrecisionKeywordSegment" => Some(PRECISION_KEYWORD_SEGMENT.clone()),
            "PrefixKeywordSegment" => Some(PREFIX_KEYWORD_SEGMENT.clone()),
            "PreorderKeywordSegment" => Some(PREORDER_KEYWORD_SEGMENT.clone()),
            "PrepareKeywordSegment" => Some(PREPARE_KEYWORD_SEGMENT.clone()),
            "PrepareStatementSegment" => Some(PREPARE_STATEMENT_SEGMENT.clone()),
            "PreparedKeywordSegment" => Some(PREPARED_KEYWORD_SEGMENT.clone()),
            "PreserveKeywordSegment" => Some(PRESERVE_KEYWORD_SEGMENT.clone()),
            "PrimaryKeyGrammar" => Some(PRIMARY_KEY_GRAMMAR.clone()),
            "PrimaryKeywordSegment" => Some(PRIMARY_KEYWORD_SEGMENT.clone()),
            "PrintKeywordSegment" => Some(PRINT_KEYWORD_SEGMENT.clone()),
            "PriorKeywordSegment" => Some(PRIOR_KEYWORD_SEGMENT.clone()),
            "PrivilegesKeywordSegment" => Some(PRIVILEGES_KEYWORD_SEGMENT.clone()),
            "ProcKeywordSegment" => Some(PROC_KEYWORD_SEGMENT.clone()),
            "ProceduralKeywordSegment" => Some(PROCEDURAL_KEYWORD_SEGMENT.clone()),
            "ProcedureKeywordSegment" => Some(PROCEDURE_KEYWORD_SEGMENT.clone()),
            "ProceduresKeywordSegment" => Some(PROCEDURES_KEYWORD_SEGMENT.clone()),
            "ProcessKeywordSegment" => Some(PROCESS_KEYWORD_SEGMENT.clone()),
            "Process_toastKeywordSegment" => Some(PROCESS_TOAST_KEYWORD_SEGMENT.clone()),
            "ProcesslistKeywordSegment" => Some(PROCESSLIST_KEYWORD_SEGMENT.clone()),
            "ProgramKeywordSegment" => Some(PROGRAM_KEYWORD_SEGMENT.clone()),
            "PropertiesNakedIdentifierSegment" => Some(PROPERTIES_NAKED_IDENTIFIER_SEGMENT.clone()),
            "ProviderKeywordSegment" => Some(PROVIDER_KEYWORD_SEGMENT.clone()),
            "PsqlVariableGrammar" => Some(PSQL_VARIABLE_GRAMMAR.clone()),
            "PublicKeywordSegment" => Some(PUBLIC_KEYWORD_SEGMENT.clone()),
            "PublicationKeywordSegment" => Some(PUBLICATION_KEYWORD_SEGMENT.clone()),
            "PublicationObjectsSegment" => Some(PUBLICATION_OBJECTS_SEGMENT.clone()),
            "PublicationReferenceSegment" => Some(PUBLICATION_REFERENCE_SEGMENT.clone()),
            "PublicationTableSegment" => Some(PUBLICATION_TABLE_SEGMENT.clone()),
            "PurgeKeywordSegment" => Some(PURGE_KEYWORD_SEGMENT.clone()),
            "QualifiedNumericLiteralSegment" => Some(QUALIFIED_NUMERIC_LITERAL_SEGMENT.clone()),
            "QualifiedOperatorSegment" => Some(QUALIFIED_OPERATOR_SEGMENT.clone()),
            "QualifyClauseSegment" => Some(QUALIFY_CLAUSE_SEGMENT.clone()),
            "QualifyKeywordSegment" => Some(QUALIFY_KEYWORD_SEGMENT.clone()),
            "QuarterKeywordSegment" => Some(QUARTER_KEYWORD_SEGMENT.clone()),
            "QuoteKeywordSegment" => Some(QUOTE_KEYWORD_SEGMENT.clone()),
            "QuotedIdentifierSegment" => Some(QUOTED_IDENTIFIER_SEGMENT.clone()),
            "QuotedLiteralSegment" => Some(QUOTED_LITERAL_SEGMENT.clone()),
            "Raid0KeywordSegment" => Some(RAID0_KEYWORD_SEGMENT.clone()),
            "RaiserrorKeywordSegment" => Some(RAISERROR_KEYWORD_SEGMENT.clone()),
            "RangeKeywordSegment" => Some(RANGE_KEYWORD_SEGMENT.clone()),
            "RawEqualsSegment" => Some(RAW_EQUALS_SEGMENT.clone()),
            "RawGreaterThanSegment" => Some(RAW_GREATER_THAN_SEGMENT.clone()),
            "RawKeywordSegment" => Some(RAW_KEYWORD_SEGMENT.clone()),
            "RawLessThanSegment" => Some(RAW_LESS_THAN_SEGMENT.clone()),
            "RawNotSegment" => Some(RAW_NOT_SEGMENT.clone()),
            "RawSegment" => Some(RAW_SEGMENT.clone()),
            "ReadKeywordSegment" => Some(READ_KEYWORD_SEGMENT.clone()),
            "ReadtextKeywordSegment" => Some(READTEXT_KEYWORD_SEGMENT.clone()),
            "RealKeywordSegment" => Some(REAL_KEYWORD_SEGMENT.clone()),
            "ReassignKeywordSegment" => Some(REASSIGN_KEYWORD_SEGMENT.clone()),
            "ReassignOwnedStatementSegment" => Some(REASSIGN_OWNED_STATEMENT_SEGMENT.clone()),
            "RecheckKeywordSegment" => Some(RECHECK_KEYWORD_SEGMENT.clone()),
            "ReconfigureKeywordSegment" => Some(RECONFIGURE_KEYWORD_SEGMENT.clone()),
            "RecursiveKeywordSegment" => Some(RECURSIVE_KEYWORD_SEGMENT.clone()),
            "RefKeywordSegment" => Some(REF_KEYWORD_SEGMENT.clone()),
            "ReferenceDefinitionGrammar" => Some(REFERENCE_DEFINITION_GRAMMAR.clone()),
            "ReferenceMatchGrammar" => Some(REFERENCE_MATCH_GRAMMAR.clone()),
            "Reference_usageKeywordSegment" => Some(REFERENCE_USAGE_KEYWORD_SEGMENT.clone()),
            "ReferencesKeywordSegment" => Some(REFERENCES_KEYWORD_SEGMENT.clone()),
            "ReferencingKeywordSegment" => Some(REFERENCING_KEYWORD_SEGMENT.clone()),
            "ReferentialActionGrammar" => Some(REFERENTIAL_ACTION_GRAMMAR.clone()),
            "RefreshKeywordSegment" => Some(REFRESH_KEYWORD_SEGMENT.clone()),
            "RefreshMaterializedViewStatementSegment" => Some(REFRESH_MATERIALIZED_VIEW_STATEMENT_SEGMENT.clone()),
            "RegexpKeywordSegment" => Some(REGEXP_KEYWORD_SEGMENT.clone()),
            "ReindexKeywordSegment" => Some(REINDEX_KEYWORD_SEGMENT.clone()),
            "ReindexStatementSegment" => Some(REINDEX_STATEMENT_SEGMENT.clone()),
            "RelationOptionSegment" => Some(RELATION_OPTION_SEGMENT.clone()),
            "RelationOptionsSegment" => Some(RELATION_OPTIONS_SEGMENT.clone()),
            "RelativeKeywordSegment" => Some(RELATIVE_KEYWORD_SEGMENT.clone()),
            "ReleaseKeywordSegment" => Some(RELEASE_KEYWORD_SEGMENT.clone()),
            "ReloadKeywordSegment" => Some(RELOAD_KEYWORD_SEGMENT.clone()),
            "RemainderKeywordSegment" => Some(REMAINDER_KEYWORD_SEGMENT.clone()),
            "RenameKeywordSegment" => Some(RENAME_KEYWORD_SEGMENT.clone()),
            "RepeatKeywordSegment" => Some(REPEAT_KEYWORD_SEGMENT.clone()),
            "RepeatableKeywordSegment" => Some(REPEATABLE_KEYWORD_SEGMENT.clone()),
            "ReplaceKeywordSegment" => Some(REPLACE_KEYWORD_SEGMENT.clone()),
            "ReplicaKeywordSegment" => Some(REPLICA_KEYWORD_SEGMENT.clone()),
            "ReplicationKeywordSegment" => Some(REPLICATION_KEYWORD_SEGMENT.clone()),
            "RequireKeywordSegment" => Some(REQUIRE_KEYWORD_SEGMENT.clone()),
            "ResetKeywordSegment" => Some(RESET_KEYWORD_SEGMENT.clone()),
            "ResetSessionAuthorizationStatementSegment" => Some(RESET_SESSION_AUTHORIZATION_STATEMENT_SEGMENT.clone()),
            "ResetStatementSegment" => Some(RESET_STATEMENT_SEGMENT.clone()),
            "ResignalKeywordSegment" => Some(RESIGNAL_KEYWORD_SEGMENT.clone()),
            "ResourceKeywordSegment" => Some(RESOURCE_KEYWORD_SEGMENT.clone()),
            "RespectKeywordSegment" => Some(RESPECT_KEYWORD_SEGMENT.clone()),
            "RestartKeywordSegment" => Some(RESTART_KEYWORD_SEGMENT.clone()),
            "RestrictKeywordSegment" => Some(RESTRICT_KEYWORD_SEGMENT.clone()),
            "RestrictedKeywordSegment" => Some(RESTRICTED_KEYWORD_SEGMENT.clone()),
            "RestrictiveKeywordSegment" => Some(RESTRICTIVE_KEYWORD_SEGMENT.clone()),
            "RetrieveKeywordSegment" => Some(RETRIEVE_KEYWORD_SEGMENT.clone()),
            "ReturnKeywordSegment" => Some(RETURN_KEYWORD_SEGMENT.clone()),
            "ReturningKeywordSegment" => Some(RETURNING_KEYWORD_SEGMENT.clone()),
            "ReturnsKeywordSegment" => Some(RETURNS_KEYWORD_SEGMENT.clone()),
            "RevokeKeywordSegment" => Some(REVOKE_KEYWORD_SEGMENT.clone()),
            "RightArrowSegment" => Some(RIGHT_ARROW_SEGMENT.clone()),
            "RightKeywordSegment" => Some(RIGHT_KEYWORD_SEGMENT.clone()),
            "RightargKeywordSegment" => Some(RIGHTARG_KEYWORD_SEGMENT.clone()),
            "RlikeKeywordSegment" => Some(RLIKE_KEYWORD_SEGMENT.clone()),
            "RoleKeywordSegment" => Some(ROLE_KEYWORD_SEGMENT.clone()),
            "RoleReferenceSegment" => Some(ROLE_REFERENCE_SEGMENT.clone()),
            "RolesKeywordSegment" => Some(ROLES_KEYWORD_SEGMENT.clone()),
            "RollbackKeywordSegment" => Some(ROLLBACK_KEYWORD_SEGMENT.clone()),
            "RollupFunctionNameSegment" => Some(ROLLUP_FUNCTION_NAME_SEGMENT.clone()),
            "RollupKeywordSegment" => Some(ROLLUP_KEYWORD_SEGMENT.clone()),
            "RoutineKeywordSegment" => Some(ROUTINE_KEYWORD_SEGMENT.clone()),
            "RoutinesKeywordSegment" => Some(ROUTINES_KEYWORD_SEGMENT.clone()),
            "RowKeywordSegment" => Some(ROW_KEYWORD_SEGMENT.clone()),
            "Row_group_sizeKeywordSegment" => Some(ROW_GROUP_SIZE_KEYWORD_SEGMENT.clone()),
            "Row_group_size_bytesKeywordSegment" => Some(ROW_GROUP_SIZE_BYTES_KEYWORD_SEGMENT.clone()),
            "RowcountKeywordSegment" => Some(ROWCOUNT_KEYWORD_SEGMENT.clone()),
            "RowguidcolKeywordSegment" => Some(ROWGUIDCOL_KEYWORD_SEGMENT.clone()),
            "RowidKeywordSegment" => Some(ROWID_KEYWORD_SEGMENT.clone()),
            "RownumKeywordSegment" => Some(ROWNUM_KEYWORD_SEGMENT.clone()),
            "RowsKeywordSegment" => Some(ROWS_KEYWORD_SEGMENT.clone()),
            "RuleKeywordSegment" => Some(RULE_KEYWORD_SEGMENT.clone()),
            "SafeKeywordSegment" => Some(SAFE_KEYWORD_SEGMENT.clone()),
            "SamplingExpressionSegment" => Some(SAMPLING_EXPRESSION_SEGMENT.clone()),
            "SaveKeywordSegment" => Some(SAVE_KEYWORD_SEGMENT.clone()),
            "SavepointKeywordSegment" => Some(SAVEPOINT_KEYWORD_SEGMENT.clone()),
            "ScalarKeywordSegment" => Some(SCALAR_KEYWORD_SEGMENT.clone()),
            "SchemaKeywordSegment" => Some(SCHEMA_KEYWORD_SEGMENT.clone()),
            "SchemaReferenceSegment" => Some(SCHEMA_REFERENCE_SEGMENT.clone()),
            "SchemasKeywordSegment" => Some(SCHEMAS_KEYWORD_SEGMENT.clone()),
            "ScrollKeywordSegment" => Some(SCROLL_KEYWORD_SEGMENT.clone()),
            "SearchKeywordSegment" => Some(SEARCH_KEYWORD_SEGMENT.clone()),
            "SecondKeywordSegment" => Some(SECOND_KEYWORD_SEGMENT.clone()),
            "Second_microsecondKeywordSegment" => Some(SECOND_MICROSECOND_KEYWORD_SEGMENT.clone()),
            "SecurityKeywordSegment" => Some(SECURITY_KEYWORD_SEGMENT.clone()),
            "SecurityLabelStatementSegment" => Some(SECURITY_LABEL_STATEMENT_SEGMENT.clone()),
            "SelectClauseElementSegment" => Some(SELECT_CLAUSE_ELEMENT_SEGMENT.clone()),
            "SelectClauseModifierSegment" => Some(SELECT_CLAUSE_MODIFIER_SEGMENT.clone()),
            "SelectClauseSegment" => Some(SELECT_CLAUSE_SEGMENT.clone()),
            "SelectClauseTerminatorGrammar" => Some(SELECT_CLAUSE_TERMINATOR_GRAMMAR.clone()),
            "SelectKeywordSegment" => Some(SELECT_KEYWORD_SEGMENT.clone()),
            "SelectStatementSegment" => Some(SELECT_STATEMENT_SEGMENT.clone()),
            "SelectableGrammar" => Some(SELECTABLE_GRAMMAR.clone()),
            "SemiKeywordSegment" => Some(SEMI_KEYWORD_SEGMENT.clone()),
            "SemiStructuredAccessorSegment" => Some(SEMI_STRUCTURED_ACCESSOR_SEGMENT.clone()),
            "SemicolonSegment" => Some(SEMICOLON_SEGMENT.clone()),
            "SeparatorKeywordSegment" => Some(SEPARATOR_KEYWORD_SEGMENT.clone()),
            "SequenceKeywordSegment" => Some(SEQUENCE_KEYWORD_SEGMENT.clone()),
            "SequenceMaxValueGrammar" => Some(SEQUENCE_MAX_VALUE_GRAMMAR.clone()),
            "SequenceMinValueGrammar" => Some(SEQUENCE_MIN_VALUE_GRAMMAR.clone()),
            "SequenceReferenceSegment" => Some(SEQUENCE_REFERENCE_SEGMENT.clone()),
            "SequencesKeywordSegment" => Some(SEQUENCES_KEYWORD_SEGMENT.clone()),
            "Serial2KeywordSegment" => Some(SERIAL2_KEYWORD_SEGMENT.clone()),
            "Serial4KeywordSegment" => Some(SERIAL4_KEYWORD_SEGMENT.clone()),
            "Serial8KeywordSegment" => Some(SERIAL8_KEYWORD_SEGMENT.clone()),
            "SerialKeywordSegment" => Some(SERIAL_KEYWORD_SEGMENT.clone()),
            "SerializableKeywordSegment" => Some(SERIALIZABLE_KEYWORD_SEGMENT.clone()),
            "ServerKeywordSegment" => Some(SERVER_KEYWORD_SEGMENT.clone()),
            "ServerReferenceSegment" => Some(SERVER_REFERENCE_SEGMENT.clone()),
            "Server_encodingKeywordSegment" => Some(SERVER_ENCODING_KEYWORD_SEGMENT.clone()),
            "Server_versionKeywordSegment" => Some(SERVER_VERSION_KEYWORD_SEGMENT.clone()),
            "SessionInformationUserFunctionsGrammar" => Some(SESSION_INFORMATION_USER_FUNCTIONS_GRAMMAR.clone()),
            "SessionKeywordSegment" => Some(SESSION_KEYWORD_SEGMENT.clone()),
            "Session_userKeywordSegment" => Some(SESSION_USER_KEYWORD_SEGMENT.clone()),
            "SetClauseListSegment" => Some(SET_CLAUSE_LIST_SEGMENT.clone()),
            "SetClauseSegment" => Some(SET_CLAUSE_SEGMENT.clone()),
            "SetConstraintsStatementSegment" => Some(SET_CONSTRAINTS_STATEMENT_SEGMENT.clone()),
            "SetExpressionSegment" => Some(SET_EXPRESSION_SEGMENT.clone()),
            "SetKeywordSegment" => Some(SET_KEYWORD_SEGMENT.clone()),
            "SetOperatorSegment" => Some(SET_OPERATOR_SEGMENT.clone()),
            "SetSchemaStatementSegment" => Some(SET_SCHEMA_STATEMENT_SEGMENT.clone()),
            "SetSessionAuthorizationStatementSegment" => Some(SET_SESSION_AUTHORIZATION_STATEMENT_SEGMENT.clone()),
            "SetStatementSegment" => Some(SET_STATEMENT_SEGMENT.clone()),
            "SetofKeywordSegment" => Some(SETOF_KEYWORD_SEGMENT.clone()),
            "SetsKeywordSegment" => Some(SETS_KEYWORD_SEGMENT.clone()),
            "SettingsKeywordSegment" => Some(SETTINGS_KEYWORD_SEGMENT.clone()),
            "SetuserKeywordSegment" => Some(SETUSER_KEYWORD_SEGMENT.clone()),
            "ShareKeywordSegment" => Some(SHARE_KEYWORD_SEGMENT.clone()),
            "SharesKeywordSegment" => Some(SHARES_KEYWORD_SEGMENT.clone()),
            "ShorthandCastSegment" => Some(SHORTHAND_CAST_SEGMENT.clone()),
            "ShowKeywordSegment" => Some(SHOW_KEYWORD_SEGMENT.clone()),
            "ShowStatementSegment" => Some(SHOW_STATEMENT_SEGMENT.clone()),
            "ShutdownKeywordSegment" => Some(SHUTDOWN_KEYWORD_SEGMENT.clone()),
            "SignalKeywordSegment" => Some(SIGNAL_KEYWORD_SEGMENT.clone()),
            "SignedSegmentGrammar" => Some(SIGNED_SEGMENT_GRAMMAR.clone()),
            "SimilarKeywordSegment" => Some(SIMILAR_KEYWORD_SEGMENT.clone()),
            "SimpleGeometryGrammar" => Some(SIMPLE_GEOMETRY_GRAMMAR.clone()),
            "SimpleKeywordSegment" => Some(SIMPLE_KEYWORD_SEGMENT.clone()),
            "SimplifiedPivotExpressionSegment" => Some(SIMPLIFIED_PIVOT_EXPRESSION_SEGMENT.clone()),
            "SimplifiedUnpivotExpressionSegment" => Some(SIMPLIFIED_UNPIVOT_EXPRESSION_SEGMENT.clone()),
            "SingleIdentifierFullGrammar" => Some(SINGLE_IDENTIFIER_FULL_GRAMMAR.clone()),
            "SingleIdentifierGrammar" => Some(SINGLE_IDENTIFIER_GRAMMAR.clone()),
            "SingleIdentifierListSegment" => Some(SINGLE_IDENTIFIER_LIST_SEGMENT.clone()),
            "SingleQuotedIdentifierSegment" => Some(SINGLE_QUOTED_IDENTIFIER_SEGMENT.clone()),
            "SizedArrayTypeSegment" => Some(SIZED_ARRAY_TYPE_SEGMENT.clone()),
            "SkipKeywordSegment" => Some(SKIP_KEYWORD_SEGMENT.clone()),
            "Skip_lockedKeywordSegment" => Some(SKIP_LOCKED_KEYWORD_SEGMENT.clone()),
            "SlashSegment" => Some(SLASH_SEGMENT.clone()),
            "SliceSegment" => Some(SLICE_SEGMENT.clone()),
            "SmallintKeywordSegment" => Some(SMALLINT_KEYWORD_SEGMENT.clone()),
            "SmallserialKeywordSegment" => Some(SMALLSERIAL_KEYWORD_SEGMENT.clone()),
            "SnapshotKeywordSegment" => Some(SNAPSHOT_KEYWORD_SEGMENT.clone()),
            "SomeKeywordSegment" => Some(SOME_KEYWORD_SEGMENT.clone()),
            "SonameKeywordSegment" => Some(SONAME_KEYWORD_SEGMENT.clone()),
            "SpatialKeywordSegment" => Some(SPATIAL_KEYWORD_SEGMENT.clone()),
            "SqlKeywordSegment" => Some(SQL_KEYWORD_SEGMENT.clone()),
            "Sql_big_resultKeywordSegment" => Some(SQL_BIG_RESULT_KEYWORD_SEGMENT.clone()),
            "Sql_big_selectsKeywordSegment" => Some(SQL_BIG_SELECTS_KEYWORD_SEGMENT.clone()),
            "Sql_big_tablesKeywordSegment" => Some(SQL_BIG_TABLES_KEYWORD_SEGMENT.clone()),
            "Sql_calc_found_rowsKeywordSegment" => Some(SQL_CALC_FOUND_ROWS_KEYWORD_SEGMENT.clone()),
            "Sql_log_offKeywordSegment" => Some(SQL_LOG_OFF_KEYWORD_SEGMENT.clone()),
            "Sql_log_updateKeywordSegment" => Some(SQL_LOG_UPDATE_KEYWORD_SEGMENT.clone()),
            "Sql_low_priority_updatesKeywordSegment" => Some(SQL_LOW_PRIORITY_UPDATES_KEYWORD_SEGMENT.clone()),
            "Sql_select_limitKeywordSegment" => Some(SQL_SELECT_LIMIT_KEYWORD_SEGMENT.clone()),
            "Sql_small_resultKeywordSegment" => Some(SQL_SMALL_RESULT_KEYWORD_SEGMENT.clone()),
            "Sql_warningsKeywordSegment" => Some(SQL_WARNINGS_KEYWORD_SEGMENT.clone()),
            "SqlcaKeywordSegment" => Some(SQLCA_KEYWORD_SEGMENT.clone()),
            "SslKeywordSegment" => Some(SSL_KEYWORD_SEGMENT.clone()),
            "StableKeywordSegment" => Some(STABLE_KEYWORD_SEGMENT.clone()),
            "StageKeywordSegment" => Some(STAGE_KEYWORD_SEGMENT.clone()),
            "StagesKeywordSegment" => Some(STAGES_KEYWORD_SEGMENT.clone()),
            "StandaloneKeywordSegment" => Some(STANDALONE_KEYWORD_SEGMENT.clone()),
            "StarSegment" => Some(STAR_SEGMENT.clone()),
            "StartBracketSegment" => Some(START_BRACKET_SEGMENT.clone()),
            "StartCurlyBracketSegment" => Some(START_CURLY_BRACKET_SEGMENT.clone()),
            "StartKeywordSegment" => Some(START_KEYWORD_SEGMENT.clone()),
            "StartSquareBracketSegment" => Some(START_SQUARE_BRACKET_SEGMENT.clone()),
            "StartingKeywordSegment" => Some(STARTING_KEYWORD_SEGMENT.clone()),
            "StartsKeywordSegment" => Some(STARTS_KEYWORD_SEGMENT.clone()),
            "StatementKeywordSegment" => Some(STATEMENT_KEYWORD_SEGMENT.clone()),
            "StatementSegment" => Some(STATEMENT_SEGMENT.clone()),
            "StatisticsKeywordSegment" => Some(STATISTICS_KEYWORD_SEGMENT.clone()),
            "StatisticsReferenceSegment" => Some(STATISTICS_REFERENCE_SEGMENT.clone()),
            "StdinKeywordSegment" => Some(STDIN_KEYWORD_SEGMENT.clone()),
            "StdoutKeywordSegment" => Some(STDOUT_KEYWORD_SEGMENT.clone()),
            "StorageKeywordSegment" => Some(STORAGE_KEYWORD_SEGMENT.clone()),
            "StoredKeywordSegment" => Some(STORED_KEYWORD_SEGMENT.clone()),
            "Straight_joinKeywordSegment" => Some(STRAIGHT_JOIN_KEYWORD_SEGMENT.clone()),
            "StreamKeywordSegment" => Some(STREAM_KEYWORD_SEGMENT.clone()),
            "StreamsKeywordSegment" => Some(STREAMS_KEYWORD_SEGMENT.clone()),
            "StrictKeywordSegment" => Some(STRICT_KEYWORD_SEGMENT.clone()),
            "StringBinaryOperatorGrammar" => Some(STRING_BINARY_OPERATOR_GRAMMAR.clone()),
            "StripKeywordSegment" => Some(STRIP_KEYWORD_SEGMENT.clone()),
            "StructKeywordSegment" => Some(STRUCT_KEYWORD_SEGMENT.clone()),
            "StructLiteralSegment" => Some(STRUCT_LITERAL_SEGMENT.clone()),
            "StructTypeSchemaSegment" => Some(STRUCT_TYPE_SCHEMA_SEGMENT.clone()),
            "StructTypeSegment" => Some(STRUCT_TYPE_SEGMENT.clone()),
            "SublistKeywordSegment" => Some(SUBLIST_KEYWORD_SEGMENT.clone()),
            "SubscriptionKeywordSegment" => Some(SUBSCRIPTION_KEYWORD_SEGMENT.clone()),
            "SubscriptionReferenceSegment" => Some(SUBSCRIPTION_REFERENCE_SEGMENT.clone()),
            "SubstringKeywordSegment" => Some(SUBSTRING_KEYWORD_SEGMENT.clone()),
            "SuccessfulKeywordSegment" => Some(SUCCESSFUL_KEYWORD_SEGMENT.clone()),
            "SummaryKeywordSegment" => Some(SUMMARY_KEYWORD_SEGMENT.clone()),
            "SuperuserKeywordSegment" => Some(SUPERUSER_KEYWORD_SEGMENT.clone()),
            "SupportKeywordSegment" => Some(SUPPORT_KEYWORD_SEGMENT.clone()),
            "SymbolSegment" => Some(SYMBOL_SEGMENT.clone()),
            "SymmetricKeywordSegment" => Some(SYMMETRIC_KEYWORD_SEGMENT.clone()),
            "SynonymKeywordSegment" => Some(SYNONYM_KEYWORD_SEGMENT.clone()),
            "SysdateKeywordSegment" => Some(SYSDATE_KEYWORD_SEGMENT.clone()),
            "SysidKeywordSegment" => Some(SYSID_KEYWORD_SEGMENT.clone()),
            "SystemKeywordSegment" => Some(SYSTEM_KEYWORD_SEGMENT.clone()),
            "TableConstraintSegment" => Some(TABLE_CONSTRAINT_SEGMENT.clone()),
            "TableConstraintUsingIndexSegment" => Some(TABLE_CONSTRAINT_USING_INDEX_SEGMENT.clone()),
            "TableEndClauseSegment" => Some(TABLE_END_CLAUSE_SEGMENT.clone()),
            "TableExpressionSegment" => Some(TABLE_EXPRESSION_SEGMENT.clone()),
            "TableKeywordSegment" => Some(TABLE_KEYWORD_SEGMENT.clone()),
            "TableReferenceSegment" => Some(TABLE_REFERENCE_SEGMENT.clone()),
            "TablesKeywordSegment" => Some(TABLES_KEYWORD_SEGMENT.clone()),
            "TablesampleKeywordSegment" => Some(TABLESAMPLE_KEYWORD_SEGMENT.clone()),
            "TablespaceKeywordSegment" => Some(TABLESPACE_KEYWORD_SEGMENT.clone()),
            "TablespaceReferenceSegment" => Some(TABLESPACE_REFERENCE_SEGMENT.clone()),
            "TagReferenceSegment" => Some(TAG_REFERENCE_SEGMENT.clone()),
            "Tail_Recurse_Expression_A_Grammar" => Some(TAIL_RECURSE_EXPRESSION_A_GRAMMAR.clone()),
            "Tail_Recurse_Expression_B_Grammar" => Some(TAIL_RECURSE_EXPRESSION_B_GRAMMAR.clone()),
            "TaskKeywordSegment" => Some(TASK_KEYWORD_SEGMENT.clone()),
            "TasksKeywordSegment" => Some(TASKS_KEYWORD_SEGMENT.clone()),
            "TempKeywordSegment" => Some(TEMP_KEYWORD_SEGMENT.clone()),
            "TemplateKeywordSegment" => Some(TEMPLATE_KEYWORD_SEGMENT.clone()),
            "TemporalQuerySegment" => Some(TEMPORAL_QUERY_SEGMENT.clone()),
            "TemporaryGrammar" => Some(TEMPORARY_GRAMMAR.clone()),
            "TemporaryKeywordSegment" => Some(TEMPORARY_KEYWORD_SEGMENT.clone()),
            "TemporaryTransientGrammar" => Some(TEMPORARY_TRANSIENT_GRAMMAR.clone()),
            "TerminateKeywordSegment" => Some(TERMINATE_KEYWORD_SEGMENT.clone()),
            "TerminatedKeywordSegment" => Some(TERMINATED_KEYWORD_SEGMENT.clone()),
            "TextKeywordSegment" => Some(TEXT_KEYWORD_SEGMENT.clone()),
            "TextsizeKeywordSegment" => Some(TEXTSIZE_KEYWORD_SEGMENT.clone()),
            "ThanKeywordSegment" => Some(THAN_KEYWORD_SEGMENT.clone()),
            "ThenKeywordSegment" => Some(THEN_KEYWORD_SEGMENT.clone()),
            "TiesKeywordSegment" => Some(TIES_KEYWORD_SEGMENT.clone()),
            "TildeSegment" => Some(TILDE_SEGMENT.clone()),
            "TimeKeywordSegment" => Some(TIME_KEYWORD_SEGMENT.clone()),
            "TimeWithTZGrammar" => Some(TIME_WITH_T_Z_GRAMMAR.clone()),
            "TimeZoneGrammar" => Some(TIME_ZONE_GRAMMAR.clone()),
            "TimestampKeywordSegment" => Some(TIMESTAMP_KEYWORD_SEGMENT.clone()),
            "TimestamptzKeywordSegment" => Some(TIMESTAMPTZ_KEYWORD_SEGMENT.clone()),
            "TimetzKeywordSegment" => Some(TIMETZ_KEYWORD_SEGMENT.clone()),
            "TimingKeywordSegment" => Some(TIMING_KEYWORD_SEGMENT.clone()),
            "TinKeywordSegment" => Some(TIN_KEYWORD_SEGMENT.clone()),
            "TinyblobKeywordSegment" => Some(TINYBLOB_KEYWORD_SEGMENT.clone()),
            "TinyintKeywordSegment" => Some(TINYINT_KEYWORD_SEGMENT.clone()),
            "TinytextKeywordSegment" => Some(TINYTEXT_KEYWORD_SEGMENT.clone()),
            "ToKeywordSegment" => Some(TO_KEYWORD_SEGMENT.clone()),
            "ToastKeywordSegment" => Some(TOAST_KEYWORD_SEGMENT.clone()),
            "TopKeywordSegment" => Some(TOP_KEYWORD_SEGMENT.clone()),
            "TrailingKeywordSegment" => Some(TRAILING_KEYWORD_SEGMENT.clone()),
            "TranKeywordSegment" => Some(TRAN_KEYWORD_SEGMENT.clone()),
            "TransactionKeywordSegment" => Some(TRANSACTION_KEYWORD_SEGMENT.clone()),
            "TransactionStatementSegment" => Some(TRANSACTION_STATEMENT_SEGMENT.clone()),
            "TransactionsKeywordSegment" => Some(TRANSACTIONS_KEYWORD_SEGMENT.clone()),
            "TransformKeywordSegment" => Some(TRANSFORM_KEYWORD_SEGMENT.clone()),
            "TransientKeywordSegment" => Some(TRANSIENT_KEYWORD_SEGMENT.clone()),
            "TreatKeywordSegment" => Some(TREAT_KEYWORD_SEGMENT.clone()),
            "TriangleKeywordSegment" => Some(TRIANGLE_KEYWORD_SEGMENT.clone()),
            "TriggerKeywordSegment" => Some(TRIGGER_KEYWORD_SEGMENT.clone()),
            "TriggerReferenceSegment" => Some(TRIGGER_REFERENCE_SEGMENT.clone()),
            "TrimKeywordSegment" => Some(TRIM_KEYWORD_SEGMENT.clone()),
            "TrimParametersGrammar" => Some(TRIM_PARAMETERS_GRAMMAR.clone()),
            "TrueKeywordSegment" => Some(TRUE_KEYWORD_SEGMENT.clone()),
            "TrueSegment" => Some(TRUE_SEGMENT.clone()),
            "TruncateKeywordSegment" => Some(TRUNCATE_KEYWORD_SEGMENT.clone()),
            "TruncateStatementSegment" => Some(TRUNCATE_STATEMENT_SEGMENT.clone()),
            "TrustedKeywordSegment" => Some(TRUSTED_KEYWORD_SEGMENT.clone()),
            "TsequalKeywordSegment" => Some(TSEQUAL_KEYWORD_SEGMENT.clone()),
            "TsqueryKeywordSegment" => Some(TSQUERY_KEYWORD_SEGMENT.clone()),
            "TsrangeKeywordSegment" => Some(TSRANGE_KEYWORD_SEGMENT.clone()),
            "TstzrangeKeywordSegment" => Some(TSTZRANGE_KEYWORD_SEGMENT.clone()),
            "TsvectorKeywordSegment" => Some(TSVECTOR_KEYWORD_SEGMENT.clone()),
            "TupleSegment" => Some(TUPLE_SEGMENT.clone()),
            "TypeKeywordSegment" => Some(TYPE_KEYWORD_SEGMENT.clone()),
            "TypedArrayLiteralSegment" => Some(TYPED_ARRAY_LITERAL_SEGMENT.clone()),
            "TypedStructLiteralSegment" => Some(TYPED_STRUCT_LITERAL_SEGMENT.clone()),
            "TypesKeywordSegment" => Some(TYPES_KEYWORD_SEGMENT.clone()),
            "UescapeKeywordSegment" => Some(UESCAPE_KEYWORD_SEGMENT.clone()),
            "UidKeywordSegment" => Some(UID_KEYWORD_SEGMENT.clone()),
            "UnboundedKeywordSegment" => Some(UNBOUNDED_KEYWORD_SEGMENT.clone()),
            "UncommittedKeywordSegment" => Some(UNCOMMITTED_KEYWORD_SEGMENT.clone()),
            "UnconditionalCrossJoinKeywordsGrammar" => Some(UNCONDITIONAL_CROSS_JOIN_KEYWORDS_GRAMMAR.clone()),
            "UnconditionalJoinKeywordsGrammar" => Some(UNCONDITIONAL_JOIN_KEYWORDS_GRAMMAR.clone()),
            "UndoKeywordSegment" => Some(UNDO_KEYWORD_SEGMENT.clone()),
            "UnencryptedKeywordSegment" => Some(UNENCRYPTED_KEYWORD_SEGMENT.clone()),
            "UnionGrammar" => Some(UNION_GRAMMAR.clone()),
            "UnionKeywordSegment" => Some(UNION_KEYWORD_SEGMENT.clone()),
            "UniqueKeyGrammar" => Some(UNIQUE_KEY_GRAMMAR.clone()),
            "UniqueKeywordSegment" => Some(UNIQUE_KEYWORD_SEGMENT.clone()),
            "UnknownKeywordSegment" => Some(UNKNOWN_KEYWORD_SEGMENT.clone()),
            "UnknownLiteralSegment" => Some(UNKNOWN_LITERAL_SEGMENT.clone()),
            "UnlistenKeywordSegment" => Some(UNLISTEN_KEYWORD_SEGMENT.clone()),
            "UnlistenStatementSegment" => Some(UNLISTEN_STATEMENT_SEGMENT.clone()),
            "UnlockKeywordSegment" => Some(UNLOCK_KEYWORD_SEGMENT.clone()),
            "UnloggedKeywordSegment" => Some(UNLOGGED_KEYWORD_SEGMENT.clone()),
            "UnorderedSelectStatementSegment" => Some(UNORDERED_SELECT_STATEMENT_SEGMENT.clone()),
            "UnorderedSetExpressionSegment" => Some(UNORDERED_SET_EXPRESSION_SEGMENT.clone()),
            "UnpackingOperatorSegment" => Some(UNPACKING_OPERATOR_SEGMENT.clone()),
            "UnpivotKeywordSegment" => Some(UNPIVOT_KEYWORD_SEGMENT.clone()),
            "UnsafeKeywordSegment" => Some(UNSAFE_KEYWORD_SEGMENT.clone()),
            "UnsignedKeywordSegment" => Some(UNSIGNED_KEYWORD_SEGMENT.clone()),
            "UntilKeywordSegment" => Some(UNTIL_KEYWORD_SEGMENT.clone()),
            "UpdateKeywordSegment" => Some(UPDATE_KEYWORD_SEGMENT.clone()),
            "UpdateStatementSegment" => Some(UPDATE_STATEMENT_SEGMENT.clone()),
            "UpdatetextKeywordSegment" => Some(UPDATETEXT_KEYWORD_SEGMENT.clone()),
            "UsageKeywordSegment" => Some(USAGE_KEYWORD_SEGMENT.clone()),
            "UseKeywordSegment" => Some(USE_KEYWORD_SEGMENT.clone()),
            "UseStatementSegment" => Some(USE_STATEMENT_SEGMENT.clone()),
            "Use_any_roleKeywordSegment" => Some(USE_ANY_ROLE_KEYWORD_SEGMENT.clone()),
            "UserKeywordSegment" => Some(USER_KEYWORD_SEGMENT.clone()),
            "UsersKeywordSegment" => Some(USERS_KEYWORD_SEGMENT.clone()),
            "UsingKeywordSegment" => Some(USING_KEYWORD_SEGMENT.clone()),
            "Utc_dateKeywordSegment" => Some(UTC_DATE_KEYWORD_SEGMENT.clone()),
            "Utc_timeKeywordSegment" => Some(UTC_TIME_KEYWORD_SEGMENT.clone()),
            "Utc_timestampKeywordSegment" => Some(UTC_TIMESTAMP_KEYWORD_SEGMENT.clone()),
            "UuidKeywordSegment" => Some(UUID_KEYWORD_SEGMENT.clone()),
            "VacuumKeywordSegment" => Some(VACUUM_KEYWORD_SEGMENT.clone()),
            "VacuumStatementSegment" => Some(VACUUM_STATEMENT_SEGMENT.clone()),
            "ValidKeywordSegment" => Some(VALID_KEYWORD_SEGMENT.clone()),
            "ValidateKeywordSegment" => Some(VALIDATE_KEYWORD_SEGMENT.clone()),
            "ValidatorKeywordSegment" => Some(VALIDATOR_KEYWORD_SEGMENT.clone()),
            "ValueKeywordSegment" => Some(VALUE_KEYWORD_SEGMENT.clone()),
            "ValuesClauseSegment" => Some(VALUES_CLAUSE_SEGMENT.clone()),
            "ValuesKeywordSegment" => Some(VALUES_KEYWORD_SEGMENT.clone()),
            "Varchar2KeywordSegment" => Some(VARCHAR2_KEYWORD_SEGMENT.clone()),
            "VarcharKeywordSegment" => Some(VARCHAR_KEYWORD_SEGMENT.clone()),
            "VarcharacterKeywordSegment" => Some(VARCHARACTER_KEYWORD_SEGMENT.clone()),
            "VariableKeywordSegment" => Some(VARIABLE_KEYWORD_SEGMENT.clone()),
            "VariablesKeywordSegment" => Some(VARIABLES_KEYWORD_SEGMENT.clone()),
            "VariadicKeywordSegment" => Some(VARIADIC_KEYWORD_SEGMENT.clone()),
            "VaryingKeywordSegment" => Some(VARYING_KEYWORD_SEGMENT.clone()),
            "VectorKeywordSegment" => Some(VECTOR_KEYWORD_SEGMENT.clone()),
            "VerboseKeywordSegment" => Some(VERBOSE_KEYWORD_SEGMENT.clone()),
            "VersionIdentifierSegment" => Some(VERSION_IDENTIFIER_SEGMENT.clone()),
            "VersionKeywordSegment" => Some(VERSION_KEYWORD_SEGMENT.clone()),
            "ViewKeywordSegment" => Some(VIEW_KEYWORD_SEGMENT.clone()),
            "ViewsKeywordSegment" => Some(VIEWS_KEYWORD_SEGMENT.clone()),
            "VirtualKeywordSegment" => Some(VIRTUAL_KEYWORD_SEGMENT.clone()),
            "VolatileKeywordSegment" => Some(VOLATILE_KEYWORD_SEGMENT.clone()),
            "WaitforKeywordSegment" => Some(WAITFOR_KEYWORD_SEGMENT.clone()),
            "WalKeywordSegment" => Some(WAL_KEYWORD_SEGMENT.clone()),
            "WalrusOperatorSegment" => Some(WALRUS_OPERATOR_SEGMENT.clone()),
            "WarehouseKeywordSegment" => Some(WAREHOUSE_KEYWORD_SEGMENT.clone()),
            "WarehousesKeywordSegment" => Some(WAREHOUSES_KEYWORD_SEGMENT.clone()),
            "WeekKeywordSegment" => Some(WEEK_KEYWORD_SEGMENT.clone()),
            "WeekdayKeywordSegment" => Some(WEEKDAY_KEYWORD_SEGMENT.clone()),
            "WellKnownTextGeometrySegment" => Some(WELL_KNOWN_TEXT_GEOMETRY_SEGMENT.clone()),
            "WhenClauseSegment" => Some(WHEN_CLAUSE_SEGMENT.clone()),
            "WhenKeywordSegment" => Some(WHEN_KEYWORD_SEGMENT.clone()),
            "WhereClauseSegment" => Some(WHERE_CLAUSE_SEGMENT.clone()),
            "WhereClauseTerminatorGrammar" => Some(WHERE_CLAUSE_TERMINATOR_GRAMMAR.clone()),
            "WhereKeywordSegment" => Some(WHERE_KEYWORD_SEGMENT.clone()),
            "WhileKeywordSegment" => Some(WHILE_KEYWORD_SEGMENT.clone()),
            "WhitespaceKeywordSegment" => Some(WHITESPACE_KEYWORD_SEGMENT.clone()),
            "WhitespaceSegment" => Some(WHITESPACE_SEGMENT.clone()),
            "WildcardExcludeExpressionSegment" => Some(WILDCARD_EXCLUDE_EXPRESSION_SEGMENT.clone()),
            "WildcardExpressionSegment" => Some(WILDCARD_EXPRESSION_SEGMENT.clone()),
            "WildcardIdentifierSegment" => Some(WILDCARD_IDENTIFIER_SEGMENT.clone()),
            "WildcardPatternMatchingSegment" => Some(WILDCARD_PATTERN_MATCHING_SEGMENT.clone()),
            "WildcardRenameExpressionSegment" => Some(WILDCARD_RENAME_EXPRESSION_SEGMENT.clone()),
            "WildcardReplaceExpressionSegment" => Some(WILDCARD_REPLACE_EXPRESSION_SEGMENT.clone()),
            "WindowKeywordSegment" => Some(WINDOW_KEYWORD_SEGMENT.clone()),
            "WindowSpecificationSegment" => Some(WINDOW_SPECIFICATION_SEGMENT.clone()),
            "WithCheckOptionSegment" => Some(WITH_CHECK_OPTION_SEGMENT.clone()),
            "WithCompoundNonSelectStatementSegment" => Some(WITH_COMPOUND_NON_SELECT_STATEMENT_SEGMENT.clone()),
            "WithCompoundStatementSegment" => Some(WITH_COMPOUND_STATEMENT_SEGMENT.clone()),
            "WithDataClauseSegment" => Some(WITH_DATA_CLAUSE_SEGMENT.clone()),
            "WithFillSegment" => Some(WITH_FILL_SEGMENT.clone()),
            "WithKeywordSegment" => Some(WITH_KEYWORD_SEGMENT.clone()),
            "WithNoSchemaBindingClauseSegment" => Some(WITH_NO_SCHEMA_BINDING_CLAUSE_SEGMENT.clone()),
            "WithinGroupClauseSegment" => Some(WITHIN_GROUP_CLAUSE_SEGMENT.clone()),
            "WithinKeywordSegment" => Some(WITHIN_KEYWORD_SEGMENT.clone()),
            "WithoutKeywordSegment" => Some(WITHOUT_KEYWORD_SEGMENT.clone()),
            "WordSegment" => Some(WORD_SEGMENT.clone()),
            "WorkKeywordSegment" => Some(WORK_KEYWORD_SEGMENT.clone()),
            "WrapperKeywordSegment" => Some(WRAPPER_KEYWORD_SEGMENT.clone()),
            "WriteKeywordSegment" => Some(WRITE_KEYWORD_SEGMENT.clone()),
            "Write_partition_columnsKeywordSegment" => Some(WRITE_PARTITION_COLUMNS_KEYWORD_SEGMENT.clone()),
            "WritetextKeywordSegment" => Some(WRITETEXT_KEYWORD_SEGMENT.clone()),
            "X509KeywordSegment" => Some(X509_KEYWORD_SEGMENT.clone()),
            "XmlKeywordSegment" => Some(XML_KEYWORD_SEGMENT.clone()),
            "XmlattributesKeywordSegment" => Some(XMLATTRIBUTES_KEYWORD_SEGMENT.clone()),
            "XmlconcatKeywordSegment" => Some(XMLCONCAT_KEYWORD_SEGMENT.clone()),
            "XmlelementKeywordSegment" => Some(XMLELEMENT_KEYWORD_SEGMENT.clone()),
            "XmlexistsKeywordSegment" => Some(XMLEXISTS_KEYWORD_SEGMENT.clone()),
            "XmlforestKeywordSegment" => Some(XMLFOREST_KEYWORD_SEGMENT.clone()),
            "XmlnamespacesKeywordSegment" => Some(XMLNAMESPACES_KEYWORD_SEGMENT.clone()),
            "XmlparseKeywordSegment" => Some(XMLPARSE_KEYWORD_SEGMENT.clone()),
            "XmlpiKeywordSegment" => Some(XMLPI_KEYWORD_SEGMENT.clone()),
            "XmlrootKeywordSegment" => Some(XMLROOT_KEYWORD_SEGMENT.clone()),
            "XmlserializeKeywordSegment" => Some(XMLSERIALIZE_KEYWORD_SEGMENT.clone()),
            "XmltableKeywordSegment" => Some(XMLTABLE_KEYWORD_SEGMENT.clone()),
            "XorKeywordSegment" => Some(XOR_KEYWORD_SEGMENT.clone()),
            "YamlKeywordSegment" => Some(YAML_KEYWORD_SEGMENT.clone()),
            "YearKeywordSegment" => Some(YEAR_KEYWORD_SEGMENT.clone()),
            "Year_monthKeywordSegment" => Some(YEAR_MONTH_KEYWORD_SEGMENT.clone()),
            "YesKeywordSegment" => Some(YES_KEYWORD_SEGMENT.clone()),
            "ZerofillKeywordSegment" => Some(ZEROFILL_KEYWORD_SEGMENT.clone()),
            "ZoneKeywordSegment" => Some(ZONE_KEYWORD_SEGMENT.clone()),
            _ => None,
    }
}

pub fn get_duckdb_segment_type(name: &str) -> Option<&'static str> {
    match name {
            "AccessStatementSegment" => Some("access_statement"),
            "AdjacentSegment" => Some("comparison_operator"),
            "AggregateOrderByClause" => Some("aggregate_order_by"),
            "AliasExpressionSegment" => Some("alias_expression"),
            "AlterAggregateStatementSegment" => Some("alter_aggregate_statement"),
            "AlterDatabaseStatementSegment" => Some("alter_database_statement"),
            "AlterDefaultPrivilegesGrantSegment" => Some("alter_default_privileges_grant"),
            "AlterDefaultPrivilegesObjectPrivilegesSegment" => Some("alter_default_privileges_object_privilege"),
            "AlterDefaultPrivilegesRevokeSegment" => Some("alter_default_privileges_revoke"),
            "AlterDefaultPrivilegesSchemaObjectsSegment" => Some("alter_default_privileges_schema_object"),
            "AlterDefaultPrivilegesStatementSegment" => Some("alter_default_privileges_statement"),
            "AlterDefaultPrivilegesToFromRolesSegment" => Some("alter_default_privileges_to_from_roles"),
            "AlterDomainStatementSegment" => Some("alter_domain_statement"),
            "AlterExtensionStatementSegment" => Some("alter_extension_statement"),
            "AlterForeignTableActionSegment" => Some("alter_foreign_table_action_segment"),
            "AlterForeignTableStatementSegment" => Some("alter_foreign_table_statement"),
            "AlterFunctionActionSegment" => Some("alter_function_action_segment"),
            "AlterFunctionStatementSegment" => Some("alter_function_statement"),
            "AlterIndexStatementSegment" => Some("alter_index_statement"),
            "AlterMaterializedViewActionSegment" => Some("alter_materialized_view_action_segment"),
            "AlterMaterializedViewStatementSegment" => Some("alter_materialized_view_statement"),
            "AlterPolicyStatementSegment" => Some("alter_policy_statement"),
            "AlterProcedureActionSegment" => Some("alter_procedure_action_segment"),
            "AlterProcedureStatementSegment" => Some("alter_procedure_statement"),
            "AlterPublicationStatementSegment" => Some("alter_publication_statement"),
            "AlterRoleStatementSegment" => Some("alter_role_statement"),
            "AlterSchemaStatementSegment" => Some("alter_schema_statement"),
            "AlterSequenceOptionsSegment" => Some("alter_sequence_options_segment"),
            "AlterSequenceStatementSegment" => Some("alter_sequence_statement"),
            "AlterStatisticsStatementSegment" => Some("alter_statistics_statement"),
            "AlterSubscriptionStatementSegment" => Some("alter_subscription"),
            "AlterTableActionSegment" => Some("alter_table_action_segment"),
            "AlterTableStatementSegment" => Some("alter_table_statement"),
            "AlterTextSearchConfigurationStatementSegment" => Some("alter_text_search_configuration_statement"),
            "AlterTriggerStatementSegment" => Some("alter_trigger"),
            "AlterTypeStatementSegment" => Some("alter_type_statement"),
            "AlterViewStatementSegment" => Some("alter_view_statement"),
            "AnalyzeStatementSegment" => Some("analyze_statement"),
            "ArrayAccessorSegment" => Some("array_accessor"),
            "ArrayExpressionSegment" => Some("array_expression"),
            "ArrayLiteralSegment" => Some("array_literal"),
            "ArrayTypeSegment" => Some("array_type"),
            "AsAliasExpressionSegment" => Some("alias_expression"),
            "AsAliasOperatorSegment" => Some("alias_operator"),
            "BaseFileSegment" => Some("file"),
            "BaseSegment" => Some("base"),
            "BinaryOperatorSegment" => Some("binary_operator"),
            "BitwiseAndSegment" => Some("binary_operator"),
            "BitwiseLShiftSegment" => Some("binary_operator"),
            "BitwiseOrSegment" => Some("binary_operator"),
            "BitwiseRShiftSegment" => Some("binary_operator"),
            "BracketedArguments" => Some("bracketed_arguments"),
            "BracketedSegment" => Some("bracketed"),
            "CTEColumnList" => Some("cte_column_list"),
            "CTEDefinitionSegment" => Some("common_table_expression"),
            "CallStoredProcedureSegment" => Some("call_statement"),
            "CaseExpressionSegment" => Some("case_expression"),
            "ClusterStatementSegment" => Some("cluster_statement"),
            "CodeSegment" => Some("raw"),
            "CollationReferenceSegment" => Some("collation_reference"),
            "ColumnConstraintSegment" => Some("column_constraint_segment"),
            "ColumnDefinitionSegment" => Some("column_definition"),
            "ColumnReferenceSegment" => Some("column_reference"),
            "ColumnTypeReferenceSegment" => Some("column_type_reference"),
            "ColumnsExpressionFunctionContentsSegment" => Some("function_contents"),
            "ColumnsExpressionFunctionNameSegment" => Some("function_name"),
            "CommentClauseSegment" => Some("comment_clause"),
            "CommentOnStatementSegment" => Some("comment_clause"),
            "CommentSegment" => Some("comment"),
            "ComparisonOperatorSegment" => Some("comparison_operator"),
            "CompositeBinaryOperatorSegment" => Some("binary_operator"),
            "CompositeComparisonOperatorSegment" => Some("comparison_operator"),
            "ConcatSegment" => Some("binary_operator"),
            "ConflictActionSegment" => Some("conflict_action"),
            "ConflictTargetSegment" => Some("conflict_target"),
            "CopyStatementSegment" => Some("copy_statement"),
            "CreateAggregateStatementSegment" => Some("create_aggregate_statement"),
            "CreateCastStatementSegment" => Some("create_cast_statement"),
            "CreateCollationStatementSegment" => Some("create_collation_statement"),
            "CreateDatabaseStatementSegment" => Some("create_database_statement"),
            "CreateDomainStatementSegment" => Some("create_domain_statement"),
            "CreateExtensionStatementSegment" => Some("create_extension_statement"),
            "CreateForeignDataWrapperStatementSegment" => Some("create_foreign_data_wrapper"),
            "CreateForeignTableStatementSegment" => Some("create_foreign_table_statement"),
            "CreateFunctionStatementSegment" => Some("create_function_statement"),
            "CreateIndexStatementSegment" => Some("create_index_statement"),
            "CreateMaterializedViewStatementSegment" => Some("create_materialized_view_statement"),
            "CreateModelStatementSegment" => Some("create_model_statement"),
            "CreateOperatorStatementSegment" => Some("create_operator_statement"),
            "CreatePolicyStatementSegment" => Some("create_policy_statement"),
            "CreateProcedureStatementSegment" => Some("create_procedure_statement"),
            "CreatePublicationStatementSegment" => Some("create_publication_statement"),
            "CreateRoleStatementSegment" => Some("create_role_statement"),
            "CreateSchemaStatementSegment" => Some("create_schema_statement"),
            "CreateSequenceOptionsSegment" => Some("create_sequence_options_segment"),
            "CreateSequenceStatementSegment" => Some("create_sequence_statement"),
            "CreateServerStatementSegment" => Some("create_server_statement"),
            "CreateStatisticsStatementSegment" => Some("create_statistics_statement"),
            "CreateSubscriptionStatementSegment" => Some("create_subscription"),
            "CreateTableStatementSegment" => Some("create_table_statement"),
            "CreateTextSearchConfigurationStatementSegment" => Some("create_text_search_configuration_statement"),
            "CreateTriggerStatementSegment" => Some("create_trigger"),
            "CreateTypeStatementSegment" => Some("create_type_statement"),
            "CreateUserMappingStatementSegment" => Some("create_user_mapping_statement"),
            "CreateUserStatementSegment" => Some("create_user_statement"),
            "CreateViewStatementSegment" => Some("create_view_statement"),
            "CubeFunctionNameSegment" => Some("function_name"),
            "CubeRollupClauseSegment" => Some("cube_rollup_clause"),
            "DatabaseReferenceSegment" => Some("database_reference"),
            "DatatypeSegment" => Some("data_type"),
            "DatePartFunctionNameSegment" => Some("function_name"),
            "DateTimeFunctionContentsSegment" => Some("function_contents"),
            "DateTimeLiteralGrammar" => Some("datetime_literal"),
            "DateTimeTypeIdentifier" => Some("datetime_type_identifier"),
            "DeallocateStatementSegment" => Some("deallocate_statement"),
            "Dedent" => Some("dedent"),
            "DefinitionParameterSegment" => Some("definition_parameter"),
            "DefinitionParametersSegment" => Some("definition_parameters"),
            "DeleteStatementSegment" => Some("delete_statement"),
            "DescribeStatementSegment" => Some("describe_statement"),
            "DiscardStatementSegment" => Some("discard_statement"),
            "DoStatementSegment" => Some("do_statement"),
            "DropAggregateStatementSegment" => Some("drop_aggregate_statement"),
            "DropCastStatementSegment" => Some("drop_cast_statement"),
            "DropCollationStatementSegment" => Some("drop_collation_statement"),
            "DropDatabaseStatementSegment" => Some("drop_database_statement"),
            "DropDomainStatementSegment" => Some("drop_domain_statement"),
            "DropExtensionStatementSegment" => Some("drop_extension_statement"),
            "DropForeignTableStatement" => Some("drop_foreign_table_statement"),
            "DropFunctionStatementSegment" => Some("drop_function_statement"),
            "DropIndexStatementSegment" => Some("drop_index_statement"),
            "DropMaterializedViewStatementSegment" => Some("drop_materialized_view_statement"),
            "DropModelStatementSegment" => Some("drop_MODELstatement"),
            "DropOwnedStatementSegment" => Some("drop_owned_statement"),
            "DropPolicyStatementSegment" => Some("drop_policy_statement"),
            "DropProcedureStatementSegment" => Some("drop_procedure_statement"),
            "DropPublicationStatementSegment" => Some("drop_publication_statement"),
            "DropRoleStatementSegment" => Some("drop_role_statement"),
            "DropSchemaStatementSegment" => Some("drop_schema_statement"),
            "DropSequenceStatementSegment" => Some("drop_sequence_statement"),
            "DropStatisticsStatementSegment" => Some("drop_statistics_statement"),
            "DropSubscriptionStatementSegment" => Some("drop_subscription"),
            "DropTableStatementSegment" => Some("drop_table_statement"),
            "DropTextSearchConfigurationStatementSegment" => Some("drop_text_search_configuration_statement"),
            "DropTriggerStatementSegment" => Some("drop_trigger"),
            "DropTypeStatementSegment" => Some("drop_type_statement"),
            "DropUserStatementSegment" => Some("drop_user_statement"),
            "DropViewStatementSegment" => Some("drop_view_statement"),
            "ElseClauseSegment" => Some("else_clause"),
            "EmptyStructLiteralBracketsSegment" => Some("struct_literal"),
            "EmptyStructLiteralSegment" => Some("typed_struct_literal"),
            "EqualsSegment" => Some("comparison_operator"),
            "ExclusionConstraintElementSegment" => Some("exclusion_constraint_element"),
            "ExecuteStatementSegment" => Some("execute_statement"),
            "ExplainOptionSegment" => Some("explain_option"),
            "ExplainStatementSegment" => Some("explain_statement"),
            "ExpressionSegment" => Some("expression"),
            "ExtensionReferenceSegment" => Some("extension_reference"),
            "FetchClauseSegment" => Some("fetch_clause"),
            "FileSegment" => Some("file"),
            "ForClauseSegment" => Some("for_clause"),
            "ForeignTableColumnConstraintSegment" => Some("column_constraint_segment"),
            "ForeignTableTableConstraintSegment" => Some("table_constraint"),
            "FrameClauseSegment" => Some("frame_clause"),
            "FromClauseSegment" => Some("from_clause"),
            "FromExpressionElementSegment" => Some("from_expression_element"),
            "FromExpressionSegment" => Some("from_expression"),
            "FromPivotExpressionSegment" => Some("from_pivot_expression"),
            "FromUnpivotExpressionSegment" => Some("from_unpivot_expression"),
            "FunctionContentsSegment" => Some("function_contents"),
            "FunctionDefinitionGrammar" => Some("function_definition"),
            "FunctionNameSegment" => Some("function_name"),
            "FunctionParameterListGrammar" => Some("function_parameter_list"),
            "FunctionSegment" => Some("function"),
            "GreaterThanOrEqualToSegment" => Some("comparison_operator"),
            "GreaterThanSegment" => Some("comparison_operator"),
            "GroupByClauseSegment" => Some("groupby_clause"),
            "GroupingExpressionList" => Some("grouping_expression_list"),
            "GroupingSetsClauseSegment" => Some("grouping_sets_clause"),
            "HavingClauseSegment" => Some("having_clause"),
            "IdentifierSegment" => Some("identifier"),
            "ImplicitIndent" => Some("indent"),
            "ImportForeignSchemaStatementSegment" => Some("import_foreign_schema_statement"),
            "Indent" => Some("indent"),
            "IndexAccessMethodSegment" => Some("index_access_method"),
            "IndexColumnDefinitionSegment" => Some("index_column_definition"),
            "IndexElementOptionsSegment" => Some("index_element_options"),
            "IndexElementSegment" => Some("index_element"),
            "IndexParametersSegment" => Some("index_parameters"),
            "IndexReferenceSegment" => Some("index_reference"),
            "InsertStatementSegment" => Some("insert_statement"),
            "IntervalExpressionSegment" => Some("interval_expression"),
            "IntoClauseSegment" => Some("into_clause"),
            "JoinClauseSegment" => Some("join_clause"),
            "JoinOnConditionSegment" => Some("join_on_condition"),
            "KeywordSegment" => Some("keyword"),
            "LambdaExpressionSegment" => Some("lambda_function"),
            "LanguageClauseSegment" => Some("language_clause"),
            "LessThanOrEqualToSegment" => Some("comparison_operator"),
            "LessThanSegment" => Some("comparison_operator"),
            "LikeOptionSegment" => Some("like_option_segment"),
            "LimitClauseSegment" => Some("limit_clause"),
            "ListComprehensionExpressionSegment" => Some("list_comprehension"),
            "ListenStatementSegment" => Some("listen_statement"),
            "LiteralKeywordSegment" => Some("literal"),
            "LiteralSegment" => Some("literal"),
            "LoadStatementSegment" => Some("load_statement"),
            "LocalAliasSegment" => Some("local_alias_segment"),
            "LockTableStatementSegment" => Some("lock_table_statement"),
            "MLTableExpressionSegment" => Some("ml_table_expression"),
            "MapTypeSchemaSegment" => Some("map_type_schema"),
            "MapTypeSegment" => Some("map_type"),
            "MatchConditionSegment" => Some("match_condition"),
            "MergeDeleteClauseSegment" => Some("merge_delete_clause"),
            "MergeInsertClauseSegment" => Some("merge_insert_clause"),
            "MergeMatchSegment" => Some("merge_match"),
            "MergeMatchedClauseSegment" => Some("merge_when_matched_clause"),
            "MergeNotMatchedClauseSegment" => Some("merge_when_not_matched_clause"),
            "MergeStatementSegment" => Some("merge_statement"),
            "MergeUpdateClauseSegment" => Some("merge_update_clause"),
            "MetaCommandQueryBufferStatement" => Some("meta_command_statement"),
            "NamedArgumentSegment" => Some("named_argument"),
            "NamedWindowExpressionSegment" => Some("named_window_expression"),
            "NamedWindowSegment" => Some("named_window"),
            "NewlineSegment" => Some("newline"),
            "NotEqualToSegment" => Some("comparison_operator"),
            "NotExtendLeftSegment" => Some("comparison_operator"),
            "NotExtendRightSegment" => Some("comparison_operator"),
            "NotifyStatementSegment" => Some("notify_statement"),
            "ObjectLiteralElementSegment" => Some("object_literal_element"),
            "ObjectLiteralSegment" => Some("object_literal"),
            "ObjectReferenceSegment" => Some("object_reference"),
            "OffsetClauseSegment" => Some("offset_clause"),
            "OperationClassReferenceSegment" => Some("operation_class_reference"),
            "OperatorClassReferenceSegment" => Some("operator_class_reference"),
            "OrderByClauseSegment" => Some("orderby_clause"),
            "OverClauseSegment" => Some("over_clause"),
            "OverlapSegment" => Some("comparison_operator"),
            "OverlapsClauseSegment" => Some("overlaps_clause"),
            "PartitionBoundSpecSegment" => Some("partition_bound_spec"),
            "PartitionClauseSegment" => Some("partitionby_clause"),
            "PathSegment" => Some("path_segment"),
            "PrepareStatementSegment" => Some("prepare_statement"),
            "PsqlVariableGrammar" => Some("psql_variable"),
            "PublicationObjectsSegment" => Some("publication_objects"),
            "PublicationReferenceSegment" => Some("publication_reference"),
            "PublicationTableSegment" => Some("publication_table"),
            "QualifiedNumericLiteralSegment" => Some("numeric_literal"),
            "QualifiedOperatorSegment" => Some("qualified_operator"),
            "QualifyClauseSegment" => Some("qualify_clause"),
            "RawSegment" => Some("raw"),
            "ReassignOwnedStatementSegment" => Some("reassign_owned_statement"),
            "RefreshMaterializedViewStatementSegment" => Some("refresh_materialized_view_statement"),
            "ReindexStatementSegment" => Some("reindex_statement_segment"),
            "RelationOptionSegment" => Some("relation_option"),
            "RelationOptionsSegment" => Some("relation_options"),
            "ResetSessionAuthorizationStatementSegment" => Some("reset_session_authorization_statement"),
            "ResetStatementSegment" => Some("reset_statement"),
            "RoleReferenceSegment" => Some("role_reference"),
            "RollupFunctionNameSegment" => Some("function_name"),
            "SamplingExpressionSegment" => Some("sample_expression"),
            "SchemaReferenceSegment" => Some("schema_reference"),
            "SecurityLabelStatementSegment" => Some("security_label_statement"),
            "SelectClauseElementSegment" => Some("select_clause_element"),
            "SelectClauseModifierSegment" => Some("select_clause_modifier"),
            "SelectClauseSegment" => Some("select_clause"),
            "SelectStatementSegment" => Some("select_statement"),
            "SemiStructuredAccessorSegment" => Some("semi_structured_expression"),
            "SequenceReferenceSegment" => Some("sequence_reference"),
            "ServerReferenceSegment" => Some("server_reference"),
            "SetClauseListSegment" => Some("set_clause_list"),
            "SetClauseSegment" => Some("set_clause"),
            "SetConstraintsStatementSegment" => Some("set_constraint_statement"),
            "SetExpressionSegment" => Some("set_expression"),
            "SetOperatorSegment" => Some("set_operator"),
            "SetSchemaStatementSegment" => Some("set_schema_statement"),
            "SetSessionAuthorizationStatementSegment" => Some("set_session_authorization_statement"),
            "SetStatementSegment" => Some("set_statement"),
            "ShorthandCastSegment" => Some("cast_expression"),
            "ShowStatementSegment" => Some("show_statement"),
            "SimplifiedPivotExpressionSegment" => Some("simplified_pivot"),
            "SimplifiedUnpivotExpressionSegment" => Some("simplified_unpivot"),
            "SingleIdentifierListSegment" => Some("identifier_list"),
            "SizedArrayTypeSegment" => Some("sized_array_type"),
            "StatementSegment" => Some("statement"),
            "StatisticsReferenceSegment" => Some("statistics_reference"),
            "StructLiteralSegment" => Some("struct_literal"),
            "StructTypeSchemaSegment" => Some("struct_type_schema"),
            "StructTypeSegment" => Some("struct_type"),
            "SubscriptionReferenceSegment" => Some("subscription_reference"),
            "SymbolSegment" => Some("symbol"),
            "TableConstraintSegment" => Some("table_constraint"),
            "TableConstraintUsingIndexSegment" => Some("table_constraint"),
            "TableEndClauseSegment" => Some("table_end_clause_segment"),
            "TableExpressionSegment" => Some("table_expression"),
            "TableReferenceSegment" => Some("table_reference"),
            "TablespaceReferenceSegment" => Some("tablespace_reference"),
            "TagReferenceSegment" => Some("tag_reference"),
            "TemporalQuerySegment" => Some("temporal_query"),
            "TimeZoneGrammar" => Some("time_zone_grammar"),
            "TransactionStatementSegment" => Some("transaction_statement"),
            "TriggerReferenceSegment" => Some("trigger_reference"),
            "TruncateStatementSegment" => Some("truncate_table"),
            "TupleSegment" => Some("tuple"),
            "TypedArrayLiteralSegment" => Some("typed_array_literal"),
            "TypedStructLiteralSegment" => Some("typed_struct_literal"),
            "UnlistenStatementSegment" => Some("unlisten_statement"),
            "UnorderedSelectStatementSegment" => Some("select_statement"),
            "UnorderedSetExpressionSegment" => Some("set_expression"),
            "UpdateStatementSegment" => Some("update_statement"),
            "UseStatementSegment" => Some("use_statement"),
            "VacuumStatementSegment" => Some("vacuum_statement"),
            "ValuesClauseSegment" => Some("values_clause"),
            "VersionIdentifierSegment" => Some("version_identifier"),
            "WellKnownTextGeometrySegment" => Some("wkt_geometry_type"),
            "WhenClauseSegment" => Some("when_clause"),
            "WhereClauseSegment" => Some("where_clause"),
            "WhitespaceSegment" => Some("whitespace"),
            "WildcardExcludeExpressionSegment" => Some("wildcard_exclude"),
            "WildcardExpressionSegment" => Some("wildcard_expression"),
            "WildcardIdentifierSegment" => Some("wildcard_identifier"),
            "WildcardPatternMatchingSegment" => Some("wildcard_pattern_matching"),
            "WildcardRenameExpressionSegment" => Some("wildcard_rename"),
            "WildcardReplaceExpressionSegment" => Some("wildcard_replace"),
            "WindowSpecificationSegment" => Some("window_specification"),
            "WithCheckOptionSegment" => Some("with_check_option"),
            "WithCompoundNonSelectStatementSegment" => Some("with_compound_statement"),
            "WithCompoundStatementSegment" => Some("with_compound_statement"),
            "WithDataClauseSegment" => Some("with_data_clause"),
            "WithFillSegment" => Some("with_fill"),
            "WithNoSchemaBindingClauseSegment" => Some("with_no_schema_binding_clause"),
            "WithinGroupClauseSegment" => Some("withingroup_clause"),
            "WordSegment" => Some("word"),
            _ => None,
    }
}

pub fn get_duckdb_root_grammar() -> Arc<Grammar> {
    get_duckdb_segment_grammar(
        "FileSegment"
    ).expect("Root grammar missing.")
}

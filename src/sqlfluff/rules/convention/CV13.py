"""Implementation of Rule CV13."""

from typing import Optional

from sqlfluff.core.rules import BaseRule, LintResult, RuleContext
from sqlfluff.core.rules.crawlers import SegmentSeekerCrawler


class Rule_CV13(BaseRule):
    """Discourage use of SERIAL and similar pseudo-types (PostgreSQL specific).

    .. note::
       This rule only applies to PostgreSQL dialects since the
       ``GENERATED AS IDENTITY`` syntax is PostgreSQL-specific.

    PostgreSQL introduced support for ``GENERATED ALWAYS AS IDENTITY``
    and ``GENERATED BY DEFAULT AS IDENTITY`` in version 10 (2017) as part
    of the SQL:2003 standard. This approach is now considered best practice
    over the PostgreSQL-specific SERIAL types for several reasons:

    - **SQL Standard Compliance**: IDENTITY columns are part of the SQL
      standard, making code more portable.
    - **Explicit Intent**: More clear and safer behavior (prevents accidental
      manual insertions with ``ALWAYS``).
    - **Modern Best Practice**: Recommended by PostgreSQL documentation
      for new projects.

    **Anti-pattern**

    Using ``SERIAL``, ``BIGSERIAL``, ``SMALLSERIAL`` or their aliases
    ``SERIAL2``, ``SERIAL4``, ``SERIAL8``.

    .. code-block:: sql
       :force:

        CREATE TABLE my_table (
            id SERIAL PRIMARY KEY,
            big_id BIGSERIAL,
            small_id SMALLSERIAL
        );

    **Best practice**

    Use ``GENERATED ALWAYS AS IDENTITY`` or
    ``GENERATED BY DEFAULT AS IDENTITY`` instead.

    .. code-block:: sql
       :force:

        CREATE TABLE my_table (
            id INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
            big_id BIGINT GENERATED ALWAYS AS IDENTITY,
            small_id SMALLINT GENERATED ALWAYS AS IDENTITY
        );
    """

    name = "convention.identity_datatype"
    aliases = ("L069",)
    groups = ("all", "convention")
    crawl_behaviour = SegmentSeekerCrawler({"data_type"})
    is_fix_compatible = False

    # SERIAL types to detect (mapped to their base integer type for reference)
    _serial_types = {
        "SERIAL": "INTEGER",
        "SERIAL4": "INTEGER",
        "BIGSERIAL": "BIGINT",
        "SERIAL8": "BIGINT",
        "SMALLSERIAL": "SMALLINT",
        "SERIAL2": "SMALLINT",
    }

    def _eval(self, context: RuleContext) -> Optional[LintResult]:
        """Check for SERIAL pseudo-types in data_type segments."""
        # Only check PostgreSQL dialects
        if context.dialect.name not in ("postgres", "redshift"):
            return None

        # Look through the data_type segment for SERIAL keywords
        for segment in context.segment.recursive_crawl("keyword"):
            type_name = segment.raw_upper
            if type_name in self._serial_types:
                base_type = self._serial_types[type_name]
                return LintResult(
                    anchor=segment,
                    description=(
                        f"Use '{base_type} GENERATED ALWAYS AS IDENTITY' "
                        f"or '{base_type} GENERATED BY DEFAULT AS IDENTITY' "
                        f"instead of '{type_name}'."
                    ),
                )
        return None
